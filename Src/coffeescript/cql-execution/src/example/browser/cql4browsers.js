(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Code, CodeService, ValueSet, ref;

  ref = require('./datatypes/datatypes'), Code = ref.Code, ValueSet = ref.ValueSet;

  CodeService = (function() {
    function CodeService(valueSetsJson) {
      var code, codes, oid, version;
      if (valueSetsJson == null) {
        valueSetsJson = {};
      }
      this.valueSets = {};
      for (oid in valueSetsJson) {
        this.valueSets[oid] = {};
        for (version in valueSetsJson[oid]) {
          codes = (function() {
            var i, len, ref1, results1;
            ref1 = valueSetsJson[oid][version];
            results1 = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              code = ref1[i];
              results1.push(new Code(code.code, code.system, code.version));
            }
            return results1;
          })();
          this.valueSets[oid][version] = new ValueSet(oid, version, codes);
        }
      }
    }

    CodeService.prototype.findValueSetsByOid = function(oid) {
      var ref1, results1, valueSet, version;
      ref1 = this.valueSets[oid];
      results1 = [];
      for (version in ref1) {
        valueSet = ref1[version];
        results1.push(valueSet);
      }
      return results1;
    };

    CodeService.prototype.findValueSet = function(oid, version) {
      var ref1, result, results;
      oid = oid.replace("urn:oid:", "");
      if (version != null) {
        result = (ref1 = this.valueSets[oid]) != null ? ref1[version] : void 0;
        if (result) {
          return result;
        }
      }
      results = this.findValueSetsByOid(oid);
      if (results.length === 0) {
        return null;
      } else {
        return results.reduce(function(a, b) {
          if (a.version > b.version) {
            return a;
          } else {
            return b;
          }
        });
      }
    };

    return CodeService;

  })();

  module.exports.CodeService = CodeService;

}).call(this);



},{"./datatypes/datatypes":6}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DT, element, i, len, ref;

  DT = require("./datatypes/datatypes");

  ref = Object.keys(DT);
  for (i = 0, len = ref.length; i < len; i++) {
    element = ref[i];
    module.exports[element] = DT[element];
  }

}).call(this);



},{"./datatypes/datatypes":6}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DT, FHIR, Patient, PatientSource, Record, toDate, typeIsArray;

  DT = require('./datatypes/datatypes');

  FHIR = require('./fhir/models');

  typeIsArray = require('./util/util').typeIsArray;

  toDate = function(str) {
    if (typeof str === 'string') {
      return new Date(str);
    } else {
      return null;
    }
  };

  Record = (function() {
    function Record(json1) {
      this.json = json1;
    }

    Record.prototype.get = function(field) {
      return this.json[field];
    };

    Record.prototype.getDate = function(field) {
      var val;
      val = this.get(field);
      if (val != null) {
        return DT.DateTime.parse(val);
      } else {
        return null;
      }
    };

    Record.prototype.getInterval = function(field) {
      var end, start, val;
      val = this.get(field);
      if ((val != null) && typeof val === 'object') {
        start = val.start != null ? DT.DateTime.parse(val.start) : null;
        end = val.end != null ? DT.DateTime.parse(val.end) : null;
        return new DT.Interval(start, end);
      }
    };

    Record.prototype.getDateOrInterval = function(field) {
      var val;
      val = this.get(field);
      if ((val != null) && typeof val === 'object') {
        return this.getInterval(field);
      } else {
        return this.getDate(field);
      }
    };

    Record.prototype.getCode = function(field) {
      var val;
      val = this.get(field);
      if ((val != null) && typeof val === 'object') {
        return new DT.Code(val.code, val.system, val.version);
      }
    };

    return Record;

  })();

  Patient = (function() {
    function Patient(json) {
      var base, i, len, name, r, ref, ref1;
      this.identifier = json.identifier;
      this.name = json.name;
      this.gender = json.gender;
      this.birthDate = json.birthDate != null ? DT.DateTime.parse(json.birthDate) : void 0;
      this.records = {};
      ref1 = (ref = json.records) != null ? ref : [];
      for (i = 0, len = ref1.length; i < len; i++) {
        r = ref1[i];
        if ((base = this.records)[name = r.profile] == null) {
          base[name] = [];
        }
        this.records[r.profile].push(new Record(r));
      }
    }

    Patient.prototype.findRecords = function(profile) {
      var ref;
      if (profile === 'patient-qicore-qicore-patient') {
        return [this];
      } else {
        return (ref = this.records[profile]) != null ? ref : [];
      }
    };

    return Patient;

  })();

  FHIR.Patient.prototype.records = function() {
    var base, i, len, name, r, ref, ref1;
    this._records = {};
    ref1 = (ref = this.json.records) != null ? ref : [];
    for (i = 0, len = ref1.length; i < len; i++) {
      r = ref1[i];
      if ((base = this._records)[name = r.profile] == null) {
        base[name] = [];
      }
      this._records[r.profile].push(new Record(r));
    }
    return this._records;
  };

  FHIR.Patient.prototype.findRecords = function(profile) {
    var ref, ref1;
    if (profile === 'patient-qicore-qicore-patient') {
      return [this];
    } else {
      return (ref = (ref1 = this._bundle) != null ? ref1.findRecords(profile) : void 0) != null ? ref : [];
    }
  };

  FHIR.Bundle.prototype.findRecords = function(profile) {
    var e, filtered, i, len, r, results;
    filtered = this.entry().filter(function(e) {
      var ref, ref1, ref2;
      return ((ref = e.resource()) != null ? (ref1 = ref.meta()) != null ? (ref2 = ref1.profile()) != null ? ref2.indexOf(profile) : void 0 : void 0 : void 0) > -1;
    });
    results = [];
    for (i = 0, len = filtered.length; i < len; i++) {
      e = filtered[i];
      r = e.resource();
      r._bundle = this;
      results.push(r);
    }
    return results;
  };

  FHIR.Bundle.prototype.findRecord = function(profile) {
    return this.findRecords(profile)[0];
  };

  FHIR.Base.prototype.get = function(field) {
    var ref;
    return (ref = this[field]) != null ? ref.call(this) : void 0;
  };

  FHIR.Base.prototype.getDate = function(field) {
    var val;
    val = this.get(field);
    if (val instanceof DT.DateTime) {
      return val;
    } else if (typeof val === "string") {
      return DT.DateTime.parse(val);
    }
  };

  FHIR.Base.prototype.getInterval = function(field) {
    var val;
    val = this.get(field);
    if (val(instannceOf(FHIR.Period))) {
      return this.periodToInterval(val);
    }
  };

  FHIR.Base.prototype.getDateOrInterval = function(field) {
    var val;
    val = this.get(field);
    if (val instanceof FHIR.Period) {
      return this.periodToInterval(val);
    } else if (typeof val === "string") {
      return DT.DateTime.parse(val);
    } else if (val instanceof DT.DateTime) {
      return val;
    }
  };

  FHIR.Base.prototype.getCode = function(field) {
    var val;
    val = this.get(field);
    return this.toCode(val);
  };

  FHIR.Base.prototype.toCode = function(val) {
    var c, i, len, results;
    if (typeIsArray(val)) {
      results = [];
      for (i = 0, len = val.length; i < len; i++) {
        c = val[i];
        results.push(this.toCode(c));
      }
      return results;
    } else if (val instanceof FHIR.CodeableConcept) {
      return this.codableConceptToCodes(val);
    } else if (val instanceof FHIR.Coding) {
      return this.codingToCode(val);
    }
  };

  FHIR.Base.prototype.codableConceptToCodes = function(cc) {
    var c, i, len, ref, results;
    ref = cc.coding();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      results.push(this.codingToCode(c));
    }
    return results;
  };

  FHIR.Base.prototype.codingToCode = function(coding) {
    return new DT.Code(coding.code(), coding.system(), coding.version());
  };

  FHIR.Base.prototype.periodToInterval = function(val) {
    var end, start;
    if (val instanceof FHIR.Period) {
      start = val.getDate("start");
      end = val.getDate("end");
      return new DT.Interval(start, end);
    }
  };

  PatientSource = (function() {
    function PatientSource(patients) {
      this.patients = patients;
      this.nextPatient();
    }

    PatientSource.prototype.currentPatient = function() {
      return this.current_patient;
    };

    PatientSource.prototype.nextPatient = function() {
      var ref;
      this.current = this.patients.shift();
      this.current_bundle = this.current ? new FHIR.Bundle(this.current) : void 0;
      return this.current_patient = (ref = this.current_bundle) != null ? ref.findRecord("patient-qicore-qicore-patient") : void 0;
    };

    return PatientSource;

  })();

  module.exports.Patient = Patient;

  module.exports.PatientSource = PatientSource;

}).call(this);



},{"./datatypes/datatypes":6,"./fhir/models":90,"./util/util":135}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var codeservice, context, datatypes, exec, expression, library, patient, quantity, repository, results;

  library = require('./elm/library');

  quantity = require('./elm/quantity');

  expression = require('./elm/expression');

  repository = require('./runtime/repository');

  context = require('./runtime/context');

  exec = require('./runtime/executor');

  results = require('./runtime/results');

  datatypes = require('./datatypes/datatypes');

  patient = require('./cql-patient');

  codeservice = require('./cql-code-service');

  module.exports.Library = library.Library;

  module.exports.Repository = repository.Repository;

  module.exports.Context = context.Context;

  module.exports.PatientContext = context.PatientContext;

  module.exports.PopulationContext = context.PopulationContext;

  module.exports.Executor = exec.Executor;

  module.exports.Results = results.Results;

  module.exports.Code = datatypes.Code;

  module.exports.Quantity = quantity.Quantity;

  module.exports.Expression = expression.Expression;

  module.exports.ValueSet = datatypes.ValueSet;

  module.exports.DateTime = datatypes.DateTime;

  module.exports.Interval = datatypes.Interval;

  module.exports.Patient = patient.Patient;

  module.exports.PatientSource = patient.PatientSource;

  module.exports.CodeService = codeservice.CodeService;

}).call(this);



},{"./cql-code-service":1,"./cql-patient":3,"./datatypes/datatypes":6,"./elm/expression":20,"./elm/library":25,"./elm/quantity":32,"./runtime/context":129,"./runtime/executor":130,"./runtime/repository":131,"./runtime/results":132}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Code, CodeSystem, Concept, ValueSet, typeIsArray,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.Code = Code = (function() {
    function Code(code1, system1, version1, display) {
      this.code = code1;
      this.system = system1;
      this.version = version1;
      this.display = display;
    }

    Code.prototype.hasCode = function(code) {
      if (this.code === code) {
        return true;
      } else {
        return false;
      }
    };

    return Code;

  })();

  module.exports.Concept = Concept = (function() {
    function Concept(codes, text) {
      this.codes = codes != null ? codes : [];
      this.text = text;
    }

    return Concept;

  })();

  module.exports.ValueSet = ValueSet = (function() {
    function ValueSet(oid, version1, codes) {
      this.oid = oid;
      this.version = version1;
      this.codes = codes != null ? codes : [];
    }

    ValueSet.prototype.hasCode = function(code, system, version) {
      var c, matches, ref;
      if ((code != null) && typeIsArray(code.codes)) {
        code = code.codes;
      }
      if (typeIsArray(code)) {
        matches = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = code.length; i < len; i++) {
            c = code[i];
            results.push(this.hasCode(c));
          }
          return results;
        }).call(this);
        return indexOf.call(matches, true) >= 0;
      }
      if (code instanceof Object) {
        ref = [code.code, code.system, code.version], code = ref[0], system = ref[1], version = ref[2];
      }
      matches = (function() {
        var i, len, ref1, results;
        ref1 = this.codes;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          c = ref1[i];
          if (c.code === code) {
            results.push(c);
          }
        }
        return results;
      }).call(this);
      if (system != null) {
        matches = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = matches.length; i < len; i++) {
            c = matches[i];
            if (c.system === system) {
              results.push(c);
            }
          }
          return results;
        })();
      }
      if (version != null) {
        matches = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = matches.length; i < len; i++) {
            c = matches[i];
            if (c.version === version) {
              results.push(c);
            }
          }
          return results;
        })();
      }
      return matches.length > 0;
    };

    ValueSet.prototype.matchCode = function(code, system, version) {
      var c, matches;
      matches = (function() {
        var i, len, ref, results;
        ref = this.codes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c.code === code) {
            results.push(c);
          }
        }
        return results;
      }).call(this);
      if (system != null) {
        matches = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = matches.length; i < len; i++) {
            c = matches[i];
            if (c.system === system) {
              results.push(c);
            }
          }
          return results;
        })();
      }
      if (version != null) {
        matches = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = matches.length; i < len; i++) {
            c = matches[i];
            if (c.version === version) {
              results.push(c);
            }
          }
          return results;
        })();
      }
      return matches.length > 0;
    };

    return ValueSet;

  })();

  module.exports.CodeSystem = CodeSystem = (function() {
    function CodeSystem(id, version1) {
      this.id = id;
      this.version = version1;
    }

    return CodeSystem;

  })();

}).call(this);



},{"../util/util":135}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var clinical, datetime, element, i, interval, j, len, len1, lib, libs, logic, ref, uncertainty;

  logic = require('./logic');

  clinical = require('./clinical');

  uncertainty = require('./uncertainty');

  datetime = require('./datetime');

  interval = require('./interval');

  libs = [logic, clinical, uncertainty, datetime, interval];

  for (i = 0, len = libs.length; i < len; i++) {
    lib = libs[i];
    ref = Object.keys(lib);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      element = ref[j];
      module.exports[element] = lib[element];
    }
  }

}).call(this);



},{"./clinical":5,"./datetime":7,"./interval":9,"./logic":10,"./uncertainty":11}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DateTime, Uncertainty;

  Uncertainty = require('./uncertainty').Uncertainty;

  module.exports.DateTime = DateTime = (function() {
    DateTime.Unit = {
      YEAR: 'year',
      MONTH: 'month',
      DAY: 'day',
      HOUR: 'hour',
      MINUTE: 'minute',
      SECOND: 'second',
      MILLISECOND: 'millisecond'
    };

    DateTime.FIELDS = [DateTime.Unit.YEAR, DateTime.Unit.MONTH, DateTime.Unit.DAY, DateTime.Unit.HOUR, DateTime.Unit.MINUTE, DateTime.Unit.SECOND, DateTime.Unit.MILLISECOND];

    DateTime.parse = function(string) {
      var arg, args, match, num, regex;
      match = regex = /(\d{4})(-(\d{2}))?(-(\d{2}))?(T((\d{2})(\:(\d{2})(\:(\d{2})(\.(\d+))?)?)?)?(([+-])(\d{2})(\:?(\d{2}))?)?)?/.exec(string);
      if ((match != null ? match[0] : void 0) === string) {
        args = [match[1], match[3], match[5], match[8], match[10], match[12], match[14]];
        if (args[6] != null) {
          args[6] = (args[6] + "00").substring(0, 3);
        }
        args = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = args.length; i < len; i++) {
            arg = args[i];
            results.push(arg != null ? parseInt(arg, 10) : void 0);
          }
          return results;
        })();
        if (match[17] != null) {
          num = parseInt(match[17], 10) + (match[19] != null ? parseInt(match[19], 10) / 60 : 0);
          args.push(match[16] === '+' ? num : num * -1);
        }
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(DateTime, args, function(){});
      } else {
        return null;
      }
    };

    DateTime.fromDate = function(date, timezoneOffset) {
      if (timezoneOffset != null) {
        date = new Date(date.getTime() + (timezoneOffset * 60 * 60 * 1000));
        return new DateTime(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), timezoneOffset);
      } else {
        return new DateTime(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
      }
    };

    function DateTime(year, month, day, hour, minute, second, millisecond, timezoneOffset1) {
      this.year = year != null ? year : null;
      this.month = month != null ? month : null;
      this.day = day != null ? day : null;
      this.hour = hour != null ? hour : null;
      this.minute = minute != null ? minute : null;
      this.second = second != null ? second : null;
      this.millisecond = millisecond != null ? millisecond : null;
      this.timezoneOffset = timezoneOffset1;
      if (this.timezoneOffset == null) {
        this.timezoneOffset = (new Date()).getTimezoneOffset() / 60 * -1;
      }
    }

    DateTime.prototype.copy = function() {
      return new DateTime(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    };

    DateTime.prototype.successor = function() {
      if (this.millisecond != null) {
        return this.add(1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.predecessor = function() {
      if (this.millisecond != null) {
        return this.add(-1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(-1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(-1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(-1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(-1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.convertToTimezoneOffset = function(timezoneOffset) {
      var d;
      if (timezoneOffset == null) {
        timezoneOffset = 0;
      }
      d = DateTime.fromDate(this.toJSDate(), timezoneOffset);
      return d.reducedPrecision(this.getPrecision());
    };

    DateTime.prototype.sameAs = function(other, precision) {
      var diff;
      if (precision == null) {
        precision = DateTime.Unit.MILLISECOND;
      }
      if (!(other instanceof DateTime)) {
        null;
      }
      diff = this.durationBetween(other, precision);
      switch (false) {
        case !(diff.low === 0 && diff.high === 0):
          return true;
        case !(diff.low <= 0 && diff.high >= 0):
          return null;
        default:
          return false;
      }
    };

    DateTime.prototype.equals = function(other) {
      return this.sameAs(other, DateTime.Unit.MILLISECOND);
    };

    DateTime.prototype.sameOrBefore = function(other, precision) {
      var diff;
      if (precision == null) {
        precision = DateTime.Unit.MILLISECOND;
      }
      if (!(other instanceof DateTime)) {
        return false;
      }
      diff = this.durationBetween(other, precision);
      switch (false) {
        case !(diff.low >= 0 && diff.high >= 0):
          return true;
        case !(diff.low < 0 && diff.high < 0):
          return false;
        default:
          return null;
      }
    };

    DateTime.prototype.sameOrAfter = function(other, precision) {
      var diff;
      if (precision == null) {
        precision = DateTime.Unit.MILLISECOND;
      }
      if (!(other instanceof DateTime)) {
        return false;
      }
      diff = this.durationBetween(other, precision);
      switch (false) {
        case !(diff.low <= 0 && diff.high <= 0):
          return true;
        case !(diff.low > 0 && diff.high > 0):
          return false;
        default:
          return null;
      }
    };

    DateTime.prototype.before = function(other, precision) {
      var diff;
      if (precision == null) {
        precision = DateTime.Unit.MILLISECOND;
      }
      if (!(other instanceof DateTime)) {
        return false;
      }
      diff = this.durationBetween(other, precision);
      switch (false) {
        case !(diff.low > 0 && diff.high > 0):
          return true;
        case !(diff.low <= 0 && diff.high <= 0):
          return false;
        default:
          return null;
      }
    };

    DateTime.prototype.after = function(other, precision) {
      var diff;
      if (precision == null) {
        precision = DateTime.Unit.MILLISECOND;
      }
      if (!(other instanceof DateTime)) {
        return false;
      }
      diff = this.durationBetween(other, precision);
      switch (false) {
        case !(diff.low < 0 && diff.high < 0):
          return true;
        case !(diff.low >= 0 && diff.high >= 0):
          return false;
        default:
          return null;
      }
    };

    DateTime.prototype.add = function(offset, field) {
      var i, len, normalized, ref, result;
      result = this.copy();
      if (result[field] != null) {
        result[field] = result[field] + offset;
        normalized = DateTime.fromDate(result.toJSDate(), this.timezoneOffset);
        ref = DateTime.FIELDS;
        for (i = 0, len = ref.length; i < len; i++) {
          field = ref[i];
          if (result[field] != null) {
            result[field] = normalized[field];
          }
        }
      }
      return result;
    };

    DateTime.prototype.durationBetween = function(other, unitField) {
      var a, b;
      if (!(other instanceof DateTime)) {
        return null;
      }
      if (this.timezoneOffset !== other.timezoneOffset) {
        other = other.convertToTimezoneOffset(this.timezoneOffset);
      }
      a = this.toUncertainty(true);
      b = other.toUncertainty(true);
      return new Uncertainty(this._durationBetweenDates(a.high, b.low, unitField), this._durationBetweenDates(a.low, b.high, unitField));
    };

    DateTime.prototype._durationBetweenDates = function(a, b, unitField) {
      var msDiff, ref;
      ref = [a, b].map(function(x) {
        switch (unitField) {
          case DateTime.Unit.DAY:
            return new Date(x.getFullYear(), x.getMonth(), x.getDate());
          case DateTime.Unit.HOUR:
            return new Date(x.getFullYear(), x.getMonth(), x.getDate(), x.getHours());
          case DateTime.Unit.MINUTE:
            return new Date(x.getFullYear(), x.getMonth(), x.getDate(), x.getHours(), x.getMinutes());
          case DateTime.Unit.SECOND:
            return new Date(x.getFullYear(), x.getMonth(), x.getDate(), x.getHours(), x.getMinutes(), x.getSeconds());
          case DateTime.Unit.MILLISECOND:
            return new Date(x.getFullYear(), x.getMonth(), x.getDate(), x.getHours(), x.getMinutes(), x.getSeconds(), x.getMilliseconds());
          default:
            return x;
        }
      }), a = ref[0], b = ref[1];
      msDiff = b.getTime() - a.getTime();
      switch (unitField) {
        case DateTime.Unit.YEAR:
          return b.getFullYear() - a.getFullYear();
        case DateTime.Unit.MONTH:
          return b.getMonth() - a.getMonth() + (12 * (b.getFullYear() - a.getFullYear()));
        case DateTime.Unit.DAY:
          return Math.floor(msDiff / (24 * 60 * 60 * 1000));
        case DateTime.Unit.HOUR:
          return Math.floor(msDiff / (60 * 60 * 1000));
        case DateTime.Unit.MINUTE:
          return Math.floor(msDiff / (60 * 1000));
        case DateTime.Unit.SECOND:
          return Math.floor(msDiff / 1000);
        case DateTime.Unit.MILLISECOND:
          return msDiff;
        default:
          return null;
      }
    };

    DateTime.prototype.isPrecise = function() {
      return DateTime.FIELDS.every((function(_this) {
        return function(field) {
          return _this[field] != null;
        };
      })(this));
    };

    DateTime.prototype.isImprecise = function() {
      return !this.isPrecise();
    };

    DateTime.prototype.isMorePrecise = function(other) {
      var field, i, len, ref;
      ref = DateTime.FIELDS;
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if ((other[field] != null) && (this[field] == null)) {
          return false;
        }
      }
      return !this.isSamePrecision(other);
    };

    DateTime.prototype.isLessPrecise = function(other) {
      return !this.isSamePrecision(other) && !this.isMorePrecise(other);
    };

    DateTime.prototype.isSamePrecision = function(other) {
      var field, i, len, ref;
      ref = DateTime.FIELDS;
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if ((this[field] != null) && (other[field] == null)) {
          return false;
        }
        if ((this[field] == null) && (other[field] != null)) {
          return false;
        }
      }
      return true;
    };

    DateTime.prototype.getPrecision = function() {
      var result;
      result = null;
      if (this.year != null) {
        result = DateTime.Unit.YEAR;
      } else {
        return result;
      }
      if (this.month != null) {
        result = DateTime.Unit.MONTH;
      } else {
        return result;
      }
      if (this.day != null) {
        result = DateTime.Unit.DAY;
      } else {
        return result;
      }
      if (this.hour != null) {
        result = DateTime.Unit.HOUR;
      } else {
        return result;
      }
      if (this.minute != null) {
        result = DateTime.Unit.MINUTE;
      } else {
        return result;
      }
      if (this.second != null) {
        result = DateTime.Unit.SECOND;
      } else {
        return result;
      }
      if (this.millisecond != null) {
        result = DateTime.Unit.MILLISECOND;
      }
      return result;
    };

    DateTime.prototype.toUncertainty = function(ignoreTimezone) {
      var high, low, ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      low = this.toJSDate(ignoreTimezone);
      high = (new DateTime(this.year, (ref = this.month) != null ? ref : 12, (ref1 = this.day) != null ? ref1 : (new Date(this.year, (ref2 = this.month) != null ? ref2 : 12, 0)).getDate(), (ref3 = this.hour) != null ? ref3 : 23, (ref4 = this.minute) != null ? ref4 : 59, (ref5 = this.second) != null ? ref5 : 59, (ref6 = this.millisecond) != null ? ref6 : 999, this.timezoneOffset)).toJSDate(ignoreTimezone);
      return new Uncertainty(low, high);
    };

    DateTime.prototype.toJSDate = function(ignoreTimezone) {
      var d, h, mi, mo, ms, ref, ref1, ref2, ref3, ref4, ref5, s, y;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      ref5 = [this.year, (this.month != null ? this.month - 1 : 0), (ref = this.day) != null ? ref : 1, (ref1 = this.hour) != null ? ref1 : 0, (ref2 = this.minute) != null ? ref2 : 0, (ref3 = this.second) != null ? ref3 : 0, (ref4 = this.millisecond) != null ? ref4 : 0], y = ref5[0], mo = ref5[1], d = ref5[2], h = ref5[3], mi = ref5[4], s = ref5[5], ms = ref5[6];
      if ((this.timezoneOffset != null) && !ignoreTimezone) {
        return new Date(Date.UTC(y, mo, d, h, mi, s, ms) - (this.timezoneOffset * 60 * 60 * 1000));
      } else {
        return new Date(y, mo, d, h, mi, s, ms);
      }
    };

    DateTime.prototype.toJSON = function() {
      return this.toString();
    };

    DateTime.prototype._pad = function(num) {
      return String("0" + num).slice(-2);
    };

    DateTime.prototype.toString = function() {
      var offsetHours, offsetMin, str;
      str = '';
      if (this.year != null) {
        str += this.year;
        if (this.month != null) {
          str += '-' + this._pad(this.month);
          if (this.day != null) {
            str += '-' + this._pad(this.day);
            if (this.hour != null) {
              str += 'T' + this._pad(this.hour);
              if (this.minute != null) {
                str += ':' + this._pad(this.minute);
                if (this.second != null) {
                  str += ':' + this._pad(this.second);
                  if (this.millisecond != null) {
                    str += '.' + this._pad(this.millisecond);
                  }
                }
              }
            }
          }
        }
      }
      if (str.indexOf('T') !== -1 && (this.timezoneOffset != null)) {
        str += this.timezoneOffset < 0 ? '-' : '+';
        offsetHours = Math.floor(Math.abs(this.timezoneOffset));
        str += this._pad(offsetHours);
        offsetMin = (Math.abs(this.timezoneOffset) - offsetHours) * 60;
        str += this._pad(offsetMin);
      }
      return str;
    };

    DateTime.prototype.getDate = function() {
      return this.reducedPrecision(DateTime.Unit.DAY);
    };

    DateTime.prototype.getTime = function() {
      return new DateTime(0, 1, 1, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    };

    DateTime.prototype.isTime = function() {
      return this.year === 0 && this.month === 1 && this.day === 1;
    };

    DateTime.prototype.reducedPrecision = function(unitField) {
      var field, fieldIndex, fieldsToRemove, i, len, reduced;
      if (unitField == null) {
        unitField = DateTime.Unit.MILLISECOND;
      }
      reduced = this.copy();
      if (unitField !== DateTime.Unit.MILLISECOND) {
        fieldIndex = DateTime.FIELDS.indexOf(unitField);
        fieldsToRemove = DateTime.FIELDS.slice(fieldIndex + 1);
        for (i = 0, len = fieldsToRemove.length; i < len; i++) {
          field = fieldsToRemove[i];
          reduced[field] = null;
        }
      }
      return reduced;
    };

    return DateTime;

  })();

}).call(this);



},{"./uncertainty":11}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Exception;

  module.exports.Exception = Exception = (function() {
    function Exception(message, wrapped) {
      this.message = message;
      this.wrapped = wrapped;
    }

    return Exception;

  })();

}).call(this);



},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DateTime, Interval, ThreeValuedLogic, Uncertainty, cmp, maxValueForInstance, minValueForInstance, predecessor, ref, successor;

  DateTime = require('./datetime').DateTime;

  Uncertainty = require('./uncertainty').Uncertainty;

  ThreeValuedLogic = require('./logic').ThreeValuedLogic;

  ref = require('../util/math'), successor = ref.successor, predecessor = ref.predecessor, maxValueForInstance = ref.maxValueForInstance, minValueForInstance = ref.minValueForInstance;

  cmp = require('../util/comparison');

  module.exports.Interval = Interval = (function() {
    var areDateTimes, areNumeric, highestNumericUncertainty, lowestNumericUncertainty;

    function Interval(low1, high1, lowClosed, highClosed) {
      this.low = low1;
      this.high = high1;
      this.lowClosed = lowClosed != null ? lowClosed : true;
      this.highClosed = highClosed != null ? highClosed : true;
    }

    Interval.prototype.contains = function(item) {
      var closed;
      if (item instanceof Interval) {
        throw new Error("Argument to contains must be a point");
      }
      closed = this.toClosed();
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, item), cmp.greaterThanOrEquals(closed.high, item));
    };

    Interval.prototype.properlyIncludes = function(other) {
      if (!(other instanceof Interval)) {
        throw new Error("Argument to properlyIncludes must be an interval");
      }
      return ThreeValuedLogic.and(this.includes(other), ThreeValuedLogic.not(cmp.equals(this, other)));
    };

    Interval.prototype.includes = function(other) {
      var a, b;
      if (!(other instanceof Interval)) {
        throw new Error("Argument to includes must be an interval");
      }
      a = this.toClosed();
      b = other.toClosed();
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(a.low, b.low), cmp.greaterThanOrEquals(a.high, b.high));
    };

    Interval.prototype.includedIn = function(other) {
      if (!(other instanceof Interval)) {
        throw new Error("Argument to includedIn must be an interval");
      }
      return other.includes(this);
    };

    Interval.prototype.overlaps = function(item) {
      var closed, high, itemClosed, low, ref1;
      closed = this.toClosed();
      ref1 = item instanceof Interval ? (itemClosed = item.toClosed(), [itemClosed.low, itemClosed.high]) : [item, item], low = ref1[0], high = ref1[1];
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high), cmp.greaterThanOrEquals(closed.high, low));
    };

    Interval.prototype.overlapsAfter = function(item) {
      var closed, high;
      closed = this.toClosed();
      high = item instanceof Interval ? item.toClosed().high : item;
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high), cmp.greaterThan(closed.high, high));
    };

    Interval.prototype.overlapsBefore = function(item) {
      var closed, low;
      closed = this.toClosed();
      low = item instanceof Interval ? item.toClosed().low : item;
      return ThreeValuedLogic.and(cmp.lessThan(closed.low, low), cmp.greaterThanOrEquals(closed.high, low));
    };

    areDateTimes = function(x, y) {
      return [x, y].every(function(z) {
        return z instanceof DateTime;
      });
    };

    areNumeric = function(x, y) {
      return [x, y].every(function(z) {
        return typeof z === 'number' || (z instanceof Uncertainty && typeof z.low === 'number');
      });
    };

    lowestNumericUncertainty = function(x, y) {
      var high, low;
      if (!(x instanceof Uncertainty)) {
        x = new Uncertainty(x);
      }
      if (!(y instanceof Uncertainty)) {
        y = new Uncertainty(y);
      }
      low = x.low < y.low ? x.low : y.low;
      high = x.high < y.high ? x.high : y.high;
      if (low !== high) {
        return new Uncertainty(low, high);
      } else {
        return low;
      }
    };

    highestNumericUncertainty = function(x, y) {
      var high, low;
      if (!(x instanceof Uncertainty)) {
        x = new Uncertainty(x);
      }
      if (!(y instanceof Uncertainty)) {
        y = new Uncertainty(y);
      }
      low = x.low > y.low ? x.low : y.low;
      high = x.high > y.high ? x.high : y.high;
      if (low !== high) {
        return new Uncertainty(low, high);
      } else {
        return low;
      }
    };

    Interval.prototype.union = function(other) {
      var a, b, h, hc, l, lc, ref1, ref2, ref3;
      if (!(other instanceof Interval)) {
        throw new Error("Argument to union must be an interval");
      }
      if (this.overlaps(other) || this.meets(other)) {
        ref1 = [this.toClosed(), other.toClosed()], a = ref1[0], b = ref1[1];
        ref2 = (function() {
          switch (false) {
            case !cmp.lessThanOrEquals(a.low, b.low):
              return [this.low, this.lowClosed];
            case !cmp.greaterThanOrEquals(a.low, b.low):
              return [other.low, other.lowClosed];
            case !areNumeric(a.low, b.low):
              return [lowestNumericUncertainty(a.low, b.low), true];
            case !(areDateTimes(a.low, b.low) && a.low.isMorePrecise(b.low)):
              return [other.low, other.lowClosed];
            default:
              return [this.low, this.lowClosed];
          }
        }).call(this), l = ref2[0], lc = ref2[1];
        ref3 = (function() {
          switch (false) {
            case !cmp.greaterThanOrEquals(a.high, b.high):
              return [this.high, this.highClosed];
            case !cmp.lessThanOrEquals(a.high, b.high):
              return [other.high, other.highClosed];
            case !areNumeric(a.low, b.low):
              return [highestNumericUncertainty(a.high, b.high), true];
            case !(areDateTimes(a.high, b.high) && a.high.isMorePrecise(b.high)):
              return [other.high, other.highClosed];
            default:
              return [this.high, this.highClosed];
          }
        }).call(this), h = ref3[0], hc = ref3[1];
        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    };

    Interval.prototype.intersect = function(other) {
      var a, b, h, hc, l, lc, ref1, ref2, ref3;
      if (!(other instanceof Interval)) {
        throw new Error("Argument to union must be an interval");
      }
      if (this.overlaps(other)) {
        ref1 = [this.toClosed(), other.toClosed()], a = ref1[0], b = ref1[1];
        ref2 = (function() {
          switch (false) {
            case !cmp.greaterThanOrEquals(a.low, b.low):
              return [this.low, this.lowClosed];
            case !cmp.lessThanOrEquals(a.low, b.low):
              return [other.low, other.lowClosed];
            case !areNumeric(a.low, b.low):
              return [highestNumericUncertainty(a.low, b.low), true];
            case !(areDateTimes(a.low, b.low) && b.low.isMorePrecise(a.low)):
              return [other.low, other.lowClosed];
            default:
              return [this.low, this.lowClosed];
          }
        }).call(this), l = ref2[0], lc = ref2[1];
        ref3 = (function() {
          switch (false) {
            case !cmp.lessThanOrEquals(a.high, b.high):
              return [this.high, this.highClosed];
            case !cmp.greaterThanOrEquals(a.high, b.high):
              return [other.high, other.highClosed];
            case !areNumeric(a.low, b.low):
              return [lowestNumericUncertainty(a.high, b.high), true];
            case !(areDateTimes(a.high, b.high) && b.high.isMorePrecise(a.high)):
              return [other.high, other.highClosed];
            default:
              return [this.high, this.highClosed];
          }
        }).call(this), h = ref3[0], hc = ref3[1];
        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    };

    Interval.prototype.except = function(other) {
      var ol, ola, olb;
      if (other === null) {
        return null;
      }
      if (!(other instanceof Interval)) {
        throw new Error("Argument to except must be an interval");
      }
      ol = this.overlaps(other);
      if (ol === true) {
        olb = this.overlapsBefore(other);
        ola = this.overlapsAfter(other);
        if (olb === true && ola === false) {
          return new Interval(this.low, other.low, this.lowClosed, !other.lowClosed);
        } else if (ola === true && olb === false) {
          return new Interval(other.high, this.high, !other.highClosed, this.highClosed);
        } else {
          return null;
        }
      } else if (ol === false) {
        return this;
      } else {
        return null;
      }
    };

    Interval.prototype.equals = function(other) {
      var a, b, ref1;
      if (other instanceof Interval) {
        ref1 = [this.toClosed(), other.toClosed()], a = ref1[0], b = ref1[1];
        return ThreeValuedLogic.and(cmp.equals(a.low, b.low), cmp.equals(a.high, b.high));
      } else {
        return false;
      }
    };

    Interval.prototype.after = function(other) {
      var closed;
      closed = this.toClosed();
      if (!!other.toClosed) {
        return cmp.greaterThan(closed.low, other.toClosed().high);
      } else {
        return cmp.greaterThan(closed.low, other);
      }
    };

    Interval.prototype.before = function(other) {
      var closed;
      closed = this.toClosed();
      if (!!other.toClosed) {
        return cmp.lessThan(closed.high, other.toClosed().low);
      } else {
        return cmp.lessThan(closed.high, other);
      }
    };

    Interval.prototype.meets = function(other) {
      return ThreeValuedLogic.or(this.meetsBefore(other), this.meetsAfter(other));
    };

    Interval.prototype.meetsAfter = function(other) {
      try {
        return cmp.equals(this.toClosed().low, successor(other.toClosed().high));
      } catch (error) {
        return false;
      }
    };

    Interval.prototype.meetsBefore = function(other) {
      try {
        return cmp.equals(this.toClosed().high, predecessor(other.toClosed().low));
      } catch (error) {
        return false;
      }
    };

    Interval.prototype.width = function() {
      var closed, diff;
      if (this.low instanceof DateTime || this.high instanceof DateTime) {
        throw new Error("Width of DateTime intervals is not supported");
      }
      closed = this.toClosed();
      if (closed.low instanceof Uncertainty || closed.high instanceof Uncertainty) {
        return null;
      } else {
        diff = Math.abs(closed.high - closed.low);
        return Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
      }
    };

    Interval.prototype.toClosed = function() {
      var high, low, point, ref1, ref2;
      point = (ref1 = this.low) != null ? ref1 : this.high;
      if (typeof point === 'number' || point instanceof DateTime || (point != null ? (ref2 = point.constructor) != null ? ref2.name : void 0 : void 0) === 'Quantity') {
        low = (function() {
          switch (false) {
            case !(this.lowClosed && (this.low == null)):
              return minValueForInstance(point);
            case !(!this.lowClosed && (this.low != null)):
              return successor(this.low);
            default:
              return this.low;
          }
        }).call(this);
        high = (function() {
          switch (false) {
            case !(this.highClosed && (this.high == null)):
              return maxValueForInstance(point);
            case !(!this.highClosed && (this.high != null)):
              return predecessor(this.high);
            default:
              return this.high;
          }
        }).call(this);
        if (low == null) {
          low = new Uncertainty(minValueForInstance(point), high);
        }
        if (high == null) {
          high = new Uncertainty(low, maxValueForInstance(point));
        }
        return new Interval(low, high, true, true);
      } else {
        return new Interval(this.low, this.high, true, true);
      }
    };

    return Interval;

  })();

}).call(this);



},{"../util/comparison":133,"../util/math":134,"./datetime":7,"./logic":10,"./uncertainty":11}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var ThreeValuedLogic,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports.ThreeValuedLogic = ThreeValuedLogic = (function() {
    function ThreeValuedLogic() {}

    ThreeValuedLogic.and = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, false) >= 0) {
        return false;
      } else if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return true;
      }
    };

    ThreeValuedLogic.or = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, true) >= 0) {
        return true;
      } else if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return false;
      }
    };

    ThreeValuedLogic.xor = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return val.reduce(function(a, b) {
          return (!a ^ !b) === 1;
        });
      }
    };

    ThreeValuedLogic.not = function(val) {
      if (val != null) {
        return !val;
      } else {
        return null;
      }
    };

    return ThreeValuedLogic;

  })();

}).call(this);



},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var ThreeValuedLogic, Uncertainty;

  ThreeValuedLogic = require('./logic').ThreeValuedLogic;

  module.exports.Uncertainty = Uncertainty = (function() {
    Uncertainty.from = function(obj) {
      if (obj instanceof Uncertainty) {
        return obj;
      } else {
        return new Uncertainty(obj);
      }
    };

    function Uncertainty(low, high) {
      var gt, ref;
      this.low = low != null ? low : null;
      this.high = high;
      gt = function(a, b) {
        if (typeof a.after === 'function') {
          return a.after(b);
        } else {
          return a > b;
        }
      };
      if (typeof this.high === 'undefined') {
        this.high = this.low;
      }
      if ((this.low != null) && (this.high != null) && gt(this.low, this.high)) {
        ref = [this.high, this.low], this.low = ref[0], this.high = ref[1];
      }
    }

    Uncertainty.prototype.isPoint = function() {
      var gte, lte;
      lte = function(a, b) {
        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrBefore(b);
        } else {
          return a <= b;
        }
      };
      gte = function(a, b) {
        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrAfter(b);
        } else {
          return a >= b;
        }
      };
      return (this.low != null) && (this.high != null) && lte(this.low, this.high) && gte(this.low, this.high);
    };

    Uncertainty.prototype.equals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(ThreeValuedLogic.or(this.lessThan(other), this.greaterThan(other)));
    };

    Uncertainty.prototype.lessThan = function(other) {
      var bestCase, lt, worstCase;
      lt = function(a, b) {
        if (typeof a.before === 'function') {
          return a.before(b);
        } else {
          return a < b;
        }
      };
      other = Uncertainty.from(other);
      bestCase = (this.low == null) || (other.high == null) || lt(this.low, other.high);
      worstCase = (this.high != null) && (other.low != null) && lt(this.high, other.low);
      if (bestCase === worstCase) {
        return bestCase;
      } else {
        return null;
      }
    };

    Uncertainty.prototype.greaterThan = function(other) {
      other = Uncertainty.from(other);
      return other.lessThan(this);
    };

    Uncertainty.prototype.lessThanOrEquals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(this.greaterThan(other));
    };

    Uncertainty.prototype.greaterThanOrEquals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(this.lessThan(other));
    };

    return Uncertainty;

  })();

}).call(this);



},{"./logic":10}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var AggregateExpression, AllTrue, AnyTrue, Avg, Count, Expression, Max, Median, Min, Mode, PopulationStdDev, PopulationVariance, Quantity, StdDev, Sum, Variance, allTrue, anyTrue, build, compact, numerical_sort, quantitiesOrArg, quantityOrValue, ref, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Expression = require('./expression').Expression;

  ref = require('../util/util'), typeIsArray = ref.typeIsArray, allTrue = ref.allTrue, anyTrue = ref.anyTrue, compact = ref.compact, numerical_sort = ref.numerical_sort;

  build = require('./builder').build;

  Quantity = require('./quantity');

  quantitiesOrArg = function(arr) {
    var i, j, len, ref1, unit, values;
    if (((ref1 = arr[0]) != null ? ref1.constructor.name : void 0) === "Quantity") {
      unit = arr[0].unit;
      values = [];
      for (j = 0, len = arr.length; j < len; j++) {
        i = arr[j];
        if (i.constructor.name === "Quantity" && i.unit === unit) {
          values.push(i.value);
        } else {
          return [];
        }
      }
      return compact(values);
    } else {
      return arr;
    }
  };

  quantityOrValue = function(value, arr) {
    var ref1;
    if ((arr != null ? (ref1 = arr[0]) != null ? ref1.constructor.name : void 0 : void 0) === "Quantity") {
      return Quantity.createQuantity(value, arr[0].unit);
    } else {
      return value;
    }
  };

  AggregateExpression = (function(superClass) {
    extend(AggregateExpression, superClass);

    function AggregateExpression(json) {
      AggregateExpression.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    return AggregateExpression;

  })(Expression);

  module.exports.Count = Count = (function(superClass) {
    extend(Count, superClass);

    function Count(json) {
      Count.__super__.constructor.apply(this, arguments);
    }

    Count.prototype.exec = function(ctx) {
      var arg;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        return compact(arg).length;
      }
    };

    return Count;

  })(AggregateExpression);

  module.exports.Sum = Sum = (function(superClass) {
    extend(Sum, superClass);

    function Sum(json) {
      Sum.__super__.constructor.apply(this, arguments);
    }

    Sum.prototype.exec = function(ctx) {
      var arg, filtered, val;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        arg = compact(arg);
        filtered = quantitiesOrArg(arg);
        val = filtered.length === 0 ? null : filtered.reduce(function(x, y) {
          return x + y;
        });
        return quantityOrValue(val, arg);
      }
    };

    return Sum;

  })(AggregateExpression);

  module.exports.Min = Min = (function(superClass) {
    extend(Min, superClass);

    function Min(json) {
      Min.__super__.constructor.apply(this, arguments);
    }

    Min.prototype.exec = function(ctx) {
      var arg, filtered;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        arg = compact(arg);
        filtered = numerical_sort(quantitiesOrArg(arg), "asc");
        return quantityOrValue(filtered[0], arg);
      }
    };

    return Min;

  })(AggregateExpression);

  module.exports.Max = Max = (function(superClass) {
    extend(Max, superClass);

    function Max(json) {
      Max.__super__.constructor.apply(this, arguments);
    }

    Max.prototype.exec = function(ctx) {
      var arg, filtered;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        arg = compact(arg);
        filtered = numerical_sort(quantitiesOrArg(arg), "desc");
        return quantityOrValue(filtered[0], arg);
      }
    };

    return Max;

  })(AggregateExpression);

  module.exports.Avg = Avg = (function(superClass) {
    extend(Avg, superClass);

    function Avg(json) {
      Avg.__super__.constructor.apply(this, arguments);
    }

    Avg.prototype.exec = function(ctx) {
      var arg, filtered, sum;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        arg = compact(arg);
        filtered = quantitiesOrArg(arg);
        if (filtered.length === 0) {
          return null;
        }
        sum = filtered.reduce(function(x, y) {
          return x + y;
        });
        return quantityOrValue(sum / filtered.length, arg);
      }
    };

    return Avg;

  })(AggregateExpression);

  module.exports.Median = Median = (function(superClass) {
    extend(Median, superClass);

    function Median(json) {
      Median.__super__.constructor.apply(this, arguments);
    }

    Median.prototype.exec = function(ctx) {
      var arg, filtered, v;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        arg = compact(arg);
        filtered = numerical_sort(quantitiesOrArg(arg, "asc"));
        if (filtered.length === 0) {
          return null;
        } else if (filtered.length % 2 === 1) {
          return quantityOrValue(filtered[(filtered.length - 1) / 2], arg);
        } else {
          v = (filtered[(filtered.length / 2) - 1] + filtered[filtered.length / 2]) / 2;
          return quantityOrValue(v, arg);
        }
      }
    };

    return Median;

  })(AggregateExpression);

  module.exports.Mode = Mode = (function(superClass) {
    extend(Mode, superClass);

    function Mode(json) {
      Mode.__super__.constructor.apply(this, arguments);
    }

    Mode.prototype.exec = function(ctx) {
      var arg, filtered, mode;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = compact(arg);
        mode = this.mode(filtered);
        if (mode.length === 1) {
          return mode[0];
        } else {
          return mode;
        }
      }
    };

    Mode.prototype.mode = function(arr) {
      var cnt, counts, elem, j, len, max, ref1, results;
      max = 0;
      counts = {};
      results = [];
      for (j = 0, len = arr.length; j < len; j++) {
        elem = arr[j];
        cnt = counts[elem] = ((ref1 = counts[elem]) != null ? ref1 : 0) + 1;
        if (cnt === max && indexOf.call(results, elem) < 0) {
          results.push(elem);
        } else if (cnt > max) {
          results = [elem];
          max = cnt;
        }
      }
      return results;
    };

    return Mode;

  })(AggregateExpression);

  module.exports.StdDev = StdDev = (function(superClass) {
    extend(StdDev, superClass);

    function StdDev(json) {
      StdDev.__super__.constructor.apply(this, arguments);
      this.type = "standard_deviation";
    }

    StdDev.prototype.exec = function(ctx) {
      var args, val;
      args = this.source.execute(ctx);
      if (typeIsArray(args)) {
        args = compact(args);
        val = quantitiesOrArg(args);
        if (val.length > 0) {
          return quantityOrValue(this.calculate(val), args);
        } else {
          return null;
        }
      }
    };

    StdDev.prototype.calculate = function(list) {
      var val;
      val = this.stats(list);
      if (val) {
        return val[this.type];
      }
    };

    StdDev.prototype.stats = function(list) {
      var j, len, mean, pop_dev, pop_var, sq, std_dev, std_var, sum, sumOfSquares;
      sum = list.reduce(function(x, y) {
        return x + y;
      });
      mean = sum / list.length;
      sumOfSquares = 0;
      for (j = 0, len = list.length; j < len; j++) {
        sq = list[j];
        sumOfSquares += Math.pow(sq - mean, 2);
      }
      std_var = (1 / list.length) * sumOfSquares;
      pop_var = (1 / (list.length - 1)) * sumOfSquares;
      std_dev = Math.sqrt(std_var);
      pop_dev = Math.sqrt(pop_var);
      return {
        standard_variance: std_var,
        population_variance: pop_var,
        standard_deviation: std_dev,
        population_deviation: pop_dev
      };
    };

    return StdDev;

  })(AggregateExpression);

  module.exports.PopulationStdDev = PopulationStdDev = (function(superClass) {
    extend(PopulationStdDev, superClass);

    function PopulationStdDev(json) {
      PopulationStdDev.__super__.constructor.apply(this, arguments);
      this.type = "population_deviation";
    }

    return PopulationStdDev;

  })(StdDev);

  module.exports.Variance = Variance = (function(superClass) {
    extend(Variance, superClass);

    function Variance(json) {
      Variance.__super__.constructor.apply(this, arguments);
      this.type = "standard_variance";
    }

    return Variance;

  })(StdDev);

  module.exports.PopulationVariance = PopulationVariance = (function(superClass) {
    extend(PopulationVariance, superClass);

    function PopulationVariance(json) {
      PopulationVariance.__super__.constructor.apply(this, arguments);
      this.type = "population_variance";
    }

    return PopulationVariance;

  })(StdDev);

  module.exports.AllTrue = AllTrue = (function(superClass) {
    extend(AllTrue, superClass);

    function AllTrue(json) {
      AllTrue.__super__.constructor.apply(this, arguments);
    }

    AllTrue.prototype.exec = function(ctx) {
      var args;
      args = this.source.execute(ctx);
      return allTrue(args);
    };

    return AllTrue;

  })(AggregateExpression);

  module.exports.AnyTrue = AnyTrue = (function(superClass) {
    extend(AnyTrue, superClass);

    function AnyTrue(json) {
      AnyTrue.__super__.constructor.apply(this, arguments);
    }

    AnyTrue.prototype.exec = function(ctx) {
      var args;
      args = this.source.execute(ctx);
      return anyTrue(args);
    };

    return AnyTrue;

  })(AggregateExpression);

}).call(this);



},{"../util/util":135,"./builder":14,"./expression":20,"./quantity":32}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Abs, Add, Ceiling, Divide, Exp, Expression, Floor, Ln, Log, MathUtil, MaxValue, MinValue, Modulo, Multiply, Negate, Power, Predecessor, Quantity, Round, Subtract, Successor, Truncate, TruncatedDivide, allTrue, anyTrue, build, ref, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ref = require('../util/util'), typeIsArray = ref.typeIsArray, allTrue = ref.allTrue, anyTrue = ref.anyTrue;

  build = require('./builder').build;

  MathUtil = require('../util/math');

  Quantity = require('./quantity');

  module.exports.Add = Add = (function(superClass) {
    extend(Add, superClass);

    function Add(json) {
      Add.__super__.constructor.apply(this, arguments);
    }

    Add.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args != null ? args.reduce(function(x, y) {
          if (x.constructor.name === 'Quantity' || x.constructor.name === 'DateTime') {
            return Quantity.doAddition(x, y);
          } else {
            return x + y;
          }
        }) : void 0;
      }
    };

    return Add;

  })(Expression);

  module.exports.Subtract = Subtract = (function(superClass) {
    extend(Subtract, superClass);

    function Subtract(json) {
      Subtract.__super__.constructor.apply(this, arguments);
    }

    Subtract.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          if (x.constructor.name === 'Quantity' || x.constructor.name === 'DateTime') {
            return Quantity.doSubtraction(x, y);
          } else {
            return x - y;
          }
        });
      }
    };

    return Subtract;

  })(Expression);

  module.exports.Multiply = Multiply = (function(superClass) {
    extend(Multiply, superClass);

    function Multiply(json) {
      Multiply.__super__.constructor.apply(this, arguments);
    }

    Multiply.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args != null ? args.reduce(function(x, y) {
          if (x.constructor.name === 'Quantity' || y.constructor.name === 'Quantity') {
            return Quantity.doMultiplication(x, y);
          } else {
            return x * y;
          }
        }) : void 0;
      }
    };

    return Multiply;

  })(Expression);

  module.exports.Divide = Divide = (function(superClass) {
    extend(Divide, superClass);

    function Divide(json) {
      Divide.__super__.constructor.apply(this, arguments);
    }

    Divide.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args != null ? args.reduce(function(x, y) {
          if (x.constructor.name === 'Quantity') {
            return Quantity.doDivision(x, y);
          } else {
            return x / y;
          }
        }) : void 0;
      }
    };

    return Divide;

  })(Expression);

  module.exports.TruncatedDivide = TruncatedDivide = (function(superClass) {
    extend(TruncatedDivide, superClass);

    function TruncatedDivide(json) {
      TruncatedDivide.__super__.constructor.apply(this, arguments);
    }

    TruncatedDivide.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return Math.floor(args.reduce(function(x, y) {
          return x / y;
        }));
      }
    };

    return TruncatedDivide;

  })(Expression);

  module.exports.Modulo = Modulo = (function(superClass) {
    extend(Modulo, superClass);

    function Modulo(json) {
      Modulo.__super__.constructor.apply(this, arguments);
    }

    Modulo.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return x % y;
        });
      }
    };

    return Modulo;

  })(Expression);

  module.exports.Ceiling = Ceiling = (function(superClass) {
    extend(Ceiling, superClass);

    function Ceiling(json) {
      Ceiling.__super__.constructor.apply(this, arguments);
    }

    Ceiling.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.ceil(arg);
      }
    };

    return Ceiling;

  })(Expression);

  module.exports.Floor = Floor = (function(superClass) {
    extend(Floor, superClass);

    function Floor(json) {
      Floor.__super__.constructor.apply(this, arguments);
    }

    Floor.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.floor(arg);
      }
    };

    return Floor;

  })(Expression);

  module.exports.Truncate = Truncate = (function(superClass) {
    extend(Truncate, superClass);

    function Truncate() {
      return Truncate.__super__.constructor.apply(this, arguments);
    }

    return Truncate;

  })(Floor);

  module.exports.Abs = Abs = (function(superClass) {
    extend(Abs, superClass);

    function Abs(json) {
      Abs.__super__.constructor.apply(this, arguments);
    }

    Abs.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.constructor.name === 'Quantity') {
        return Quantity.createQuantity(Math.abs(arg.value), arg.unit);
      } else {
        return Math.abs(arg);
      }
    };

    return Abs;

  })(Expression);

  module.exports.Negate = Negate = (function(superClass) {
    extend(Negate, superClass);

    function Negate(json) {
      Negate.__super__.constructor.apply(this, arguments);
    }

    Negate.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.constructor.name === 'Quantity') {
        return Quantity.createQuantity(arg.value * -1, arg.unit);
      } else {
        return arg * -1;
      }
    };

    return Negate;

  })(Expression);

  module.exports.Round = Round = (function(superClass) {
    extend(Round, superClass);

    function Round(json) {
      Round.__super__.constructor.apply(this, arguments);
      this.precision = build(json.precision);
    }

    Round.prototype.exec = function(ctx) {
      var arg, dec;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        dec = this.precision != null ? this.precision.execute(ctx) : 0;
        return Math.round(arg * Math.pow(10, dec)) / Math.pow(10, dec);
      }
    };

    return Round;

  })(Expression);

  module.exports.Ln = Ln = (function(superClass) {
    extend(Ln, superClass);

    function Ln(json) {
      Ln.__super__.constructor.apply(this, arguments);
    }

    Ln.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.log(arg);
      }
    };

    return Ln;

  })(Expression);

  module.exports.Exp = Exp = (function(superClass) {
    extend(Exp, superClass);

    function Exp(json) {
      Exp.__super__.constructor.apply(this, arguments);
    }

    Exp.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.exp(arg);
      }
    };

    return Exp;

  })(Expression);

  module.exports.Log = Log = (function(superClass) {
    extend(Log, superClass);

    function Log(json) {
      Log.__super__.constructor.apply(this, arguments);
    }

    Log.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return Math.log(x) / Math.log(y);
        });
      }
    };

    return Log;

  })(Expression);

  module.exports.Power = Power = (function(superClass) {
    extend(Power, superClass);

    function Power(json) {
      Power.__super__.constructor.apply(this, arguments);
    }

    Power.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return Math.pow(x, y);
        });
      }
    };

    return Power;

  })(Expression);

  module.exports.MinValue = MinValue = (function(superClass) {
    extend(MinValue, superClass);

    MinValue.prototype.MIN_VALUES = {
      "Integer": MathUtil.MIN_INT_VALUE,
      "Real": MathUtil.MIN_FLOAT_VALUE,
      "DateTime": MathUtil.MIN_DATE_VALUE
    };

    function MinValue(json) {
      MinValue.__super__.constructor.apply(this, arguments);
    }

    MinValue.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return MIN_VALUES[arg];
      }
    };

    return MinValue;

  })(Expression);

  module.exports.MaxValue = MaxValue = (function(superClass) {
    extend(MaxValue, superClass);

    MaxValue.prototype.MAX_VALUES = {
      "Integer": MathUtil.MAX_INT_VALUE,
      "Real": MathUtil.MAX_FLOAT_VALUE,
      "DateTime": MathUtil.MAX_DATE_VALUE
    };

    function MaxValue(json) {
      MaxValue.__super__.constructor.apply(this, arguments);
    }

    MaxValue.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return MAX_VALUES[arg];
      }
    };

    return MaxValue;

  })(Expression);

  module.exports.Successor = Successor = (function(superClass) {
    extend(Successor, superClass);

    function Successor(json) {
      Successor.__super__.constructor.apply(this, arguments);
    }

    Successor.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return MathUtil.successor(arg);
      }
    };

    return Successor;

  })(Expression);

  module.exports.Predecessor = Predecessor = (function(superClass) {
    extend(Predecessor, superClass);

    function Predecessor(json) {
      Predecessor.__super__.constructor.apply(this, arguments);
    }

    Predecessor.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return MathUtil.predecessor(arg);
      }
    };

    return Predecessor;

  })(Expression);

}).call(this);



},{"../util/math":134,"../util/util":135,"./builder":14,"./expression":20,"./quantity":32}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var E, build, buildFunctionRef, constructByName, functionExists, typeIsArray;

  E = require('./expressions');

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.build = build = function(json) {
    var child;
    if (json == null) {
      return json;
    }
    if (typeIsArray(json)) {
      return (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = json.length; i < len; i++) {
          child = json[i];
          results.push(build(child));
        }
        return results;
      })();
    }
    if (json.type === "FunctionRef") {
      return new buildFunctionRef(json);
    } else if (json.type === "Literal") {
      return E.Literal.from(json);
    } else if (functionExists("E." + json.type)) {
      return constructByName("E." + json.type, json);
    } else {
      return null;
    }
  };

  buildFunctionRef = function(json) {
    if (functionExists("E." + json.name + "FunctionRef")) {
      return constructByName("E." + json.name + "FunctionRef", json);
    } else {
      return new E.FunctionRef(json);
    }
  };

  functionExists = function(name) {
    return eval("typeof " + name) === "function";
  };

  constructByName = function(name, json) {
    return eval("new " + name + "(json)");
  };

}).call(this);



},{"../util/util":135,"./expressions":21}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var CalculateAge, CalculateAgeAt, CodeDef, CodeRef, CodeSystemDef, Concept, ConceptDef, ConceptRef, Expression, InValueSet, ValueSetDef, ValueSetRef, build, calculateAge, dt, monthsDiff,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  dt = require('../datatypes/datatypes');

  build = require('./builder').build;

  module.exports.ValueSetDef = ValueSetDef = (function(superClass) {
    extend(ValueSetDef, superClass);

    function ValueSetDef(json) {
      ValueSetDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.version = json.version;
    }

    ValueSetDef.prototype.exec = function(ctx) {
      var ref, valueset;
      valueset = (ref = ctx.codeService.findValueSet(this.id, this.version)) != null ? ref : new dt.ValueSet(this.id, this.version);
      ctx.rootContext().set(this.name, valueset);
      return valueset;
    };

    return ValueSetDef;

  })(Expression);

  module.exports.ValueSetRef = ValueSetRef = (function(superClass) {
    extend(ValueSetRef, superClass);

    function ValueSetRef(json) {
      ValueSetRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    ValueSetRef.prototype.exec = function(ctx) {
      var valueset;
      valueset = ctx.getValueSet(this.name);
      if (valueset instanceof Expression) {
        valueset = valueset.execute(ctx);
      }
      return valueset;
    };

    return ValueSetRef;

  })(Expression);

  module.exports.InValueSet = InValueSet = (function(superClass) {
    extend(InValueSet, superClass);

    function InValueSet(json) {
      InValueSet.__super__.constructor.apply(this, arguments);
      this.code = build(json.code);
      this.valueset = new ValueSetRef(json.valueset);
    }

    InValueSet.prototype.exec = function(ctx) {
      var code, valueset;
      if (!((this.code != null) && (this.valueset != null))) {
        return false;
      }
      code = this.code.execute(ctx);
      valueset = this.valueset.execute(ctx);
      if ((code != null) && (valueset != null)) {
        return valueset.hasCode(code);
      } else {
        return false;
      }
    };

    return InValueSet;

  })(Expression);

  module.exports.CodeSystemDef = CodeSystemDef = (function(superClass) {
    extend(CodeSystemDef, superClass);

    function CodeSystemDef(json) {
      CodeSystemDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.version = json.version;
    }

    CodeSystemDef.prototype.exec = function(ctx) {
      return new dt.CodeSystem(this.id, this.version);
    };

    return CodeSystemDef;

  })(Expression);

  module.exports.CodeDef = CodeDef = (function(superClass) {
    extend(CodeDef, superClass);

    function CodeDef(json) {
      CodeDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.systemName = json.codeSystem.name;
      this.display = json.display;
    }

    CodeDef.prototype.exec = function(ctx) {
      var ref, system;
      system = (ref = ctx.getCodeSystem(this.systemName)) != null ? ref.execute(ctx) : void 0;
      return new dt.Code(this.id, system.id, system.version, this.display);
    };

    return CodeDef;

  })(Expression);

  module.exports.CodeRef = CodeRef = (function(superClass) {
    extend(CodeRef, superClass);

    function CodeRef(json) {
      CodeRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    CodeRef.prototype.exec = function(ctx) {
      var ref;
      return (ref = ctx.getCode(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return CodeRef;

  })(Expression);

  module.exports.ConceptDef = ConceptDef = (function(superClass) {
    extend(ConceptDef, superClass);

    function ConceptDef(json) {
      ConceptDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.display = json.display;
      this.codes = json.code;
    }

    ConceptDef.prototype.exec = function(ctx) {
      var code, codes;
      codes = (function() {
        var i, len, ref, ref1, results;
        ref = this.codes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          code = ref[i];
          results.push((ref1 = ctx.getCode(code.name)) != null ? ref1.execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return new dt.Concept(codes, this.display);
    };

    return ConceptDef;

  })(Expression);

  module.exports.ConceptRef = ConceptRef = (function(superClass) {
    extend(ConceptRef, superClass);

    function ConceptRef(json) {
      ConceptRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    ConceptRef.prototype.exec = function(ctx) {
      var ref;
      return (ref = ctx.getConcept(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return ConceptRef;

  })(Expression);

  module.exports.Concept = Concept = (function(superClass) {
    extend(Concept, superClass);

    function Concept(json) {
      Concept.__super__.constructor.apply(this, arguments);
      this.codes = json.code;
      this.display = json.display;
    }

    Concept.prototype.toCode = function(ctx, code) {
      var ref, system;
      system = (ref = ctx.getCodeSystem(code.system.name)) != null ? ref.id : void 0;
      return new dt.Code(code.code, system, code.version, code.display);
    };

    Concept.prototype.exec = function(ctx) {
      var code, codes;
      codes = (function() {
        var i, len, ref, results;
        ref = this.codes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          code = ref[i];
          results.push(this.toCode(ctx, code));
        }
        return results;
      }).call(this);
      return new dt.Concept(codes, this.display);
    };

    return Concept;

  })(Expression);

  calculateAge = function(date1, date2, precision) {
    var ageInMS, divisor, value;
    if (date1.getTime() - date2.getTime() > 0) {
      return 0;
    }
    value = precision === "Year" ? monthsDiff(date1, date2) / 12 : precision === "Month" ? monthsDiff(date1, date2) : (ageInMS = date2.getTime() - date1.getTime(), divisor = (function() {
      switch (precision) {
        case 'Day':
          return 1000 * 60 * 60 * 24;
        case 'Hour':
          return 1000 * 60 * 60;
        case 'Minute':
          return 1000 * 60;
        case 'Second':
          return 1000;
        default:
          return 1;
      }
    })(), ageInMS / divisor);
    return Math.floor(value);
  };

  monthsDiff = function(date1, date2) {
    var date3, high, low, months, ref;
    ref = date1.getTime() > date2.getTime() ? [date1, date2] : [date2, date1], high = ref[0], low = ref[1];
    months = ((high.getFullYear() - low.getFullYear()) * 12) + (high.getMonth() - low.getMonth());
    if (months === 0) {
      return 0;
    }
    date3 = new Date(low.getTime());
    date3.setMonth(low.getMonth() + months);
    if (date3.getMonth() === high.getMonth() && (date3.getDate() - high.getDate() > 0)) {
      months--;
    }
    return months;
  };

  module.exports.CalculateAge = CalculateAge = (function(superClass) {
    extend(CalculateAge, superClass);

    function CalculateAge(json) {
      CalculateAge.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    CalculateAge.prototype.exec = function(ctx) {
      var date1, date2;
      date1 = this.execArgs(ctx).toJSDate();
      date2 = new Date();
      return calculateAge(date1, date2, this.precision);
    };

    return CalculateAge;

  })(Expression);

  module.exports.CalculateAgeAt = CalculateAgeAt = (function(superClass) {
    extend(CalculateAgeAt, superClass);

    function CalculateAgeAt(json) {
      CalculateAgeAt.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    CalculateAgeAt.prototype.exec = function(ctx) {
      var args, date1, date2;
      args = this.execArgs(ctx);
      if ((args[0] != null) && (args[1] != null)) {
        date1 = args[0];
        date2 = args[1];
        date1.hour = 0;
        date1.minute = 0;
        date1.second = 0;
        date1.millisecond = 0;
        date1 = date1.toJSDate(true);
        date2 = date2.toJSDate(true);
        return calculateAge(date1, date2, this.precision);
      } else {
        return null;
      }
    };

    return CalculateAgeAt;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"./builder":14,"./expression":20}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, Greater, GreaterOrEqual, Less, LessOrEqual, Uncertainty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  Uncertainty = require('../datatypes/datatypes').Uncertainty;

  module.exports.Less = Less = (function(superClass) {
    extend(Less, superClass);

    function Less(json) {
      Less.__super__.constructor.apply(this, arguments);
    }

    Less.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      return args[0].lessThan(args[1]);
    };

    return Less;

  })(Expression);

  module.exports.LessOrEqual = LessOrEqual = (function(superClass) {
    extend(LessOrEqual, superClass);

    function LessOrEqual(json) {
      LessOrEqual.__super__.constructor.apply(this, arguments);
    }

    LessOrEqual.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      return args[0].lessThanOrEquals(args[1]);
    };

    return LessOrEqual;

  })(Expression);

  module.exports.Greater = Greater = (function(superClass) {
    extend(Greater, superClass);

    function Greater(json) {
      Greater.__super__.constructor.apply(this, arguments);
    }

    Greater.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      return args[0].greaterThan(args[1]);
    };

    return Greater;

  })(Expression);

  module.exports.GreaterOrEqual = GreaterOrEqual = (function(superClass) {
    extend(GreaterOrEqual, superClass);

    function GreaterOrEqual(json) {
      GreaterOrEqual.__super__.constructor.apply(this, arguments);
    }

    GreaterOrEqual.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      return args[0].greaterThanOrEquals(args[1]);
    };

    return GreaterOrEqual;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"./expression":20}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Case, CaseItem, Expression, If, build, equals,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  equals = require('../util/comparison').equals;

  module.exports.If = If = (function(superClass) {
    extend(If, superClass);

    function If(json) {
      If.__super__.constructor.apply(this, arguments);
      this.condition = build(json.condition);
      this.th = build(json.then);
      this.els = build(json["else"]);
    }

    If.prototype.exec = function(ctx) {
      if (this.condition.execute(ctx)) {
        return this.th.execute(ctx);
      } else {
        return this.els.execute(ctx);
      }
    };

    return If;

  })(Expression);

  module.exports.CaseItem = CaseItem = CaseItem = (function() {
    function CaseItem(json) {
      this.when = build(json.when);
      this.then = build(json.then);
    }

    return CaseItem;

  })();

  module.exports.Case = Case = (function(superClass) {
    extend(Case, superClass);

    function Case(json) {
      var ci;
      Case.__super__.constructor.apply(this, arguments);
      this.comparand = build(json.comparand);
      this.caseItems = (function() {
        var i, len, ref, results;
        ref = json.caseItem;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          ci = ref[i];
          results.push(new CaseItem(ci));
        }
        return results;
      })();
      this.els = build(json["else"]);
    }

    Case.prototype.exec = function(ctx) {
      if (this.comparand) {
        return this.exec_selected(ctx);
      } else {
        return this.exec_standard(ctx);
      }
    };

    Case.prototype.exec_selected = function(ctx) {
      var ci, i, len, ref, val;
      val = this.comparand.execute(ctx);
      ref = this.caseItems;
      for (i = 0, len = ref.length; i < len; i++) {
        ci = ref[i];
        if (equals(ci.when.execute(ctx), val)) {
          return ci.then.execute(ctx);
        }
      }
      return this.els.execute(ctx);
    };

    Case.prototype.exec_standard = function(ctx) {
      var ci, i, len, ref;
      ref = this.caseItems;
      for (i = 0, len = ref.length; i < len; i++) {
        ci = ref[i];
        if (ci.when.execute(ctx)) {
          return ci.then.execute(ctx);
        }
      }
      return this.els.execute(ctx);
    };

    return Case;

  })(Expression);

}).call(this);



},{"../util/comparison":133,"./builder":14,"./expression":20}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DT, DateFrom, DateTime, DateTimeComponentFrom, DurationBetween, Expression, Now, SameAs, SameOrAfter, SameOrBefore, Time, TimeFrom, TimeOfDay, TimezoneFrom, Today, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  DT = require('../datatypes/datatypes');

  module.exports.DateTime = DateTime = (function(superClass) {
    extend(DateTime, superClass);

    DateTime.PROPERTIES = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', 'timezoneOffset'];

    function DateTime(json) {
      var i, len, property, ref;
      DateTime.__super__.constructor.apply(this, arguments);
      ref = DateTime.PROPERTIES;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (json[property] != null) {
          this[property] = build(json[property]);
        }
      }
    }

    DateTime.prototype.exec = function(ctx) {
      var args, p;
      args = (function() {
        var i, len, ref, results;
        ref = DateTime.PROPERTIES;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          results.push(this[p] != null ? this[p].execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DT.DateTime, args, function(){});
    };

    return DateTime;

  })(Expression);

  module.exports.Time = Time = (function(superClass) {
    extend(Time, superClass);

    Time.PROPERTIES = ['hour', 'minute', 'second', 'millisecond', 'timezoneOffset'];

    function Time(json) {
      var i, len, property, ref;
      Time.__super__.constructor.apply(this, arguments);
      ref = Time.PROPERTIES;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (json[property] != null) {
          this[property] = build(json[property]);
        }
      }
    }

    Time.prototype.exec = function(ctx) {
      var args, p;
      args = (function() {
        var i, len, ref, results;
        ref = Time.PROPERTIES;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          results.push(this[p] != null ? this[p].execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return ((function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DT.DateTime, [0, 1, 1].concat(slice.call(args)), function(){})).getTime();
    };

    return Time;

  })(Expression);

  module.exports.Today = Today = (function(superClass) {
    extend(Today, superClass);

    function Today(json) {
      Today.__super__.constructor.apply(this, arguments);
    }

    Today.prototype.exec = function(ctx) {
      return DT.DateTime.fromDate(new Date()).getDate();
    };

    return Today;

  })(Expression);

  module.exports.Now = Now = (function(superClass) {
    extend(Now, superClass);

    function Now(json) {
      Now.__super__.constructor.apply(this, arguments);
    }

    Now.prototype.exec = function(ctx) {
      return DT.DateTime.fromDate(new Date());
    };

    return Now;

  })(Expression);

  module.exports.TimeOfDay = TimeOfDay = (function(superClass) {
    extend(TimeOfDay, superClass);

    function TimeOfDay(json) {
      TimeOfDay.__super__.constructor.apply(this, arguments);
    }

    TimeOfDay.prototype.exec = function(ctx) {
      return DT.DateTime.fromDate(new Date()).getTime();
    };

    return TimeOfDay;

  })(Expression);

  module.exports.DateTimeComponentFrom = DateTimeComponentFrom = (function(superClass) {
    extend(DateTimeComponentFrom, superClass);

    function DateTimeComponentFrom(json) {
      DateTimeComponentFrom.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    DateTimeComponentFrom.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg[this.precision.toLowerCase()];
      } else {
        return null;
      }
    };

    return DateTimeComponentFrom;

  })(Expression);

  module.exports.DateFrom = DateFrom = (function(superClass) {
    extend(DateFrom, superClass);

    function DateFrom(json) {
      DateFrom.__super__.constructor.apply(this, arguments);
    }

    DateFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.getDate();
      } else {
        return null;
      }
    };

    return DateFrom;

  })(Expression);

  module.exports.TimeFrom = TimeFrom = (function(superClass) {
    extend(TimeFrom, superClass);

    function TimeFrom(json) {
      TimeFrom.__super__.constructor.apply(this, arguments);
    }

    TimeFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.getTime();
      } else {
        return null;
      }
    };

    return TimeFrom;

  })(Expression);

  module.exports.TimezoneFrom = TimezoneFrom = (function(superClass) {
    extend(TimezoneFrom, superClass);

    function TimezoneFrom(json) {
      TimezoneFrom.__super__.constructor.apply(this, arguments);
    }

    TimezoneFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.timezoneOffset;
      } else {
        return null;
      }
    };

    return TimezoneFrom;

  })(Expression);

  module.exports.SameAs = SameAs = (function(superClass) {
    extend(SameAs, superClass);

    function SameAs(json) {
      SameAs.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameAs.prototype.exec = function(ctx) {
      var d1, d2, ref, ref1;
      ref = this.execArgs(ctx), d1 = ref[0], d2 = ref[1];
      if ((d1 != null) && (d2 != null)) {
        return d1.sameAs(d2, (ref1 = this.precision) != null ? ref1.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameAs;

  })(Expression);

  module.exports.SameOrAfter = SameOrAfter = (function(superClass) {
    extend(SameOrAfter, superClass);

    function SameOrAfter(json) {
      SameOrAfter.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameOrAfter.prototype.exec = function(ctx) {
      var d1, d2, ref, ref1;
      ref = this.execArgs(ctx), d1 = ref[0], d2 = ref[1];
      if ((d1 != null) && (d2 != null)) {
        return d1.sameOrAfter(d2, (ref1 = this.precision) != null ? ref1.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameOrAfter;

  })(Expression);

  module.exports.SameOrBefore = SameOrBefore = (function(superClass) {
    extend(SameOrBefore, superClass);

    function SameOrBefore(json) {
      SameOrBefore.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameOrBefore.prototype.exec = function(ctx) {
      var d1, d2, ref, ref1;
      ref = this.execArgs(ctx), d1 = ref[0], d2 = ref[1];
      if ((d1 != null) && (d2 != null)) {
        return d1.sameOrBefore(d2, (ref1 = this.precision) != null ? ref1.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameOrBefore;

  })(Expression);

  module.exports.doAfter = function(a, b, precision) {
    return a.after(b, precision);
  };

  module.exports.doBefore = function(a, b, precision) {
    return a.before(b, precision);
  };

  module.exports.DurationBetween = DurationBetween = (function(superClass) {
    extend(DurationBetween, superClass);

    function DurationBetween(json) {
      DurationBetween.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    DurationBetween.prototype.exec = function(ctx) {
      var args, ref, result;
      args = this.execArgs(ctx);
      if ((args[0] == null) || (args[1] == null) || typeof args[0].durationBetween !== 'function' || typeof args[1].durationBetween !== 'function') {
        return null;
      }
      result = args[0].durationBetween(args[1], (ref = this.precision) != null ? ref.toLowerCase() : void 0);
      if ((result != null) && result.isPoint()) {
        return result.low;
      } else {
        return result;
      }
    };

    return DurationBetween;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"./builder":14,"./expression":20}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, IncludeDef, UnimplementedExpression, UsingDef, VersionedIdentifier, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  module.exports.UsingDef = UsingDef = (function(superClass) {
    extend(UsingDef, superClass);

    function UsingDef() {
      return UsingDef.__super__.constructor.apply(this, arguments);
    }

    return UsingDef;

  })(UnimplementedExpression);

  module.exports.IncludeDef = IncludeDef = (function(superClass) {
    extend(IncludeDef, superClass);

    function IncludeDef() {
      return IncludeDef.__super__.constructor.apply(this, arguments);
    }

    return IncludeDef;

  })(UnimplementedExpression);

  module.exports.VersionedIdentifier = VersionedIdentifier = (function(superClass) {
    extend(VersionedIdentifier, superClass);

    function VersionedIdentifier() {
      return VersionedIdentifier.__super__.constructor.apply(this, arguments);
    }

    return VersionedIdentifier;

  })(UnimplementedExpression);

}).call(this);



},{"./expression":20}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, UnimplementedExpression, build, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  build = require('./builder').build;

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.Expression = Expression = (function() {
    function Expression(json) {
      var op;
      if (json.operand != null) {
        op = build(json.operand);
        if (typeIsArray(json.operand)) {
          this.args = op;
        } else {
          this.arg = op;
        }
      }
      if (json.localId != null) {
        this.localId = json.localId;
      }
    }

    Expression.prototype.execute = function(ctx) {
      if (this.localId != null) {
        ctx.localId_context[this.localId] = this.exec(ctx);
        return ctx.localId_context[this.localId];
      } else {
        return this.exec(ctx);
      }
    };

    Expression.prototype.exec = function(ctx) {
      return this;
    };

    Expression.prototype.execArgs = function(ctx) {
      var arg, i, len, ref, results;
      switch (false) {
        case this.args == null:
          ref = this.args;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            arg = ref[i];
            results.push(arg.execute(ctx));
          }
          return results;
        case this.arg == null:
          return this.arg.execute(ctx);
        default:
          return null;
      }
    };

    return Expression;

  })();

  module.exports.UnimplementedExpression = UnimplementedExpression = (function(superClass) {
    extend(UnimplementedExpression, superClass);

    function UnimplementedExpression(json1) {
      this.json = json1;
      UnimplementedExpression.__super__.constructor.apply(this, arguments);
    }

    UnimplementedExpression.prototype.exec = function(ctx) {
      throw new Error("Unimplemented Expression: " + this.json.type);
    };

    return UnimplementedExpression;

  })(Expression);

}).call(this);



},{"../util/util":135,"./builder":14}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var aggregate, arithmetic, clinical, comparison, conditional, datetime, declaration, element, expression, external, i, instance, interval, j, len, len1, lib, libs, list, literal, logical, nullological, overloaded, parameters, quantity, query, ref, reusable, string, structured, type;

  expression = require('./expression', aggregate = require('./aggregate', arithmetic = require('./arithmetic', clinical = require('./clinical', comparison = require('./comparison', conditional = require('./conditional', datetime = require('./datetime', declaration = require('./declaration', external = require('./external', instance = require('./instance', interval = require('./interval', list = require('./list', literal = require('./literal', logical = require('./logical', nullological = require('./nullological', parameters = require('./parameters', quantity = require('./quantity', query = require('./query', reusable = require('./reusable', string = require('./string', structured = require('./structured', type = require('./type', overloaded = require('./overloaded')))))))))))))))))))))));

  libs = [expression, aggregate, arithmetic, clinical, comparison, conditional, datetime, declaration, external, instance, interval, list, literal, logical, nullological, parameters, query, quantity, reusable, string, structured, type, overloaded];

  for (i = 0, len = libs.length; i < len; i++) {
    lib = libs[i];
    ref = Object.keys(lib);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      element = ref[j];
      module.exports[element] = lib[element];
    }
  }

}).call(this);



},{"./aggregate":12,"./arithmetic":13,"./clinical":15,"./comparison":16,"./conditional":17,"./datetime":18,"./declaration":19,"./expression":20,"./external":22,"./instance":23,"./interval":24,"./list":26,"./literal":27,"./logical":28,"./nullological":29,"./overloaded":30,"./parameters":31,"./quantity":32,"./query":33,"./reusable":34,"./string":35,"./structured":36,"./type":37}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, Retrieve, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.Retrieve = Retrieve = (function(superClass) {
    extend(Retrieve, superClass);

    function Retrieve(json) {
      Retrieve.__super__.constructor.apply(this, arguments);
      this.datatype = json.dataType;
      this.templateId = json.templateId;
      this.codeProperty = json.codeProperty;
      this.codes = build(json.codes);
      this.dateProperty = json.dateProperty;
      this.dateRange = build(json.dateRange);
    }

    Retrieve.prototype.exec = function(ctx) {
      var r, range, records, ref, valueset;
      records = ctx.findRecords((ref = this.templateId) != null ? ref : this.datatype);
      if (this.codes && 'exec' in this.codes) {
        valueset = this.codes.execute(ctx);
        records = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = records.length; i < len; i++) {
            r = records[i];
            if (valueset.hasCode(r.getCode())) {
              results.push(r);
            }
          }
          return results;
        })();
      }
      if (this.dateRange && this.dateProperty) {
        range = this.dateRange.execute(ctx);
        records = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = records.length; i < len; i++) {
            r = records[i];
            if (range.includes(r.getDateOrInterval(this.dateProperty))) {
              results.push(r);
            }
          }
          return results;
        }).call(this);
      }
      return records;
    };

    return Retrieve;

  })(Expression);

}).call(this);



},{"./builder":14,"./expression":20}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Code, Element, Expression, Instance, Quantity, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  Quantity = require('./quantity').Quantity;

  Code = require('../datatypes/datatypes').Code;

  Element = (function() {
    function Element(json) {
      this.name = json.name;
      this.value = build(json.value);
    }

    Element.prototype.exec = function(ctx) {
      var ref;
      return (ref = this.value) != null ? ref.execute(ctx) : void 0;
    };

    return Element;

  })();

  module.exports.Instance = Instance = (function(superClass) {
    extend(Instance, superClass);

    function Instance(json) {
      var child;
      Instance.__super__.constructor.apply(this, arguments);
      this.classType = json.classType;
      this.element = (function() {
        var i, len, ref, results;
        ref = json.element;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          results.push(new Element(child));
        }
        return results;
      })();
    }

    Instance.prototype.exec = function(ctx) {
      var el, i, len, obj, ref;
      obj = {};
      ref = this.element;
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        obj[el.name] = el.exec(ctx);
      }
      switch (this.classType) {
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return new Quantity(obj);
        case "{urn:hl7-org:elm-types:r1}Code":
          return new Code(obj.code, obj.system, obj.version, obj.display);
        default:
          return obj;
      }
    };

    return Instance;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"./builder":14,"./expression":20,"./quantity":32}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Collapse, End, Ends, Expression, Interval, Meets, MeetsAfter, MeetsBefore, Overlaps, OverlapsAfter, OverlapsBefore, Start, Starts, ThreeValuedLogic, UnimplementedExpression, Width, build, cmp, doIncludes, dtivl, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  ThreeValuedLogic = require('../datatypes/logic').ThreeValuedLogic;

  build = require('./builder').build;

  dtivl = require('../datatypes/interval');

  cmp = require('../util/comparison');

  module.exports.Interval = Interval = (function(superClass) {
    extend(Interval, superClass);

    function Interval(json) {
      Interval.__super__.constructor.apply(this, arguments);
      this.lowClosed = json.lowClosed;
      this.highClosed = json.highClosed;
      this.low = build(json.low);
      this.high = build(json.high);
    }

    Interval.prototype.exec = function(ctx) {
      return new dtivl.Interval(this.low.execute(ctx), this.high.execute(ctx), this.lowClosed, this.highClosed);
    };

    return Interval;

  })(Expression);

  module.exports.doContains = function(interval, item) {
    return interval.contains(item);
  };

  module.exports.doIncludes = doIncludes = function(interval, subinterval) {
    return interval.includes(subinterval);
  };

  module.exports.doProperIncludes = function(interval, subinterval) {
    return interval.properlyIncludes(subinterval);
  };

  module.exports.doAfter = function(a, b, precision) {
    return a.after(b, precision);
  };

  module.exports.doBefore = function(a, b, precision) {
    return a.before(b, precision);
  };

  module.exports.Meets = Meets = (function(superClass) {
    extend(Meets, superClass);

    function Meets(json) {
      Meets.__super__.constructor.apply(this, arguments);
    }

    Meets.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.meets(b);
      } else {
        return null;
      }
    };

    return Meets;

  })(Expression);

  module.exports.MeetsAfter = MeetsAfter = (function(superClass) {
    extend(MeetsAfter, superClass);

    function MeetsAfter(json) {
      MeetsAfter.__super__.constructor.apply(this, arguments);
    }

    MeetsAfter.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.meetsAfter(b);
      } else {
        return null;
      }
    };

    return MeetsAfter;

  })(Expression);

  module.exports.MeetsBefore = MeetsBefore = (function(superClass) {
    extend(MeetsBefore, superClass);

    function MeetsBefore(json) {
      MeetsBefore.__super__.constructor.apply(this, arguments);
    }

    MeetsBefore.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.meetsBefore(b);
      } else {
        return null;
      }
    };

    return MeetsBefore;

  })(Expression);

  module.exports.Overlaps = Overlaps = (function(superClass) {
    extend(Overlaps, superClass);

    function Overlaps(json) {
      Overlaps.__super__.constructor.apply(this, arguments);
    }

    Overlaps.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.overlaps(b);
      } else {
        return null;
      }
    };

    return Overlaps;

  })(Expression);

  module.exports.OverlapsAfter = OverlapsAfter = (function(superClass) {
    extend(OverlapsAfter, superClass);

    function OverlapsAfter(json) {
      OverlapsAfter.__super__.constructor.apply(this, arguments);
    }

    OverlapsAfter.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.overlapsAfter(b);
      } else {
        return null;
      }
    };

    return OverlapsAfter;

  })(Expression);

  module.exports.OverlapsBefore = OverlapsBefore = (function(superClass) {
    extend(OverlapsBefore, superClass);

    function OverlapsBefore(json) {
      OverlapsBefore.__super__.constructor.apply(this, arguments);
    }

    OverlapsBefore.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.overlapsBefore(b);
      } else {
        return null;
      }
    };

    return OverlapsBefore;

  })(Expression);

  module.exports.doUnion = function(a, b) {
    return a.union(b);
  };

  module.exports.doExcept = function(a, b) {
    if ((a != null) && (b != null)) {
      return a.except(b);
    } else {
      return null;
    }
  };

  module.exports.doIntersect = function(a, b) {
    if ((a != null) && (b != null)) {
      return a.intersect(b);
    } else {
      return null;
    }
  };

  module.exports.Width = Width = (function(superClass) {
    extend(Width, superClass);

    function Width(json) {
      Width.__super__.constructor.apply(this, arguments);
    }

    Width.prototype.exec = function(ctx) {
      var ref1;
      return (ref1 = this.arg.execute(ctx)) != null ? ref1.width() : void 0;
    };

    return Width;

  })(Expression);

  module.exports.Start = Start = (function(superClass) {
    extend(Start, superClass);

    function Start(json) {
      Start.__super__.constructor.apply(this, arguments);
    }

    Start.prototype.exec = function(ctx) {
      var ref1;
      return (ref1 = this.arg.execute(ctx)) != null ? ref1.low : void 0;
    };

    return Start;

  })(Expression);

  module.exports.End = End = (function(superClass) {
    extend(End, superClass);

    function End(json) {
      End.__super__.constructor.apply(this, arguments);
    }

    End.prototype.exec = function(ctx) {
      var ref1;
      return (ref1 = this.arg.execute(ctx)) != null ? ref1.high : void 0;
    };

    return End;

  })(Expression);

  module.exports.Starts = Starts = (function(superClass) {
    extend(Starts, superClass);

    function Starts() {
      return Starts.__super__.constructor.apply(this, arguments);
    }

    return Starts;

  })(UnimplementedExpression);

  module.exports.Ends = Ends = (function(superClass) {
    extend(Ends, superClass);

    function Ends() {
      return Ends.__super__.constructor.apply(this, arguments);
    }

    return Ends;

  })(UnimplementedExpression);

  module.exports.Collapse = Collapse = (function(superClass) {
    extend(Collapse, superClass);

    function Collapse() {
      return Collapse.__super__.constructor.apply(this, arguments);
    }

    return Collapse;

  })(UnimplementedExpression);

}).call(this);



},{"../datatypes/interval":9,"../datatypes/logic":10,"../util/comparison":133,"./builder":14,"./expression":20}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var CodeDef, CodeSystemDef, ConceptDef, ExpressionDef, FunctionDef, Library, ParameterDef, Results, ValueSetDef, ref;

  module.exports.Library = Library = (function() {
    function Library(json, libraryManager) {
      var code, codesystem, concept, expr, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, o, p, param, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref3, ref4, ref5, ref6, ref7, ref8, ref9, u, valueset;
      this.source = json;
      this.usings = [];
      ref2 = (ref = (ref1 = json.library.usings) != null ? ref1.def : void 0) != null ? ref : [];
      for (i = 0, len = ref2.length; i < len; i++) {
        u = ref2[i];
        if (u.localIdentifier !== "System") {
          this.usings.push({
            "name": u.localIdentifier,
            "version": u.version
          });
        }
      }
      this.parameters = {};
      ref5 = (ref3 = (ref4 = json.library.parameters) != null ? ref4.def : void 0) != null ? ref3 : [];
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        param = ref5[j];
        this.parameters[param.name] = new ParameterDef(param);
      }
      this.codesystems = {};
      ref8 = (ref6 = (ref7 = json.library.codeSystems) != null ? ref7.def : void 0) != null ? ref6 : [];
      for (k = 0, len2 = ref8.length; k < len2; k++) {
        codesystem = ref8[k];
        this.codesystems[codesystem.name] = new CodeSystemDef(codesystem);
      }
      this.valuesets = {};
      ref11 = (ref9 = (ref10 = json.library.valueSets) != null ? ref10.def : void 0) != null ? ref9 : [];
      for (l = 0, len3 = ref11.length; l < len3; l++) {
        valueset = ref11[l];
        this.valuesets[valueset.name] = new ValueSetDef(valueset);
      }
      this.codes = {};
      ref14 = (ref12 = (ref13 = json.library.codes) != null ? ref13.def : void 0) != null ? ref12 : [];
      for (m = 0, len4 = ref14.length; m < len4; m++) {
        code = ref14[m];
        this.codes[code.name] = new CodeDef(code);
      }
      this.concepts = {};
      ref17 = (ref15 = (ref16 = json.library.concepts) != null ? ref16.def : void 0) != null ? ref15 : [];
      for (n = 0, len5 = ref17.length; n < len5; n++) {
        concept = ref17[n];
        this.concepts[concept.name] = new ConceptDef(concept);
      }
      this.expressions = {};
      ref20 = (ref18 = (ref19 = json.library.statements) != null ? ref19.def : void 0) != null ? ref18 : [];
      for (o = 0, len6 = ref20.length; o < len6; o++) {
        expr = ref20[o];
        this.expressions[expr.name] = expr.type === "FunctionDef" ? new FunctionDef(expr) : new ExpressionDef(expr);
      }
      this.includes = {};
      ref23 = (ref21 = (ref22 = json.library.includes) != null ? ref22.def : void 0) != null ? ref21 : [];
      for (p = 0, len7 = ref23.length; p < len7; p++) {
        expr = ref23[p];
        if (libraryManager) {
          this.includes[expr.localIdentifier] = libraryManager.resolve(expr.path, expr.version);
        }
      }
    }

    Library.prototype.get = function(identifier) {
      return this.expressions[identifier] || this.includes[identifier];
    };

    Library.prototype.getValueSet = function(identifier) {
      return this.valuesets[identifier];
    };

    Library.prototype.getCodeSystem = function(identifier) {
      return this.codesystems[identifier];
    };

    Library.prototype.getCode = function(identifier) {
      return this.codes[identifier];
    };

    Library.prototype.getConcept = function(identifier) {
      return this.concepts[identifier];
    };

    Library.prototype.getParameter = function(name) {
      return this.parameters[name];
    };

    return Library;

  })();

  ref = require('./expressions'), ExpressionDef = ref.ExpressionDef, FunctionDef = ref.FunctionDef, ParameterDef = ref.ParameterDef, ValueSetDef = ref.ValueSetDef, CodeSystemDef = ref.CodeSystemDef, CodeDef = ref.CodeDef, ConceptDef = ref.ConceptDef;

  Results = require('../runtime/results').Results;

}).call(this);



},{"../runtime/results":132,"./expressions":21}],26:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Current, Distinct, Exists, Expression, Filter, First, Flatten, ForEach, IndexOf, Last, List, SingletonFrom, Times, ToList, UnimplementedExpression, ValueSet, build, doContains, doDistinct, doIncludes, equals, ref, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  ValueSet = require('../datatypes/datatypes').ValueSet;

  build = require('./builder').build;

  typeIsArray = require('../util/util').typeIsArray;

  equals = require('../util/comparison').equals;

  module.exports.List = List = (function(superClass) {
    extend(List, superClass);

    function List(json) {
      var ref1;
      List.__super__.constructor.apply(this, arguments);
      this.elements = (ref1 = build(json.element)) != null ? ref1 : [];
    }

    List.prototype.exec = function(ctx) {
      var item, j, len, ref1, results;
      ref1 = this.elements;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        item = ref1[j];
        results.push(item.execute(ctx));
      }
      return results;
    };

    return List;

  })(Expression);

  module.exports.Exists = Exists = (function(superClass) {
    extend(Exists, superClass);

    function Exists(json) {
      Exists.__super__.constructor.apply(this, arguments);
    }

    Exists.prototype.exec = function(ctx) {
      var ref1;
      return ((ref1 = this.execArgs(ctx)) != null ? ref1.length : void 0) > 0;
    };

    return Exists;

  })(Expression);

  module.exports.doUnion = function(a, b) {
    return doDistinct(a.concat(b));
  };

  module.exports.doExcept = function(a, b) {
    var itm, j, len, results;
    results = [];
    for (j = 0, len = a.length; j < len; j++) {
      itm = a[j];
      if (!doContains(b, itm)) {
        results.push(itm);
      }
    }
    return results;
  };

  module.exports.doIntersect = function(a, b) {
    var itm, j, len, results;
    results = [];
    for (j = 0, len = a.length; j < len; j++) {
      itm = a[j];
      if (doContains(b, itm)) {
        results.push(itm);
      }
    }
    return results;
  };

  module.exports.Times = Times = (function(superClass) {
    extend(Times, superClass);

    function Times() {
      return Times.__super__.constructor.apply(this, arguments);
    }

    return Times;

  })(UnimplementedExpression);

  module.exports.Filter = Filter = (function(superClass) {
    extend(Filter, superClass);

    function Filter() {
      return Filter.__super__.constructor.apply(this, arguments);
    }

    return Filter;

  })(UnimplementedExpression);

  module.exports.SingletonFrom = SingletonFrom = (function(superClass) {
    extend(SingletonFrom, superClass);

    function SingletonFrom(json) {
      SingletonFrom.__super__.constructor.apply(this, arguments);
    }

    SingletonFrom.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg.length > 1) {
        throw new Error('IllegalArgument: \'SingletonFrom\' requires a 0 or 1 arg array');
      } else if (arg.length === 1) {
        return arg[0];
      } else {
        return null;
      }
    };

    return SingletonFrom;

  })(Expression);

  module.exports.ToList = ToList = (function(superClass) {
    extend(ToList, superClass);

    function ToList(json) {
      ToList.__super__.constructor.apply(this, arguments);
    }

    ToList.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return [arg];
      } else {
        return [];
      }
    };

    return ToList;

  })(Expression);

  module.exports.IndexOf = IndexOf = (function(superClass) {
    extend(IndexOf, superClass);

    function IndexOf(json) {
      IndexOf.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
      this.element = build(json.element);
    }

    IndexOf.prototype.exec = function(ctx) {
      var el, i, index, itm, j, len, src;
      src = this.source.exec(ctx);
      el = this.element.exec(ctx);
      if ((src == null) || (el == null)) {
        return null;
      }
      for (i = j = 0, len = src.length; j < len; i = ++j) {
        itm = src[i];
        if (equals(itm, el)) {
          index = i;
          break;
        }
      }
      if (index != null) {
        return index;
      } else {
        return -1;
      }
    };

    return IndexOf;

  })(Expression);

  module.exports.doContains = doContains = function(container, item) {
    var element, j, len;
    for (j = 0, len = container.length; j < len; j++) {
      element = container[j];
      if (equals(element, item)) {
        return true;
      }
    }
    return false;
  };

  module.exports.doIncludes = doIncludes = function(list, sublist) {
    return sublist.every(function(x) {
      return doContains(list, x);
    });
  };

  module.exports.doProperIncludes = function(list, sublist) {
    return list.length > sublist.length && doIncludes(list, sublist);
  };

  module.exports.ForEach = ForEach = (function(superClass) {
    extend(ForEach, superClass);

    function ForEach() {
      return ForEach.__super__.constructor.apply(this, arguments);
    }

    return ForEach;

  })(UnimplementedExpression);

  module.exports.Flatten = Flatten = (function(superClass) {
    extend(Flatten, superClass);

    function Flatten(json) {
      Flatten.__super__.constructor.apply(this, arguments);
    }

    Flatten.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (typeIsArray(arg) && (arg.every(function(x) {
        return typeIsArray(x);
      }))) {
        return arg.reduce((function(x, y) {
          return x.concat(y);
        }), []);
      } else {
        return arg;
      }
    };

    return Flatten;

  })(Expression);

  module.exports.Distinct = Distinct = (function(superClass) {
    extend(Distinct, superClass);

    function Distinct(json) {
      Distinct.__super__.constructor.apply(this, arguments);
    }

    Distinct.prototype.exec = function(ctx) {
      return doDistinct(this.execArgs(ctx));
    };

    return Distinct;

  })(Expression);

  doDistinct = function(list) {
    var seen;
    seen = [];
    return list.filter(function(item) {
      var isNew;
      isNew = seen.every(function(seenItem) {
        return !equals(item, seenItem);
      });
      if (isNew) {
        seen.push(item);
      }
      return isNew;
    });
  };

  module.exports.Current = Current = (function(superClass) {
    extend(Current, superClass);

    function Current() {
      return Current.__super__.constructor.apply(this, arguments);
    }

    return Current;

  })(UnimplementedExpression);

  module.exports.First = First = (function(superClass) {
    extend(First, superClass);

    function First(json) {
      First.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    First.prototype.exec = function(ctx) {
      var src;
      src = this.source.exec(ctx);
      if ((src != null) && typeIsArray(src) && src.length > 0) {
        return src[0];
      } else {
        return null;
      }
    };

    return First;

  })(Expression);

  module.exports.Last = Last = (function(superClass) {
    extend(Last, superClass);

    function Last(json) {
      Last.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    Last.prototype.exec = function(ctx) {
      var src;
      src = this.source.exec(ctx);
      if ((src != null) && typeIsArray(src) && src.length > 0) {
        return src[src.length - 1];
      } else {
        return null;
      }
    };

    return Last;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"../util/comparison":133,"../util/util":135,"./builder":14,"./expression":20}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var BooleanLiteral, DecimalLiteral, Expression, IntegerLiteral, Literal, StringLiteral,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  module.exports.Literal = Literal = (function(superClass) {
    extend(Literal, superClass);

    Literal.from = function(json) {
      switch (json.valueType) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return new BooleanLiteral(json);
        case "{urn:hl7-org:elm-types:r1}Integer":
          return new IntegerLiteral(json);
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return new DecimalLiteral(json);
        case "{urn:hl7-org:elm-types:r1}String":
          return new StringLiteral(json);
        default:
          return new Literal(json);
      }
    };

    function Literal(json) {
      Literal.__super__.constructor.apply(this, arguments);
      this.valueType = json.valueType;
      this.value = json.value;
    }

    Literal.prototype.exec = function(ctx) {
      return this.value;
    };

    return Literal;

  })(Expression);

  module.exports.BooleanLiteral = BooleanLiteral = (function(superClass) {
    extend(BooleanLiteral, superClass);

    function BooleanLiteral(json) {
      BooleanLiteral.__super__.constructor.apply(this, arguments);
      this.value = this.value === 'true';
    }

    BooleanLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return BooleanLiteral;

  })(Literal);

  module.exports.IntegerLiteral = IntegerLiteral = (function(superClass) {
    extend(IntegerLiteral, superClass);

    function IntegerLiteral(json) {
      IntegerLiteral.__super__.constructor.apply(this, arguments);
      this.value = parseInt(this.value, 10);
    }

    IntegerLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return IntegerLiteral;

  })(Literal);

  module.exports.DecimalLiteral = DecimalLiteral = (function(superClass) {
    extend(DecimalLiteral, superClass);

    function DecimalLiteral(json) {
      DecimalLiteral.__super__.constructor.apply(this, arguments);
      this.value = parseFloat(this.value);
    }

    DecimalLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return DecimalLiteral;

  })(Literal);

  module.exports.StringLiteral = StringLiteral = (function(superClass) {
    extend(StringLiteral, superClass);

    function StringLiteral(json) {
      StringLiteral.__super__.constructor.apply(this, arguments);
    }

    StringLiteral.prototype.exec = function(ctx) {
      return this.value.replace(/\\'/g, "'").replace(/\\"/g, "\"");
    };

    return StringLiteral;

  })(Literal);

}).call(this);



},{"./expression":20}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var And, Expression, IsFalse, IsTrue, Not, Or, ThreeValuedLogic, Xor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ThreeValuedLogic = require('../datatypes/datatypes').ThreeValuedLogic;

  module.exports.And = And = (function(superClass) {
    extend(And, superClass);

    function And(json) {
      And.__super__.constructor.apply(this, arguments);
    }

    And.prototype.exec = function(ctx) {
      return ThreeValuedLogic.and.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return And;

  })(Expression);

  module.exports.Or = Or = (function(superClass) {
    extend(Or, superClass);

    function Or(json) {
      Or.__super__.constructor.apply(this, arguments);
    }

    Or.prototype.exec = function(ctx) {
      return ThreeValuedLogic.or.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return Or;

  })(Expression);

  module.exports.Not = Not = (function(superClass) {
    extend(Not, superClass);

    function Not(json) {
      Not.__super__.constructor.apply(this, arguments);
    }

    Not.prototype.exec = function(ctx) {
      return ThreeValuedLogic.not(this.execArgs(ctx));
    };

    return Not;

  })(Expression);

  module.exports.Xor = Xor = (function(superClass) {
    extend(Xor, superClass);

    function Xor(json) {
      Xor.__super__.constructor.apply(this, arguments);
    }

    Xor.prototype.exec = function(ctx) {
      return ThreeValuedLogic.xor.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return Xor;

  })(Expression);

  module.exports.IsTrue = IsTrue = (function(superClass) {
    extend(IsTrue, superClass);

    function IsTrue(json) {
      IsTrue.__super__.constructor.apply(this, arguments);
    }

    IsTrue.prototype.exec = function(ctx) {
      return true === this.execArgs(ctx);
    };

    return IsTrue;

  })(Expression);

  module.exports.IsFalse = IsFalse = (function(superClass) {
    extend(IsFalse, superClass);

    function IsFalse(json) {
      IsFalse.__super__.constructor.apply(this, arguments);
    }

    IsFalse.prototype.exec = function(ctx) {
      return false === this.execArgs(ctx);
    };

    return IsFalse;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":6,"./expression":20}],29:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Coalesce, Expression, IsNull, Null,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  module.exports.Null = Null = (function(superClass) {
    extend(Null, superClass);

    function Null(json) {
      Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.exec = function(ctx) {
      return null;
    };

    return Null;

  })(Expression);

  module.exports.IsNull = IsNull = (function(superClass) {
    extend(IsNull, superClass);

    function IsNull(json) {
      IsNull.__super__.constructor.apply(this, arguments);
    }

    IsNull.prototype.exec = function(ctx) {
      return this.execArgs(ctx) == null;
    };

    return IsNull;

  })(Expression);

  module.exports.Coalesce = Coalesce = (function(superClass) {
    extend(Coalesce, superClass);

    function Coalesce(json) {
      Coalesce.__super__.constructor.apply(this, arguments);
    }

    Coalesce.prototype.exec = function(ctx) {
      var arg, i, len, ref, result;
      ref = this.args;
      for (i = 0, len = ref.length; i < len; i++) {
        arg = ref[i];
        result = arg.execute(ctx);
        if (result != null) {
          return result;
        }
      }
      return null;
    };

    return Coalesce;

  })(Expression);

}).call(this);



},{"./expression":20}],30:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var After, ArrayIndexOutOfBoundsException, Contains, DT, DateTime, Equal, Equivalent, Except, Exception, Expression, IVL, In, IncludedIn, Includes, Indexer, Intersect, LIST, Length, NotEqual, ProperIncludedIn, ProperIncludes, STRING, ThreeValuedLogic, Union, build, equals, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ThreeValuedLogic = require('../datatypes/logic').ThreeValuedLogic;

  DateTime = require('../datatypes/datetime').DateTime;

  Exception = require('../datatypes/exception').Exception;

  typeIsArray = require('../util/util').typeIsArray;

  equals = require('../util/comparison').equals;

  build = require('./builder').build;

  DT = require('./datetime');

  LIST = require('./list');

  IVL = require('./interval');

  STRING = require('./string');

  module.exports.Equal = Equal = (function(superClass) {
    extend(Equal, superClass);

    function Equal(json) {
      Equal.__super__.constructor.apply(this, arguments);
    }

    Equal.prototype.exec = function(ctx) {
      return equals.apply(null, this.execArgs(ctx));
    };

    return Equal;

  })(Expression);

  module.exports.Equivalent = Equivalent = (function(superClass) {
    extend(Equivalent, superClass);

    function Equivalent(json) {
      Equivalent.__super__.constructor.apply(this, arguments);
    }

    Equivalent.prototype.exec = function(ctx) {
      var a, b, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return false;
      } else if ((a.code || a.codes) && (b.code || b.codes)) {
        return this.matchCodes(a, b);
      } else {
        return equals(a, b);
      }
    };

    Equivalent.prototype.matchCodes = function(code1, code2) {
      var c, matches;
      matches = [];
      if (code1.codes) {
        return ((function() {
          var i, len, ref, results;
          ref = code1.codes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            if (this.matchCodes(c, code2)) {
              results.push(c);
            }
          }
          return results;
        }).call(this)).length > 0;
      } else if (code2.codes) {
        return this.matchCodes(code2, code1);
      }
      return code1.code === code2.code && code1.system === code2.system && code1.version === code2.version;
    };

    return Equivalent;

  })(Expression);

  module.exports.NotEqual = NotEqual = (function(superClass) {
    extend(NotEqual, superClass);

    function NotEqual(json) {
      NotEqual.__super__.constructor.apply(this, arguments);
    }

    NotEqual.prototype.exec = function(ctx) {
      return ThreeValuedLogic.not(equals.apply(null, this.execArgs(ctx)));
    };

    return NotEqual;

  })(Expression);

  module.exports.Union = Union = (function(superClass) {
    extend(Union, superClass);

    function Union(json) {
      Union.__super__.constructor.apply(this, arguments);
    }

    Union.prototype.exec = function(ctx) {
      var a, b, lib, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doUnion(a, b);
    };

    return Union;

  })(Expression);

  module.exports.Except = Except = (function(superClass) {
    extend(Except, superClass);

    function Except(json) {
      Except.__super__.constructor.apply(this, arguments);
    }

    Except.prototype.exec = function(ctx) {
      var a, b, lib, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doExcept(a, b);
    };

    return Except;

  })(Expression);

  module.exports.Intersect = Intersect = (function(superClass) {
    extend(Intersect, superClass);

    function Intersect(json) {
      Intersect.__super__.constructor.apply(this, arguments);
    }

    Intersect.prototype.exec = function(ctx) {
      var a, b, lib, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIntersect(a, b);
    };

    return Intersect;

  })(Expression);

  module.exports.ArrayIndexOutOfBoundsException = ArrayIndexOutOfBoundsException = ArrayIndexOutOfBoundsException = (function(superClass) {
    extend(ArrayIndexOutOfBoundsException, superClass);

    function ArrayIndexOutOfBoundsException() {
      return ArrayIndexOutOfBoundsException.__super__.constructor.apply(this, arguments);
    }

    return ArrayIndexOutOfBoundsException;

  })(Exception);

  module.exports.Indexer = Indexer = (function(superClass) {
    extend(Indexer, superClass);

    function Indexer(json) {
      Indexer.__super__.constructor.apply(this, arguments);
    }

    Indexer.prototype.exec = function(ctx) {
      var index, operand, ref;
      ref = this.execArgs(ctx), operand = ref[0], index = ref[1];
      if ((operand == null) || (index == null)) {
        return null;
      }
      if (index < 0 || index >= operand.length) {
        throw new ArrayIndexOutOfBoundsException();
      }
      return operand[index];
    };

    return Indexer;

  })(Expression);

  module.exports.In = In = (function(superClass) {
    extend(In, superClass);

    function In(json) {
      In.__super__.constructor.apply(this, arguments);
    }

    In.prototype.exec = function(ctx) {
      var container, item, lib, ref;
      ref = this.execArgs(ctx), item = ref[0], container = ref[1];
      if ((item == null) || (container == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doContains(container, item);
    };

    return In;

  })(Expression);

  module.exports.Contains = Contains = (function(superClass) {
    extend(Contains, superClass);

    function Contains(json) {
      Contains.__super__.constructor.apply(this, arguments);
    }

    Contains.prototype.exec = function(ctx) {
      var container, item, lib, ref;
      ref = this.execArgs(ctx), container = ref[0], item = ref[1];
      if ((item == null) || (container == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doContains(container, item);
    };

    return Contains;

  })(Expression);

  module.exports.Includes = Includes = (function(superClass) {
    extend(Includes, superClass);

    function Includes(json) {
      Includes.__super__.constructor.apply(this, arguments);
    }

    Includes.prototype.exec = function(ctx) {
      var contained, container, lib, ref;
      ref = this.execArgs(ctx), container = ref[0], contained = ref[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIncludes(container, contained);
    };

    return Includes;

  })(Expression);

  module.exports.IncludedIn = IncludedIn = (function(superClass) {
    extend(IncludedIn, superClass);

    function IncludedIn(json) {
      IncludedIn.__super__.constructor.apply(this, arguments);
    }

    IncludedIn.prototype.exec = function(ctx) {
      var contained, container, lib, ref;
      ref = this.execArgs(ctx), contained = ref[0], container = ref[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIncludes(container, contained);
    };

    return IncludedIn;

  })(Expression);

  module.exports.ProperIncludes = ProperIncludes = (function(superClass) {
    extend(ProperIncludes, superClass);

    function ProperIncludes(json) {
      ProperIncludes.__super__.constructor.apply(this, arguments);
    }

    ProperIncludes.prototype.exec = function(ctx) {
      var contained, container, lib, ref;
      ref = this.execArgs(ctx), container = ref[0], contained = ref[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doProperIncludes(container, contained);
    };

    return ProperIncludes;

  })(Expression);

  module.exports.ProperIncludedIn = ProperIncludedIn = (function(superClass) {
    extend(ProperIncludedIn, superClass);

    function ProperIncludedIn(json) {
      ProperIncludedIn.__super__.constructor.apply(this, arguments);
    }

    ProperIncludedIn.prototype.exec = function(ctx) {
      var contained, container, lib, ref;
      ref = this.execArgs(ctx), contained = ref[0], container = ref[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doProperIncludes(container, contained);
    };

    return ProperIncludedIn;

  })(Expression);

  module.exports.Length = Length = (function(superClass) {
    extend(Length, superClass);

    function Length(json) {
      Length.__super__.constructor.apply(this, arguments);
    }

    Length.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.length;
      } else {
        return null;
      }
    };

    return Length;

  })(Expression);

  module.exports.After = After = (function(superClass) {
    extend(After, superClass);

    function After(json) {
      var ref;
      After.__super__.constructor.apply(this, arguments);
      this.precision = (ref = json.precision) != null ? ref.toLowerCase() : void 0;
    }

    After.prototype.exec = function(ctx) {
      var a, b, lib, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !(a instanceof DateTime):
            return DT;
          default:
            return IVL;
        }
      })();
      return lib.doAfter(a, b, this.precision);
    };

    return After;

  })(Expression);

  module.exports.Before = After = (function(superClass) {
    extend(After, superClass);

    function After(json) {
      var ref;
      After.__super__.constructor.apply(this, arguments);
      this.precision = (ref = json.precision) != null ? ref.toLowerCase() : void 0;
    }

    After.prototype.exec = function(ctx) {
      var a, b, lib, ref;
      ref = this.execArgs(ctx), a = ref[0], b = ref[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !(a instanceof DateTime):
            return DT;
          default:
            return IVL;
        }
      })();
      return lib.doBefore(a, b, this.precision);
    };

    return After;

  })(Expression);

}).call(this);



},{"../datatypes/datetime":7,"../datatypes/exception":8,"../datatypes/logic":10,"../util/comparison":133,"../util/util":135,"./builder":14,"./datetime":18,"./expression":20,"./interval":24,"./list":26,"./string":35}],31:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, ParameterDef, ParameterRef, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.ParameterDef = ParameterDef = (function(superClass) {
    extend(ParameterDef, superClass);

    function ParameterDef(json) {
      ParameterDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this["default"] = build(json["default"]);
      this.parameterTypeSpecifier = json.parameterTypeSpecifier;
    }

    ParameterDef.prototype.exec = function(ctx) {
      var ref;
      if (((ctx != null ? ctx.parameters[this.name] : void 0) != null)) {
        return ctx.parameters[this.name];
      } else {
        return (ref = this["default"]) != null ? ref.execute(ctx) : void 0;
      }
    };

    return ParameterDef;

  })(Expression);

  module.exports.ParameterRef = ParameterRef = (function(superClass) {
    extend(ParameterRef, superClass);

    function ParameterRef(json) {
      ParameterRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    ParameterRef.prototype.exec = function(ctx) {
      var ref;
      return (ref = ctx.getParameter(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return ParameterRef;

  })(Expression);

}).call(this);



},{"./builder":14,"./expression":20}],32:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Code, Expression, Quantity, ValueSet, build, clean_unit, durationInMilliseconds, get_ucum_unit, ref, ucum_time_units, ucum_to_cql_units,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ref = require('../datatypes/datatypes'), ValueSet = ref.ValueSet, Code = ref.Code;

  build = require('./builder').build;

  module.exports.Quantity = Quantity = (function(superClass) {
    extend(Quantity, superClass);

    function Quantity(json) {
      Quantity.__super__.constructor.apply(this, arguments);
      this.unit = json.unit;
      this.value = parseFloat(json.value);
    }

    Quantity.prototype.clone = function() {
      return new Quantity({
        value: this.value,
        unit: this.unit
      });
    };

    Quantity.prototype.exec = function(ctx) {
      return this;
    };

    Quantity.prototype.toString = function() {
      return this.value + " '" + this.unit + "'";
    };

    Quantity.prototype.sameOrBefore = function(other) {
      var otherDurationInMilliseconds, thisDurationInMilliseconds;
      if (other instanceof Quantity && other.unit === this.unit) {
        return this.value <= parseFloat(other.value);
      } else if (other instanceof Quantity && (ucum_time_units[other.unit] != null) && (ucum_time_units[this.unit] != null)) {
        thisDurationInMilliseconds = durationInMilliseconds(this);
        otherDurationInMilliseconds = durationInMilliseconds(other);
        return thisDurationInMilliseconds <= otherDurationInMilliseconds;
      } else {
        return null;
      }
    };

    Quantity.prototype.sameOrAfter = function(other) {
      var otherDurationInMilliseconds, thisDurationInMilliseconds;
      if (other instanceof Quantity && other.unit === this.unit) {
        return this.value >= parseFloat(other.value);
      } else if (other instanceof Quantity && (ucum_time_units[other.unit] != null) && (ucum_time_units[this.unit] != null)) {
        thisDurationInMilliseconds = durationInMilliseconds(this);
        otherDurationInMilliseconds = durationInMilliseconds(other);
        return thisDurationInMilliseconds >= otherDurationInMilliseconds;
      } else {
        return null;
      }
    };

    Quantity.prototype.after = function(other) {
      var otherDurationInMilliseconds, thisDurationInMilliseconds;
      if (other instanceof Quantity && other.unit === this.unit) {
        return this.value > parseFloat(other.value);
      } else if (other instanceof Quantity && (ucum_time_units[other.unit] != null) && (ucum_time_units[this.unit] != null)) {
        thisDurationInMilliseconds = durationInMilliseconds(this);
        otherDurationInMilliseconds = durationInMilliseconds(other);
        return thisDurationInMilliseconds > otherDurationInMilliseconds;
      } else {
        return null;
      }
    };

    Quantity.prototype.before = function(other) {
      var otherDurationInMilliseconds, thisDurationInMilliseconds;
      if (other instanceof Quantity && other.unit === this.unit) {
        return this.value < parseFloat(other.value);
      } else if (other instanceof Quantity && (ucum_time_units[other.unit] != null) && (ucum_time_units[this.unit] != null)) {
        thisDurationInMilliseconds = durationInMilliseconds(this);
        otherDurationInMilliseconds = durationInMilliseconds(other);
        return thisDurationInMilliseconds < otherDurationInMilliseconds;
      } else {
        return null;
      }
    };

    Quantity.prototype.equals = function(other) {
      var otherDurationInMilliseconds, thisDurationInMilliseconds;
      if (other instanceof Quantity && this.unit === other.unit) {
        return this.value === parseFloat(other.value);
      } else if (other instanceof Quantity && (ucum_time_units[other.unit] != null) && (ucum_time_units[this.unit] != null)) {
        thisDurationInMilliseconds = durationInMilliseconds(this);
        otherDurationInMilliseconds = durationInMilliseconds(other);
        return thisDurationInMilliseconds === otherDurationInMilliseconds;
      } else {
        return null;
      }
    };

    return Quantity;

  })(Expression);

  clean_unit = function(units) {
    if (ucum_time_units[units]) {
      return ucum_to_cql_units[ucum_time_units[units]];
    } else {
      return units;
    }
  };

  ucum_time_units = {
    'years': 'a_g',
    'year': 'a_g',
    'YEARS': 'a_g',
    'YEAR': 'a_g',
    'a_g': 'a_g',
    'a': 'a_j',
    'ANN': 'a_j',
    'ann': 'a_j',
    'A': 'a_j',
    'a_j': 'a_j',
    'months': 'mo_g',
    'month': 'mo_g',
    'mo_g': 'mo_g',
    'mo': 'mo_j',
    'MO': 'mo_j',
    'mo_j': 'mo_j',
    'weeks': 'wk',
    'week': 'wk',
    'wk': 'wk',
    'WK': 'wk',
    'days': 'd',
    'day': 'd',
    'd': 'd',
    'D': 'd',
    'hours': 'h',
    'hour': 'h',
    'h': 'h',
    'H': 'h',
    'minutes': 'min',
    'minute': 'min',
    'min': 'min',
    'MIN': 'min',
    'seconds': 's',
    'second': 's',
    's': 's',
    'S': 's',
    'milliseconds': 'ms',
    'millisecond': 'ms',
    'ms': 'ms',
    'MS': 'ms'
  };

  ucum_to_cql_units = {
    'a_j': 'year',
    'a_g': 'year',
    'mo_j': 'month',
    'mo_g': 'month',
    'wk': 'week',
    'd': 'day',
    'h': 'hour',
    'min': 'minute',
    's': 'second',
    'ms': 'millisecond'
  };

  get_ucum_unit = function(units) {
    if (ucum_time_units[units]) {
      return ucum_time_units[units];
    } else {
      return units;
    }
  };

  durationInMilliseconds = function(qty) {
    var millivalue;
    if (parseFloat(qty.value)) {
      millivalue = (function() {
        switch (false) {
          case get_ucum_unit(qty.unit) !== 's':
            return qty.value * 1000;
          case get_ucum_unit(qty.unit) !== 'min':
            return qty.value * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'h':
            return qty.value * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'd':
            return qty.value * 24 * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'wk':
            return qty.value * 7 * 24 * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'mo_g':
            return qty.value * 30.436875 * 24 * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'a_g':
            return qty.value * 365.2425 * 24 * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'mo_j':
            return qty.value * 30.4375 * 24 * 60 * 60 * 1000;
          case get_ucum_unit(qty.unit) !== 'a_j':
            return qty.value * 365.25 * 24 * 60 * 60 * 1000;
          default:
            return qty.value;
        }
      })();
      return millivalue;
    } else {
      return null;
    }
  };

  module.exports.createQuantity = function(value, unit) {
    return new Quantity({
      value: value,
      unit: unit
    });
  };

  module.exports.parseQuantity = function(str) {
    var components, unit, value;
    components = /([+|-]?\d+\.?\d*)\s*'(.+)'/.exec(str);
    if ((components != null) && (components[1] != null) && (components[2] != null)) {
      value = parseFloat(components[1]);
      unit = components[2].trim();
      return new Quantity({
        value: value,
        unit: unit
      });
    } else {
      return null;
    }
  };

  module.exports.doAddition = function(a, b) {
    if (a instanceof Quantity && b instanceof Quantity) {
      if (a.unit === b.unit) {
        return new Quantity({
          unit: a.unit,
          value: a.value + b.value
        });
      }
    } else {
      return a.copy().add(b.value, clean_unit(b.unit));
    }
  };

  module.exports.doSubtraction = function(a, b) {
    if (a instanceof Quantity && b instanceof Quantity) {
      if (a.unit === b.unit) {
        return new Quantity({
          unit: a.unit,
          value: a.value - b.value
        });
      }
    } else {
      return a.copy().add(b.value * -1, clean_unit(b.unit));
    }
  };

  module.exports.doDivision = function(a, b) {
    if (a instanceof Quantity && b instanceof Quantity) {
      if (a.unit === b.unit) {
        return a.value / b.value;
      }
    } else {
      return new Quantity({
        unit: a.unit,
        value: a.value / b
      });
    }
  };

  module.exports.doMultiplication = function(a, b) {
    var d, q, ref1;
    if (a instanceof Quantity && b instanceof Quantity) {
      return null;
    } else {
      ref1 = a instanceof Quantity ? [a, b] : [b, a], q = ref1[0], d = ref1[1];
      return new Quantity({
        unit: q.unit,
        value: q.value * d
      });
    }
  };

}).call(this);



},{"../datatypes/datatypes":6,"./builder":14,"./expression":20}],33:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var AliasRef, AliasedQuerySource, ByColumn, ByDirection, ByExpression, Context, Expression, LetClause, MultiSource, Query, QueryLetRef, ReturnClause, Sort, SortClause, UnimplementedExpression, With, Without, allTrue, build, equals, ref, ref1, toDistinctList, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  Context = require('../runtime/context').Context;

  build = require('./builder').build;

  ref1 = require('../util/util'), typeIsArray = ref1.typeIsArray, allTrue = ref1.allTrue;

  equals = require('../util/comparison').equals;

  module.exports.AliasedQuerySource = AliasedQuerySource = (function() {
    function AliasedQuerySource(json) {
      this.alias = json.alias;
      this.expression = build(json.expression);
    }

    return AliasedQuerySource;

  })();

  module.exports.LetClause = LetClause = (function() {
    function LetClause(json) {
      this.identifier = json.identifier;
      this.expression = build(json.expression);
    }

    return LetClause;

  })();

  module.exports.With = With = (function(superClass) {
    extend(With, superClass);

    function With(json) {
      With.__super__.constructor.apply(this, arguments);
      this.alias = json.alias;
      this.expression = build(json.expression);
      this.suchThat = build(json.suchThat);
    }

    With.prototype.exec = function(ctx) {
      var childCtx, rec, records, returns;
      records = this.expression.execute(ctx);
      this.isList = typeIsArray(records);
      records = this.isList ? records : [records];
      returns = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = records.length; i < len; i++) {
          rec = records[i];
          childCtx = ctx.childContext();
          childCtx.set(this.alias, rec);
          results.push(this.suchThat.execute(childCtx));
        }
        return results;
      }).call(this);
      return returns.some(function(x) {
        return x;
      });
    };

    return With;

  })(Expression);

  module.exports.Without = Without = (function(superClass) {
    extend(Without, superClass);

    function Without(json) {
      Without.__super__.constructor.apply(this, arguments);
    }

    Without.prototype.exec = function(ctx) {
      return !Without.__super__.exec.call(this, ctx);
    };

    return Without;

  })(With);

  module.exports.Sort = Sort = (function(superClass) {
    extend(Sort, superClass);

    function Sort() {
      return Sort.__super__.constructor.apply(this, arguments);
    }

    return Sort;

  })(UnimplementedExpression);

  module.exports.ByDirection = ByDirection = (function(superClass) {
    extend(ByDirection, superClass);

    function ByDirection(json) {
      ByDirection.__super__.constructor.apply(this, arguments);
      this.direction = json.direction;
      this.low_order = this.direction === "asc" ? -1 : 1;
      this.high_order = this.low_order * -1;
    }

    ByDirection.prototype.exec = function(a, b) {
      if (a === b) {
        return 0;
      } else if (a < b) {
        return this.low_order;
      } else {
        return this.high_order;
      }
    };

    return ByDirection;

  })(Expression);

  module.exports.ByExpression = ByExpression = (function(superClass) {
    extend(ByExpression, superClass);

    function ByExpression(json) {
      ByExpression.__super__.constructor.apply(this, arguments);
      this.expression = build(json.expression);
      this.direction = json.direction;
      this.low_order = this.direction === "asc" ? -1 : 1;
      this.high_order = this.low_order * -1;
    }

    ByExpression.prototype.exec = function(a, b) {
      var a_val, b_val, ctx;
      ctx = new Context();
      ctx.context_values = a;
      a_val = this.expression.execute(ctx);
      ctx.context_values = b;
      b_val = this.expression.execute(ctx);
      if (a_val === b_val) {
        return 0;
      } else if (a_val < b_val) {
        return this.low_order;
      } else {
        return this.high_order;
      }
    };

    return ByExpression;

  })(Expression);

  module.exports.ByColumn = ByColumn = (function(superClass) {
    extend(ByColumn, superClass);

    function ByColumn(json) {
      ByColumn.__super__.constructor.apply(this, arguments);
      this.expression = build({
        "name": json.path,
        "type": "IdentifierRef"
      });
    }

    return ByColumn;

  })(ByExpression);

  module.exports.ReturnClause = ReturnClause = ReturnClause = (function() {
    function ReturnClause(json) {
      var ref2;
      this.expression = build(json.expression);
      this.distinct = (ref2 = json.distinct) != null ? ref2 : true;
    }

    return ReturnClause;

  })();

  module.exports.SortClause = SortClause = SortClause = (function() {
    function SortClause(json) {
      this.by = build(json != null ? json.by : void 0);
    }

    SortClause.prototype.sort = function(values) {
      if (this.by) {
        return values.sort((function(_this) {
          return function(a, b) {
            var i, item, len, order, ref2;
            order = 0;
            ref2 = _this.by;
            for (i = 0, len = ref2.length; i < len; i++) {
              item = ref2[i];
              order = item.exec(a, b);
              if (order !== 0) {
                break;
              }
            }
            return order;
          };
        })(this));
      }
    };

    return SortClause;

  })();

  toDistinctList = function(xList) {
    var i, inYList, j, len, len1, x, y, yList;
    yList = [];
    for (i = 0, len = xList.length; i < len; i++) {
      x = xList[i];
      inYList = false;
      for (j = 0, len1 = yList.length; j < len1; j++) {
        y = yList[j];
        if (equals(x, y)) {
          inYList = true;
        }
      }
      if (!inYList) {
        yList.push(x);
      }
    }
    return yList;
  };

  module.exports.Query = Query = (function(superClass) {
    extend(Query, superClass);

    function Query(json) {
      var d, s;
      Query.__super__.constructor.apply(this, arguments);
      this.sources = new MultiSource((function() {
        var i, len, ref2, results;
        ref2 = json.source;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          s = ref2[i];
          results.push(new AliasedQuerySource(s));
        }
        return results;
      })());
      this.letClauses = (function() {
        var i, len, ref2, ref3, results;
        ref3 = (ref2 = json["let"]) != null ? ref2 : [];
        results = [];
        for (i = 0, len = ref3.length; i < len; i++) {
          d = ref3[i];
          results.push(new LetClause(d));
        }
        return results;
      })();
      this.relationship = json.relationship != null ? build(json.relationship) : [];
      this.where = build(json.where);
      this.returnClause = json["return"] != null ? new ReturnClause(json["return"]) : null;
      this.aliases = this.sources.aliases();
      this.sortClause = json.sort != null ? new SortClause(json.sort) : null;
    }

    Query.prototype.exec = function(ctx) {
      var distinct, ref2, returnedValues;
      returnedValues = [];
      this.sources.forEach(ctx, (function(_this) {
        return function(rctx) {
          var child_ctx, def, i, len, passed, ref2, rel, relations, val;
          ref2 = _this.letClauses;
          for (i = 0, len = ref2.length; i < len; i++) {
            def = ref2[i];
            rctx.set(def.identifier, def.expression.execute(rctx));
          }
          relations = (function() {
            var j, len1, ref3, results;
            ref3 = this.relationship;
            results = [];
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              rel = ref3[j];
              child_ctx = rctx.childContext();
              results.push(rel.execute(child_ctx));
            }
            return results;
          }).call(_this);
          passed = allTrue(relations);
          passed = passed && (_this.where ? _this.where.execute(rctx) : passed);
          if (passed) {
            if (_this.returnClause != null) {
              val = _this.returnClause.expression.execute(rctx);
              return returnedValues.push(val);
            } else {
              if (_this.aliases.length === 1) {
                return returnedValues.push(rctx.get(_this.aliases[0]));
              } else {
                return returnedValues.push(rctx.context_values);
              }
            }
          }
        };
      })(this));
      distinct = this.returnClause != null ? this.returnClause.distinct : true;
      if (distinct) {
        returnedValues = toDistinctList(returnedValues);
      }
      if ((ref2 = this.sortClause) != null) {
        ref2.sort(returnedValues);
      }
      if (this.sources.returnsList()) {
        return returnedValues;
      } else {
        return returnedValues[0];
      }
    };

    return Query;

  })(Expression);

  module.exports.AliasRef = AliasRef = (function(superClass) {
    extend(AliasRef, superClass);

    function AliasRef(json) {
      AliasRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    AliasRef.prototype.exec = function(ctx) {
      return ctx != null ? ctx.get(this.name) : void 0;
    };

    return AliasRef;

  })(Expression);

  module.exports.QueryLetRef = QueryLetRef = (function(superClass) {
    extend(QueryLetRef, superClass);

    function QueryLetRef(json) {
      QueryLetRef.__super__.constructor.apply(this, arguments);
    }

    return QueryLetRef;

  })(AliasRef);

  MultiSource = (function() {
    function MultiSource(sources) {
      this.sources = sources;
      this.alias = this.sources[0].alias;
      this.expression = this.sources[0].expression;
      this.isList = true;
      if (this.sources.length > 1) {
        this.rest = new MultiSource(this.sources.slice(1));
      }
    }

    MultiSource.prototype.aliases = function() {
      var a;
      a = [this.alias];
      if (this.rest) {
        a = a.concat(this.rest.aliases());
      }
      return a;
    };

    MultiSource.prototype.returnsList = function() {
      return this.isList || (this.rest && this.rest.returnsList());
    };

    MultiSource.prototype.forEach = function(ctx, func) {
      var i, len, rctx, rec, records, results;
      records = this.expression.execute(ctx);
      this.isList = typeIsArray(records);
      records = this.isList ? records : [records];
      results = [];
      for (i = 0, len = records.length; i < len; i++) {
        rec = records[i];
        rctx = new Context(ctx);
        rctx.set(this.alias, rec);
        if (this.rest) {
          results.push(this.rest.forEach(rctx, func));
        } else {
          results.push(func(rctx));
        }
      }
      return results;
    };

    return MultiSource;

  })();

}).call(this);



},{"../runtime/context":129,"../util/comparison":133,"../util/util":135,"./builder":14,"./expression":20}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, ExpressionDef, ExpressionRef, FunctionDef, FunctionRef, IdentifierRef, OperandRef, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.ExpressionDef = ExpressionDef = (function(superClass) {
    extend(ExpressionDef, superClass);

    function ExpressionDef(json) {
      ExpressionDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.context = json.context;
      this.expression = build(json.expression);
    }

    ExpressionDef.prototype.exec = function(ctx) {
      var ref, value;
      value = (ref = this.expression) != null ? ref.execute(ctx) : void 0;
      ctx.rootContext().set(this.name, value);
      return value;
    };

    return ExpressionDef;

  })(Expression);

  module.exports.ExpressionRef = ExpressionRef = (function(superClass) {
    extend(ExpressionRef, superClass);

    function ExpressionRef(json) {
      ExpressionRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    ExpressionRef.prototype.exec = function(ctx) {
      var value;
      ctx = this.library ? ctx.getLibraryContext(this.library) : ctx;
      value = ctx.get(this.name);
      if (value instanceof Expression) {
        value = value.execute(ctx);
      }
      return value;
    };

    return ExpressionRef;

  })(Expression);

  module.exports.FunctionDef = FunctionDef = (function(superClass) {
    extend(FunctionDef, superClass);

    function FunctionDef(json) {
      FunctionDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.expression = build(json.expression);
      this.parameters = json.operand;
    }

    FunctionDef.prototype.exec = function(ctx) {
      return this;
    };

    return FunctionDef;

  })(Expression);

  module.exports.FunctionRef = FunctionRef = (function(superClass) {
    extend(FunctionRef, superClass);

    function FunctionRef(json) {
      FunctionRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    FunctionRef.prototype.exec = function(ctx) {
      var args, child_ctx, functionDef, i, j, len, p, ref, ref1, ref2;
      functionDef = this.library ? (ref = ctx.get(this.library)) != null ? ref.get(this.name) : void 0 : ctx.get(this.name);
      args = this.execArgs(ctx);
      child_ctx = this.library ? (ref1 = ctx.getLibraryContext(this.library)) != null ? ref1.childContext() : void 0 : ctx.childContext();
      if (args.length !== functionDef.parameters.length) {
        throw new Error("incorrect number of arguments supplied");
      }
      ref2 = functionDef.parameters;
      for (i = j = 0, len = ref2.length; j < len; i = ++j) {
        p = ref2[i];
        child_ctx.set(p.name, args[i]);
      }
      return functionDef.expression.execute(child_ctx);
    };

    return FunctionRef;

  })(Expression);

  module.exports.OperandRef = OperandRef = (function(superClass) {
    extend(OperandRef, superClass);

    function OperandRef(json) {
      this.name = json.name;
    }

    OperandRef.prototype.exec = function(ctx) {
      return ctx.get(this.name);
    };

    return OperandRef;

  })(Expression);

  module.exports.IdentifierRef = IdentifierRef = (function(superClass) {
    extend(IdentifierRef, superClass);

    function IdentifierRef(json) {
      IdentifierRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    IdentifierRef.prototype.exec = function(ctx) {
      var _obj, curr_obj, curr_val, j, len, part, parts, ref, ref1, ref2, val;
      val = this.library ? (ref = ctx.get(this.library)) != null ? ref.get(this.name) : void 0 : ctx.get(this.name);
      if (val == null) {
        parts = this.name.split(".");
        val = ctx.get(part);
        if ((val != null) && parts.length > 1) {
          curr_obj = val;
          curr_val = null;
          ref1 = parts.slice(1);
          for (j = 0, len = ref1.length; j < len; j++) {
            part = ref1[j];
            _obj = (ref2 = curr_obj != null ? curr_obj[part] : void 0) != null ? ref2 : curr_obj != null ? typeof curr_obj.get === "function" ? curr_obj.get(part) : void 0 : void 0;
            curr_obj = _obj instanceof Function ? _obj.call(curr_obj) : _obj;
          }
          val = curr_obj;
        }
      }
      if (val instanceof Function) {
        return val.call(ctx.context_values);
      } else {
        return val;
      }
    };

    return IdentifierRef;

  })(Expression);

}).call(this);



},{"./builder":14,"./expression":20}],35:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Combine, Concatenate, Expression, Lower, PositionOf, Split, Substring, Upper, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.Concatenate = Concatenate = (function(superClass) {
    extend(Concatenate, superClass);

    function Concatenate(json) {
      Concatenate.__super__.constructor.apply(this, arguments);
    }

    Concatenate.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return x + y;
        });
      }
    };

    return Concatenate;

  })(Expression);

  module.exports.Combine = Combine = (function(superClass) {
    extend(Combine, superClass);

    function Combine(json) {
      Combine.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
      this.separator = build(json.separator);
    }

    Combine.prototype.exec = function(ctx) {
      var separator, source;
      source = this.source.execute(ctx);
      separator = this.separator != null ? this.separator.execute(ctx) : '';
      if ((source == null) || source.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return source.join(separator);
      }
    };

    return Combine;

  })(Expression);

  module.exports.Split = Split = (function(superClass) {
    extend(Split, superClass);

    function Split(json) {
      Split.__super__.constructor.apply(this, arguments);
      this.stringToSplit = build(json.stringToSplit);
      this.separator = build(json.separator);
    }

    Split.prototype.exec = function(ctx) {
      var separator, stringToSplit;
      stringToSplit = this.stringToSplit.execute(ctx);
      separator = this.separator.execute(ctx);
      if (!((stringToSplit != null) && (separator != null))) {
        return null;
      } else {
        return stringToSplit.split(separator);
      }
    };

    return Split;

  })(Expression);

  module.exports.Upper = Upper = (function(superClass) {
    extend(Upper, superClass);

    function Upper(json) {
      Upper.__super__.constructor.apply(this, arguments);
    }

    Upper.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.toUpperCase();
      } else {
        return null;
      }
    };

    return Upper;

  })(Expression);

  module.exports.Lower = Lower = (function(superClass) {
    extend(Lower, superClass);

    function Lower(json) {
      Lower.__super__.constructor.apply(this, arguments);
    }

    Lower.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.toLowerCase();
      } else {
        return null;
      }
    };

    return Lower;

  })(Expression);

  module.exports.PositionOf = PositionOf = (function(superClass) {
    extend(PositionOf, superClass);

    function PositionOf(json) {
      PositionOf.__super__.constructor.apply(this, arguments);
      this.pattern = build(json.pattern);
      this.string = build(json.string);
    }

    PositionOf.prototype.exec = function(ctx) {
      var pattern, string;
      pattern = this.pattern.execute(ctx);
      string = this.string.execute(ctx);
      if (!((pattern != null) && (string != null))) {
        return null;
      } else {
        return string.indexOf(pattern);
      }
    };

    return PositionOf;

  })(Expression);

  module.exports.Substring = Substring = (function(superClass) {
    extend(Substring, superClass);

    function Substring(json) {
      Substring.__super__.constructor.apply(this, arguments);
      this.stringToSub = build(json.stringToSub);
      this.startIndex = build(json.startIndex);
      this.length = build(json['length']);
    }

    Substring.prototype.exec = function(ctx) {
      var length, startIndex, stringToSub;
      stringToSub = this.stringToSub.execute(ctx);
      startIndex = this.startIndex.execute(ctx);
      length = this.length != null ? this.length.execute(ctx) : null;
      if ((stringToSub == null) || (startIndex == null) || startIndex < 0 || startIndex >= stringToSub.length) {
        return null;
      } else if (length != null) {
        return stringToSub.substr(startIndex, length);
      } else {
        return stringToSub.substr(startIndex);
      }
    };

    return Substring;

  })(Expression);

}).call(this);



},{"./builder":14,"./expression":20}],36:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Expression, Property, Tuple, TupleElement, TupleElementDefinition, UnimplementedExpression, build, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  build = require('./builder').build;

  module.exports.Property = Property = (function(superClass) {
    extend(Property, superClass);

    function Property(json) {
      Property.__super__.constructor.apply(this, arguments);
      this.scope = json.scope;
      this.source = build(json.source);
      this.path = json.path;
    }

    Property.prototype.exec = function(ctx) {
      var _obj, curr_obj, curr_val, i, len, obj, part, parts, ref1, ref2, val;
      obj = this.scope != null ? ctx.get(this.scope) : this.source;
      if (obj instanceof Expression) {
        obj = obj.execute(ctx);
      }
      val = (ref1 = obj != null ? obj[this.path] : void 0) != null ? ref1 : obj != null ? typeof obj.get === "function" ? obj.get(this.path) : void 0 : void 0;
      if (!val) {
        parts = this.path.split(".");
        curr_obj = obj;
        curr_val = null;
        for (i = 0, len = parts.length; i < len; i++) {
          part = parts[i];
          _obj = (ref2 = curr_obj != null ? curr_obj[part] : void 0) != null ? ref2 : curr_obj != null ? typeof curr_obj.get === "function" ? curr_obj.get(part) : void 0 : void 0;
          curr_obj = _obj instanceof Function ? _obj.call(curr_obj) : _obj;
        }
        val = curr_obj;
      }
      if (val instanceof Function) {
        return val.call(obj);
      } else {
        return val;
      }
    };

    return Property;

  })(Expression);

  module.exports.Tuple = Tuple = (function(superClass) {
    extend(Tuple, superClass);

    function Tuple(json) {
      var el;
      Tuple.__super__.constructor.apply(this, arguments);
      this.elements = (function() {
        var i, len, ref1, results;
        ref1 = json.element;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          el = ref1[i];
          results.push({
            name: el.name,
            value: build(el.value)
          });
        }
        return results;
      })();
    }

    Tuple.prototype.exec = function(ctx) {
      var el, i, len, ref1, ref2, val;
      val = {};
      ref1 = this.elements;
      for (i = 0, len = ref1.length; i < len; i++) {
        el = ref1[i];
        val[el.name] = (ref2 = el.value) != null ? ref2.execute(ctx) : void 0;
      }
      return val;
    };

    return Tuple;

  })(Expression);

  module.exports.TupleElement = TupleElement = (function(superClass) {
    extend(TupleElement, superClass);

    function TupleElement() {
      return TupleElement.__super__.constructor.apply(this, arguments);
    }

    return TupleElement;

  })(UnimplementedExpression);

  module.exports.TupleElementDefinition = TupleElementDefinition = (function(superClass) {
    extend(TupleElementDefinition, superClass);

    function TupleElementDefinition() {
      return TupleElementDefinition.__super__.constructor.apply(this, arguments);
    }

    return TupleElementDefinition;

  })(UnimplementedExpression);

}).call(this);



},{"./builder":14,"./expression":20}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var As, Concept, Convert, DateTime, Expression, FunctionRef, IntervalTypeSpecifier, Is, ListTypeSpecifier, NamedTypeSpecifier, ToBoolean, ToConcept, ToDateTime, ToDecimal, ToInteger, ToQuantity, ToString, ToTime, TupleTypeSpecifier, UnimplementedExpression, parseQuantity, ref, ref1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  FunctionRef = require('./reusable').FunctionRef;

  ref1 = require('../datatypes/datetime'), Concept = ref1.Concept, DateTime = ref1.DateTime;

  parseQuantity = require('./quantity').parseQuantity;

  module.exports.As = As = (function(superClass) {
    extend(As, superClass);

    function As(json) {
      var ref2;
      As.__super__.constructor.apply(this, arguments);
      this.asType = json.asType;
      this.asTypeSpecifier = json.asTypeSpecifier;
      this.strict = (ref2 = json.strict) != null ? ref2 : false;
    }

    As.prototype.exec = function(ctx) {
      return this.execArgs(ctx);
    };

    return As;

  })(Expression);

  module.exports.ToBoolean = ToBoolean = (function(superClass) {
    extend(ToBoolean, superClass);

    function ToBoolean(json) {
      ToBoolean.__super__.constructor.apply(this, arguments);
    }

    ToBoolean.prototype.exec = function(ctx) {
      var arg, strArg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        strArg = arg.toString();
        if (strArg === "true" || strArg === "t" || strArg === "yes" || strArg === "y" || strArg === "1") {
          return true;
        } else if (strArg === "false" || strArg === "f" || strArg === "no" || strArg === "n" || strArg === "0") {
          return false;
        } else {
          throw new Error("cannot convert " + strArg + " to Boolean");
        }
      } else {
        return null;
      }
    };

    return ToBoolean;

  })(Expression);

  module.exports.ToConcept = ToConcept = (function(superClass) {
    extend(ToConcept, superClass);

    function ToConcept(json) {
      ToConcept.__super__.constructor.apply(this, arguments);
    }

    ToConcept.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return new Concept([arg], arg.display);
      } else {
        return null;
      }
    };

    return ToConcept;

  })(Expression);

  module.exports.ToDateTime = ToDateTime = (function(superClass) {
    extend(ToDateTime, superClass);

    function ToDateTime(json) {
      ToDateTime.__super__.constructor.apply(this, arguments);
    }

    ToDateTime.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return DateTime.parse(arg.toString());
      } else {
        return null;
      }
    };

    return ToDateTime;

  })(Expression);

  module.exports.ToDecimal = ToDecimal = (function(superClass) {
    extend(ToDecimal, superClass);

    function ToDecimal(json) {
      ToDecimal.__super__.constructor.apply(this, arguments);
    }

    ToDecimal.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return parseFloat(arg.toString());
      } else {
        return null;
      }
    };

    return ToDecimal;

  })(Expression);

  module.exports.ToInteger = ToInteger = (function(superClass) {
    extend(ToInteger, superClass);

    function ToInteger(json) {
      ToInteger.__super__.constructor.apply(this, arguments);
    }

    ToInteger.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return parseInt(arg.toString());
      } else {
        return null;
      }
    };

    return ToInteger;

  })(Expression);

  module.exports.ToQuantity = ToQuantity = (function(superClass) {
    extend(ToQuantity, superClass);

    function ToQuantity(json) {
      ToQuantity.__super__.constructor.apply(this, arguments);
    }

    ToQuantity.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return parseQuantity(arg.toString());
      } else {
        return null;
      }
    };

    return ToQuantity;

  })(Expression);

  module.exports.ToString = ToString = (function(superClass) {
    extend(ToString, superClass);

    function ToString(json) {
      ToString.__super__.constructor.apply(this, arguments);
    }

    ToString.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return arg.toString();
      } else {
        return null;
      }
    };

    return ToString;

  })(Expression);

  module.exports.ToTime = ToTime = (function(superClass) {
    extend(ToTime, superClass);

    function ToTime(json) {
      ToTime.__super__.constructor.apply(this, arguments);
    }

    ToTime.prototype.exec = function(ctx) {
      var arg, dt;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        dt = DateTime.parse(arg.toString());
        if ((dt != null) && typeof dt !== 'undefined') {
          return dt.getTime();
        } else {
          return null;
        }
      } else {
        return null;
      }
    };

    return ToTime;

  })(Expression);

  module.exports.Convert = Convert = (function(superClass) {
    extend(Convert, superClass);

    function Convert(json) {
      Convert.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
      this.toType = json.toType;
    }

    Convert.prototype.exec = function(ctx) {
      switch (this.toType) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return new ToBoolean({
            "type": "ToBoolean",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Concept":
          return new ToConcept({
            "type": "ToConcept",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return new ToDecimal({
            "type": "ToDecimal",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Integer":
          return new ToInteger({
            "type": "ToInteger",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}String":
          return new ToString({
            "type": "ToString",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return new ToQuantity({
            "type": "ToQuantity",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}DateTime":
          return new ToDateTime({
            "type": "ToDateTime",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Time":
          return new ToTime({
            "type": "ToTime",
            "operand": this.operand
          }).execute(ctx);
        default:
          return this.execArgs(ctx);
      }
    };

    return Convert;

  })(Expression);

  module.exports.Is = Is = (function(superClass) {
    extend(Is, superClass);

    function Is() {
      return Is.__super__.constructor.apply(this, arguments);
    }

    return Is;

  })(UnimplementedExpression);

  module.exports.IntervalTypeSpecifier = IntervalTypeSpecifier = (function(superClass) {
    extend(IntervalTypeSpecifier, superClass);

    function IntervalTypeSpecifier() {
      return IntervalTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return IntervalTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.ListTypeSpecifier = ListTypeSpecifier = (function(superClass) {
    extend(ListTypeSpecifier, superClass);

    function ListTypeSpecifier() {
      return ListTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return ListTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.NamedTypeSpecifier = NamedTypeSpecifier = (function(superClass) {
    extend(NamedTypeSpecifier, superClass);

    function NamedTypeSpecifier() {
      return NamedTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return NamedTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.TupleTypeSpecifier = TupleTypeSpecifier = (function(superClass) {
    extend(TupleTypeSpecifier, superClass);

    function TupleTypeSpecifier() {
      return TupleTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return TupleTypeSpecifier;

  })(UnimplementedExpression);

}).call(this);



},{"../datatypes/datetime":7,"./expression":20,"./quantity":32,"./reusable":34}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  window.cql = require('../../cql');

  window.executeSimpleELM = function(elm, patientSource, valueSets, libraryName, version, parameters) {
    var codeService, executor, lib, rep;
    if (parameters == null) {
      parameters = {};
    }
    if (Array.isArray(elm)) {
      if (elm.length > 1) {
        rep = new cql.Repository(elm);
        lib = rep.resolve(libraryName, version);
      } else {
        lib = new cql.Library(elm[0]);
      }
    } else {
      lib = new cql.Library(elm);
    }
    codeService = new cql.CodeService(valueSets);
    executor = new cql.Executor(lib, codeService, parameters);
    return executor.exec(patientSource);
  };

}).call(this);



},{"../../cql":4}],39:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Alert, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Prospective warnings of potential issues when providing care to the patient.
  @class Alert
  @exports Alert as Alert
   */

  Alert = (function(superClass) {
    extend(Alert, superClass);

    function Alert(json) {
      this.json = json;
      Alert.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned to the alert for external use (outside the FHIR environment).
    @returns {Array} an array of {@link Identifier} objects
     */

    Alert.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Allows an alert to be divided into different categories like clinical, administrative etc.
    @returns {CodeableConcept}
     */

    Alert.prototype.category = function() {
      if (this.json['category']) {
        return new CodeableConcept(this.json['category']);
      }
    };


    /**
    Supports basic workflow.
    @returns {Array} an array of {@link String} objects
     */

    Alert.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The person who this alert concerns.
    @returns {Reference}
     */

    Alert.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The person or device that created the alert.
    @returns {Reference}
     */

    Alert.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    The textual component of the alert to display to the user.
    @returns {Array} an array of {@link String} objects
     */

    Alert.prototype.note = function() {
      return this.json['note'];
    };

    return Alert;

  })(DomainResource);

  module.exports.Alert = Alert;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],40:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, AllergyIntolerance, AllergyIntoleranceEventComponent, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class AllergyIntoleranceEventComponent
  @exports  AllergyIntoleranceEventComponent as AllergyIntoleranceEventComponent
   */

  AllergyIntoleranceEventComponent = (function(superClass) {
    extend(AllergyIntoleranceEventComponent, superClass);

    function AllergyIntoleranceEventComponent(json) {
      this.json = json;
      AllergyIntoleranceEventComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identification of the specific substance considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different to the substance identified as the cause of the risk, but must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite substance that includes the identified substance. It must be clinically safe to only process the AllergyIntolerance.substance and ignore the AllergyIntolerance.event.substance.
    @returns {CodeableConcept}
     */

    AllergyIntoleranceEventComponent.prototype.substance = function() {
      if (this.json['substance']) {
        return new CodeableConcept(this.json['substance']);
      }
    };


    /**
    Statement about the degree of clinical certainty that the Specific Substance was the cause of the Manifestation in this reaction event.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntoleranceEventComponent.prototype.certainty = function() {
      return this.json['certainty'];
    };


    /**
    Clinical symptoms and/or signs that are observed or associated with the Adverse Reaction Event.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    AllergyIntoleranceEventComponent.prototype.manifestation = function() {
      var i, item, len, ref, results;
      if (this.json['manifestation']) {
        ref = this.json['manifestation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Text description about the Reaction as a whole, including details of the manifestation if required.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntoleranceEventComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Record of the date and/or time of the onset of the Reaction.
    @returns {Array} an array of {@link Date} objects
     */

    AllergyIntoleranceEventComponent.prototype.onset = function() {
      if (this.json['onset']) {
        return DT.DateTime.parse(this.json['onset']);
      }
    };


    /**
    The amount of time that the Adverse Reaction persisted.
    @returns {Duration}
     */

    AllergyIntoleranceEventComponent.prototype.duration = function() {
      if (this.json['duration']) {
        return new Duration(this.json['duration']);
      }
    };


    /**
    Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntoleranceEventComponent.prototype.severity = function() {
      return this.json['severity'];
    };


    /**
    Identification of the route by which the subject was exposed to the substance.
    @returns {CodeableConcept}
     */

    AllergyIntoleranceEventComponent.prototype.exposureRoute = function() {
      if (this.json['exposureRoute']) {
        return new CodeableConcept(this.json['exposureRoute']);
      }
    };


    /**
    Additional text about the Adverse Reaction event not captured in other fields.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntoleranceEventComponent.prototype.comment = function() {
      return this.json['comment'];
    };

    return AllergyIntoleranceEventComponent;

  })(BackboneElement);


  /**
  Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
  @class AllergyIntolerance
  @exports AllergyIntolerance as AllergyIntolerance
   */

  AllergyIntolerance = (function(superClass) {
    extend(AllergyIntolerance, superClass);

    function AllergyIntolerance(json) {
      this.json = json;
      AllergyIntolerance.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this allergy/intolerance concern that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    AllergyIntolerance.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Date when the sensitivity was recorded.
    @returns {Array} an array of {@link Date} objects
     */

    AllergyIntolerance.prototype.recordedDate = function() {
      if (this.json['recordedDate']) {
        return DT.DateTime.parse(this.json['recordedDate']);
      }
    };


    /**
    Indicates who has responsibility for the record.
    @returns {Reference}
     */

    AllergyIntolerance.prototype.recorder = function() {
      if (this.json['recorder']) {
        return new Reference(this.json['recorder']);
      }
    };


    /**
    The patient who has the allergy or intolerance.
    @returns {Reference}
     */

    AllergyIntolerance.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Identification of a substance, or a class of substances, that is considered to be responsible for the Adverse reaction risk.
    @returns {CodeableConcept}
     */

    AllergyIntolerance.prototype.substance = function() {
      if (this.json['substance']) {
        return new CodeableConcept(this.json['substance']);
      }
    };


    /**
    Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified Substance.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntolerance.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Estimate of the potential clinical harm, or seriousness, of the reaction to the identified Substance.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntolerance.prototype.criticality = function() {
      return this.json['criticality'];
    };


    /**
    Identification of the underlying physiological mechanism for the Reaction Risk.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntolerance.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Category of the identified Substance.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntolerance.prototype.category = function() {
      return this.json['category'];
    };


    /**
    Represents the date and/or time of the last known occurence of a reaction event.
    @returns {Array} an array of {@link Date} objects
     */

    AllergyIntolerance.prototype.lastOccurence = function() {
      if (this.json['lastOccurence']) {
        return DT.DateTime.parse(this.json['lastOccurence']);
      }
    };


    /**
    Additional narrative about the propensity for the Adverse Reaction, not captured in other fields.
    @returns {Array} an array of {@link String} objects
     */

    AllergyIntolerance.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    Details about each Adverse Reaction Event linked to exposure to the identified Substance.
    @returns {Array} an array of {@link AllergyIntoleranceEventComponent} objects
     */

    AllergyIntolerance.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AllergyIntoleranceEventComponent(item));
        }
        return results;
      }
    };

    return AllergyIntolerance;

  })(DomainResource);

  module.exports.AllergyIntolerance = AllergyIntolerance;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],41:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Appointment, AppointmentParticipantComponent, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class AppointmentParticipantComponent
  @exports  AppointmentParticipantComponent as AppointmentParticipantComponent
   */

  AppointmentParticipantComponent = (function(superClass) {
    extend(AppointmentParticipantComponent, superClass);

    function AppointmentParticipantComponent(json) {
      this.json = json;
      AppointmentParticipantComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Role of participant in the appointment.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    AppointmentParticipantComponent.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A Person of device that is participating in the appointment, usually Practitioner, Patient, RelatedPerson or Device.
    @returns {Reference}
     */

    AppointmentParticipantComponent.prototype.actor = function() {
      if (this.json['actor']) {
        return new Reference(this.json['actor']);
      }
    };


    /**
    Is this participant required to be present at the meeting. This covers a use-case where 2 doctors need to meet to discuss the results for a specific patient, and the patient is not required to be present.
    @returns {Array} an array of {@link String} objects
     */

    AppointmentParticipantComponent.prototype.required = function() {
      return this.json['required'];
    };


    /**
    Participation status of the Patient.
    @returns {Array} an array of {@link String} objects
     */

    AppointmentParticipantComponent.prototype.status = function() {
      return this.json['status'];
    };

    return AppointmentParticipantComponent;

  })(BackboneElement);


  /**
  A scheduled healthcare event for a patient and/or practitioner(s) where a service may take place at a specific date/time.
  @class Appointment
  @exports Appointment as Appointment
   */

  Appointment = (function(superClass) {
    extend(Appointment, superClass);

    function Appointment(json) {
      this.json = json;
      Appointment.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this appointment concern that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    Appointment.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority) (Need to change back to CodeableConcept).
    @returns {Array} an array of {@link Number} objects
     */

    Appointment.prototype.priority = function() {
      return this.json['priority'];
    };


    /**
    Each of the participants has their own participation status which indicates their involvement in the process, however this status indicates the shared status.
    @returns {Array} an array of {@link String} objects
     */

    Appointment.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The type of appointments that is being booked (ideally this would be an identifiable service - which is at a location, rather than the location itself).
    @returns {CodeableConcept}
     */

    Appointment.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The reason that this appointment is being scheduled, this is more clinical than administrative.
    @returns {CodeableConcept}
     */

    Appointment.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };


    /**
    The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    @returns {Array} an array of {@link String} objects
     */

    Appointment.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Date/Time that the appointment is to take place.
    @returns {Array} an array of {@link Date} objects
     */

    Appointment.prototype.start = function() {
      if (this.json['start']) {
        return DT.DateTime.parse(this.json['start']);
      }
    };


    /**
    Date/Time that the appointment is to conclude.
    @returns {Array} an array of {@link Date} objects
     */

    Appointment.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };


    /**
    The slot that this appointment is filling. If provided then the schedule will not be provided as slots are not recursive, and the start/end values MUST be the same as from the slot.
    @returns {Array} an array of {@link Reference} objects
     */

    Appointment.prototype.slot = function() {
      var i, item, len, ref, results;
      if (this.json['slot']) {
        ref = this.json['slot'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The primary location that this appointment is to take place.
    @returns {Reference}
     */

    Appointment.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Additional comments about the appointment.
    @returns {Array} an array of {@link String} objects
     */

    Appointment.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    An Order that lead to the creation of this appointment.
    @returns {Reference}
     */

    Appointment.prototype.order = function() {
      if (this.json['order']) {
        return new Reference(this.json['order']);
      }
    };


    /**
    List of participants involved in the appointment.
    @returns {Array} an array of {@link AppointmentParticipantComponent} objects
     */

    Appointment.prototype.participant = function() {
      var i, item, len, ref, results;
      if (this.json['participant']) {
        ref = this.json['participant'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AppointmentParticipantComponent(item));
        }
        return results;
      }
    };


    /**
    Who recorded the appointment.
    @returns {Reference}
     */

    Appointment.prototype.lastModifiedBy = function() {
      if (this.json['lastModifiedBy']) {
        return new Reference(this.json['lastModifiedBy']);
      }
    };


    /**
    Date when the appointment was recorded.
    @returns {Array} an array of {@link Date} objects
     */

    Appointment.prototype.lastModified = function() {
      if (this.json['lastModified']) {
        return DT.DateTime.parse(this.json['lastModified']);
      }
    };

    return Appointment;

  })(DomainResource);

  module.exports.Appointment = Appointment;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],42:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, AppointmentResponse, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.
  @class AppointmentResponse
  @exports AppointmentResponse as AppointmentResponse
   */

  AppointmentResponse = (function(superClass) {
    extend(AppointmentResponse, superClass);

    function AppointmentResponse(json) {
      this.json = json;
      AppointmentResponse.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this appointment concern that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    AppointmentResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Parent appointment that this response is replying to.
    @returns {Reference}
     */

    AppointmentResponse.prototype.appointment = function() {
      if (this.json['appointment']) {
        return new Reference(this.json['appointment']);
      }
    };


    /**
    Role of participant in the appointment.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    AppointmentResponse.prototype.participantType = function() {
      var i, item, len, ref, results;
      if (this.json['participantType']) {
        ref = this.json['participantType'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A Person of device that is participating in the appointment, usually Practitioner, Patient, RelatedPerson or Device.
    @returns {Array} an array of {@link Reference} objects
     */

    AppointmentResponse.prototype.individual = function() {
      var i, item, len, ref, results;
      if (this.json['individual']) {
        ref = this.json['individual'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Participation status of the Patient.
    @returns {Array} an array of {@link String} objects
     */

    AppointmentResponse.prototype.participantStatus = function() {
      return this.json['participantStatus'];
    };


    /**
    Additional comments about the appointment.
    @returns {Array} an array of {@link String} objects
     */

    AppointmentResponse.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    Date/Time that the appointment is to take place.
    @returns {Array} an array of {@link Date} objects
     */

    AppointmentResponse.prototype.start = function() {
      if (this.json['start']) {
        return DT.DateTime.parse(this.json['start']);
      }
    };


    /**
    Date/Time that the appointment is to conclude.
    @returns {Array} an array of {@link Date} objects
     */

    AppointmentResponse.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };


    /**
    Who recorded the appointment response.
    @returns {Reference}
     */

    AppointmentResponse.prototype.lastModifiedBy = function() {
      if (this.json['lastModifiedBy']) {
        return new Reference(this.json['lastModifiedBy']);
      }
    };


    /**
    Date when the response was recorded or last updated.
    @returns {Array} an array of {@link Date} objects
     */

    AppointmentResponse.prototype.lastModified = function() {
      if (this.json['lastModified']) {
        return DT.DateTime.parse(this.json['lastModified']);
      }
    };

    return AppointmentResponse;

  })(DomainResource);

  module.exports.AppointmentResponse = AppointmentResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],43:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, Availability, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  (informative) A container for slot(s) of time that may be available for booking appointments.
  @class Availability
  @exports Availability as Availability
   */

  Availability = (function(superClass) {
    extend(Availability, superClass);

    function Availability(json) {
      this.json = json;
      Availability.__super__.constructor.call(this, this.json);
    }


    /**
    External Ids for this item.
    @returns {Array} an array of {@link Identifier} objects
     */

    Availability.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The schedule type can be used for the categorization of healthcare services or other appointment types.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Availability.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The resource this availability resource is providing availability information for. These are expected to usually be one of HealthcareService, Location, Practitioner, Device, Patient or RelatedPerson.
    @returns {Reference}
     */

    Availability.prototype.actor = function() {
      if (this.json['actor']) {
        return new Reference(this.json['actor']);
      }
    };


    /**
    The period of time that the slots that are attached to this availability resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    @returns {Period}
     */

    Availability.prototype.planningHorizon = function() {
      if (this.json['planningHorizon']) {
        return new Period(this.json['planningHorizon']);
      }
    };


    /**
    Comments on the availability to describe any extended information. Such as custom constraints on the slot(s) that may be associated.
    @returns {Array} an array of {@link String} objects
     */

    Availability.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    When this availability was created, or last revised.
    @returns {Array} an array of {@link Date} objects
     */

    Availability.prototype.lastModified = function() {
      if (this.json['lastModified']) {
        return DT.DateTime.parse(this.json['lastModified']);
      }
    };

    return Availability;

  })(DomainResource);

  module.exports.Availability = Availability;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],44:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, Basic, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.
  @class Basic
  @exports Basic as Basic
   */

  Basic = (function(superClass) {
    extend(Basic, superClass);

    function Basic(json) {
      this.json = json;
      Basic.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned to the resource for business purposes, outside the context of FHIR.
    @returns {Array} an array of {@link Identifier} objects
     */

    Basic.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Identifies the 'type' of resource - equivalent to the resource name for other resources.
    @returns {CodeableConcept}
     */

    Basic.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Identifies the patient, practitioner, device or any other resource that is the "focus" of this resoruce.
    @returns {Reference}
     */

    Basic.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Indicates who was responsible for creating the resource instance.
    @returns {Reference}
     */

    Basic.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    Identifies when the resource was first created.
    @returns {Array} an array of {@link Date} objects
     */

    Basic.prototype.created = function() {
      if (this.json['created']) {
        return DT.DateTime.parse(this.json['created']);
      }
    };

    return Basic;

  })(DomainResource);

  module.exports.Basic = Basic;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],45:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, Binary, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  @class Binary
  @exports Binary as Binary
   */

  Binary = (function(superClass) {
    extend(Binary, superClass);

    function Binary(json) {
      this.json = json;
      Binary.__super__.constructor.call(this, this.json);
    }


    /**
    MimeType of the binary content represented as a standard MimeType (BCP 13).
    @returns {Array} an array of {@link String} objects
     */

    Binary.prototype.contentType = function() {
      return this.json['contentType'];
    };


    /**
    The actual content, base64 encoded.
    @returns {Array} an array of {@link } objects
     */

    Binary.prototype.content = function() {
      return this.json['content'];
    };

    return Binary;

  })(Resource);

  module.exports.Binary = Binary;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],46:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, Bundle, BundleEntryComponent, BundleEntryDeletedComponent, BundleLinkComponent, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class BundleLinkComponent
  @exports  BundleLinkComponent as BundleLinkComponent
   */

  BundleLinkComponent = (function(superClass) {
    extend(BundleLinkComponent, superClass);

    function BundleLinkComponent(json) {
      this.json = json;
      BundleLinkComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A name which details the functional use for this link - see [[http://www.iana.org/assignments/link-relations/link-relations.xhtml]].
    @returns {Array} an array of {@link String} objects
     */

    BundleLinkComponent.prototype.relation = function() {
      return this.json['relation'];
    };


    /**
    The reference details for the link.
    @returns {Array} an array of {@link String} objects
     */

    BundleLinkComponent.prototype.url = function() {
      return this.json['url'];
    };

    return BundleLinkComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class BundleEntryDeletedComponent
  @exports  BundleEntryDeletedComponent as BundleEntryDeletedComponent
   */

  BundleEntryDeletedComponent = (function(superClass) {
    extend(BundleEntryDeletedComponent, superClass);

    function BundleEntryDeletedComponent(json) {
      this.json = json;
      BundleEntryDeletedComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The type of resource that was deleted (required to construct the identity).
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryDeletedComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The id of the resource that was deleted.
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryDeletedComponent.prototype.id = function() {
      return this.json['id'];
    };


    /**
    Version id for releted resource.
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryDeletedComponent.prototype.versionId = function() {
      return this.json['versionId'];
    };


    /**
    The date/time that the resource was deleted.
    @returns {Array} an array of {@link Date} objects
     */

    BundleEntryDeletedComponent.prototype.instant = function() {
      if (this.json['instant']) {
        return DT.DateTime.parse(this.json['instant']);
      }
    };

    return BundleEntryDeletedComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class BundleEntryComponent
  @exports  BundleEntryComponent as BundleEntryComponent
   */

  BundleEntryComponent = (function(superClass) {
    extend(BundleEntryComponent, superClass);

    function BundleEntryComponent(json) {
      this.json = json;
      BundleEntryComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The Base URL for the resource, if different to the base URL specified for the bundle as a whole.
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryComponent.prototype.base = function() {
      return this.json['base'];
    };


    /**
    The status of a resource in the bundle. Used for search (to differentiate between resources included as a match, and resources included as an _include), for history (deleted resources), and for transactions (create/update/delete).
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Search URL for this resource when processing a transaction (see transaction documentation).
    @returns {Array} an array of {@link String} objects
     */

    BundleEntryComponent.prototype.search = function() {
      return this.json['search'];
    };


    /**
    When searching, the server's search ranking score for the entry.
    @returns {Array} an array of {@link Number} objects
     */

    BundleEntryComponent.prototype.score = function() {
      return this.json['score'];
    };


    /**
    If this is an entry that represents a deleted resource. Only used when the bundle is a transaction or a history type. See RESTful API documentation for further informatino.
    @returns {BundleEntryDeletedComponent}
     */

    BundleEntryComponent.prototype.deleted = function() {
      if (this.json['deleted']) {
        return new BundleEntryDeletedComponent(this.json['deleted']);
      }
    };


    /**
    The Resources for the entry.
    @returns {Resource}
     */

    BundleEntryComponent.prototype.resource = function() {
      var req, typeName;
      if (this.json['resource']) {
        typeName = this.json['resource'].resourceType;
        req = require('./' + typeName.toLowerCase())[typeName];
        return new req(this.json['resource']);
      }
    };

    return BundleEntryComponent;

  })(BackboneElement);


  /**
  A container for a group of resources.
  @class Bundle
  @exports Bundle as Bundle
   */

  Bundle = (function(superClass) {
    extend(Bundle, superClass);

    function Bundle(json) {
      this.json = json;
      Bundle.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the purpose of this bundle- how it was intended to be used.
    @returns {Array} an array of {@link String} objects
     */

    Bundle.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The base URL for the service that provided these resources. All relative URLs are relative to this one (equivalent to xml:base).
    @returns {Array} an array of {@link String} objects
     */

    Bundle.prototype.base = function() {
      return this.json['base'];
    };


    /**
    If a set of search matches, this is the total number of matches for the search (as opposed to the number of results in this bundle).
    @returns {Array} an array of {@link Number} objects
     */

    Bundle.prototype.total = function() {
      return this.json['total'];
    };


    /**
    A series of links that provide context to this bundle.
    @returns {Array} an array of {@link BundleLinkComponent} objects
     */

    Bundle.prototype.link = function() {
      var i, item, len, ref, results;
      if (this.json['link']) {
        ref = this.json['link'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new BundleLinkComponent(item));
        }
        return results;
      }
    };


    /**
    An entry in a bundle resource - will either contain a resource, or a deleted entry (transaction and history bundles only).
    @returns {Array} an array of {@link BundleEntryComponent} objects
     */

    Bundle.prototype.entry = function() {
      var i, item, len, ref, results;
      if (this.json['entry']) {
        ref = this.json['entry'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new BundleEntryComponent(item));
        }
        return results;
      }
    };


    /**
    XML Digital Signature - base64 encoded.
    @returns {Array} an array of {@link } objects
     */

    Bundle.prototype.signature = function() {
      return this.json['signature'];
    };

    return Bundle;

  })(Resource);

  module.exports.Bundle = Bundle;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],47:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CarePlan, CarePlanActivityComponent, CarePlanActivitySimpleComponent, CarePlanGoalComponent, CarePlanParticipantComponent, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class CarePlanParticipantComponent
  @exports  CarePlanParticipantComponent as CarePlanParticipantComponent
   */

  CarePlanParticipantComponent = (function(superClass) {
    extend(CarePlanParticipantComponent, superClass);

    function CarePlanParticipantComponent(json) {
      this.json = json;
      CarePlanParticipantComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates specific responsibility of an individual within the care plan.  E.g. "Primary physician", "Team coordinator", "Caregiver", etc.
    @returns {CodeableConcept}
     */

    CarePlanParticipantComponent.prototype.role = function() {
      if (this.json['role']) {
        return new CodeableConcept(this.json['role']);
      }
    };


    /**
    The specific person or organization who is participating/expected to participate in the care plan.
    @returns {Reference}
     */

    CarePlanParticipantComponent.prototype.member = function() {
      if (this.json['member']) {
        return new Reference(this.json['member']);
      }
    };

    return CarePlanParticipantComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class CarePlanGoalComponent
  @exports  CarePlanGoalComponent as CarePlanGoalComponent
   */

  CarePlanGoalComponent = (function(superClass) {
    extend(CarePlanGoalComponent, superClass);

    function CarePlanGoalComponent(json) {
      this.json = json;
      CarePlanGoalComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Human-readable description of a specific desired objective of the care plan.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanGoalComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Indicates whether the goal has been reached and is still considered relevant.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanGoalComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Any comments related to the goal.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanGoalComponent.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    The identified conditions that this goal relates to - the condition that caused it to be created, or that it is intended to address.
    @returns {Array} an array of {@link Reference} objects
     */

    CarePlanGoalComponent.prototype.concern = function() {
      var i, item, len, ref, results;
      if (this.json['concern']) {
        ref = this.json['concern'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return CarePlanGoalComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class CarePlanActivitySimpleComponent
  @exports  CarePlanActivitySimpleComponent as CarePlanActivitySimpleComponent
   */

  CarePlanActivitySimpleComponent = (function(superClass) {
    extend(CarePlanActivitySimpleComponent, superClass);

    function CarePlanActivitySimpleComponent(json) {
      this.json = json;
      CarePlanActivitySimpleComponent.__super__.constructor.call(this, this.json);
    }


    /**
    High-level categorization of the type of activity in a care plan.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivitySimpleComponent.prototype.category = function() {
      return this.json['category'];
    };


    /**
    Detailed description of the type of activity.  E.g. What lab test, what procedure, what kind of encounter.
    @returns {CodeableConcept}
     */

    CarePlanActivitySimpleComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    The period, timing or frequency upon which the described activity is to occur.
    @returns {Timing}
     */

    CarePlanActivitySimpleComponent.prototype.scheduledTiming = function() {
      if (this.json['scheduledTiming']) {
        return new Timing(this.json['scheduledTiming']);
      }
    };


    /**
    The period, timing or frequency upon which the described activity is to occur.
    @returns {Period}
     */

    CarePlanActivitySimpleComponent.prototype.scheduledPeriod = function() {
      if (this.json['scheduledPeriod']) {
        return new Period(this.json['scheduledPeriod']);
      }
    };


    /**
    The period, timing or frequency upon which the described activity is to occur.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivitySimpleComponent.prototype.scheduledString = function() {
      return this.json['scheduledString'];
    };


    /**
    Identifies the facility where the activity will occur.  E.g. home, hospital, specific clinic, etc.
    @returns {Reference}
     */

    CarePlanActivitySimpleComponent.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Identifies who's expected to be involved in the activity.
    @returns {Array} an array of {@link Reference} objects
     */

    CarePlanActivitySimpleComponent.prototype.performer = function() {
      var i, item, len, ref, results;
      if (this.json['performer']) {
        ref = this.json['performer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Identifies the food, drug or other product being consumed or supplied in the activity.
    @returns {Reference}
     */

    CarePlanActivitySimpleComponent.prototype.product = function() {
      if (this.json['product']) {
        return new Reference(this.json['product']);
      }
    };


    /**
    Identifies the quantity expected to be consumed in a given day.
    @returns {Quantity}
     */

    CarePlanActivitySimpleComponent.prototype.dailyAmount = function() {
      if (this.json['dailyAmount']) {
        return new Quantity(this.json['dailyAmount']);
      }
    };


    /**
    Identifies the quantity expected to be supplied.
    @returns {Quantity}
     */

    CarePlanActivitySimpleComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivitySimpleComponent.prototype.details = function() {
      return this.json['details'];
    };

    return CarePlanActivitySimpleComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class CarePlanActivityComponent
  @exports  CarePlanActivityComponent as CarePlanActivityComponent
   */

  CarePlanActivityComponent = (function(superClass) {
    extend(CarePlanActivityComponent, superClass);

    function CarePlanActivityComponent(json) {
      this.json = json;
      CarePlanActivityComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivityComponent.prototype.goal = function() {
      return this.json['goal'];
    };


    /**
    Identifies what progress is being made for the specific activity.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivityComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    @returns {Array} an array of {@link boolean} objects
     */

    CarePlanActivityComponent.prototype.prohibited = function() {
      return this.json['prohibited'];
    };


    /**
    Resources that describe follow-on actions resulting from the plan, such as drug prescriptions, encounter records, appointments, etc.
    @returns {Array} an array of {@link Reference} objects
     */

    CarePlanActivityComponent.prototype.actionResulting = function() {
      var i, item, len, ref, results;
      if (this.json['actionResulting']) {
        ref = this.json['actionResulting'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Notes about the execution of the activity.
    @returns {Array} an array of {@link String} objects
     */

    CarePlanActivityComponent.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    The details of the proposed activity represented in a specific resource.
    @returns {Reference}
     */

    CarePlanActivityComponent.prototype.detail = function() {
      if (this.json['detail']) {
        return new Reference(this.json['detail']);
      }
    };


    /**
    A simple summary of details suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    @returns {CarePlanActivitySimpleComponent}
     */

    CarePlanActivityComponent.prototype.simple = function() {
      if (this.json['simple']) {
        return new CarePlanActivitySimpleComponent(this.json['simple']);
      }
    };

    return CarePlanActivityComponent;

  })(BackboneElement);


  /**
  Describes the intention of how one or more practitioners intend to deliver care for a particular patient for a period of time, possibly limited to care for a specific condition or set of conditions.
  @class CarePlan
  @exports CarePlan as CarePlan
   */

  CarePlan = (function(superClass) {
    extend(CarePlan, superClass);

    function CarePlan(json) {
      this.json = json;
      CarePlan.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this care plan that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    CarePlan.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Identifies the patient/subject whose intended care is described by the plan.
    @returns {Reference}
     */

    CarePlan.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Indicates whether the plan is currently being acted upon, represents future intentions or is now just historical record.
    @returns {Array} an array of {@link String} objects
     */

    CarePlan.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Indicates when the plan did (or is intended to) come into effect and end.
    @returns {Period}
     */

    CarePlan.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Identifies the most recent date on which the plan has been revised.
    @returns {Array} an array of {@link Date} objects
     */

    CarePlan.prototype.modified = function() {
      if (this.json['modified']) {
        return DT.DateTime.parse(this.json['modified']);
      }
    };


    /**
    Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan.
    @returns {Array} an array of {@link Reference} objects
     */

    CarePlan.prototype.concern = function() {
      var i, item, len, ref, results;
      if (this.json['concern']) {
        ref = this.json['concern'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
    @returns {Array} an array of {@link CarePlanParticipantComponent} objects
     */

    CarePlan.prototype.participant = function() {
      var i, item, len, ref, results;
      if (this.json['participant']) {
        ref = this.json['participant'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CarePlanParticipantComponent(item));
        }
        return results;
      }
    };


    /**
    Describes the intended objective(s) of carrying out the Care Plan.
    @returns {Array} an array of {@link CarePlanGoalComponent} objects
     */

    CarePlan.prototype.goal = function() {
      var i, item, len, ref, results;
      if (this.json['goal']) {
        ref = this.json['goal'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CarePlanGoalComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
    @returns {Array} an array of {@link CarePlanActivityComponent} objects
     */

    CarePlan.prototype.activity = function() {
      var i, item, len, ref, results;
      if (this.json['activity']) {
        ref = this.json['activity'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CarePlanActivityComponent(item));
        }
        return results;
      }
    };


    /**
    General notes about the care plan not covered elsewhere.
    @returns {Array} an array of {@link String} objects
     */

    CarePlan.prototype.notes = function() {
      return this.json['notes'];
    };

    return CarePlan;

  })(DomainResource);

  module.exports.CarePlan = CarePlan;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],48:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var AddedItemAdjudicationComponent, AddedItemComponent, AddedItemDetailAdjudicationComponent, AddedItemsDetailComponent, Address, Attachment, BackboneElement, CORE, ClaimResponse, CodeableConcept, Coding, ContactPoint, DT, DetailAdjudicationComponent, DomainResource, Element, ElementDefinition, ErrorsComponent, Extension, HumanName, Identifier, ItemAdjudicationComponent, ItemDetailComponent, ItemSubdetailComponent, ItemsComponent, Narrative, NotesComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SubdetailAdjudicationComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ItemAdjudicationComponent
  @exports  ItemAdjudicationComponent as ItemAdjudicationComponent
   */

  ItemAdjudicationComponent = (function(superClass) {
    extend(ItemAdjudicationComponent, superClass);

    function ItemAdjudicationComponent(json) {
      this.json = json;
      ItemAdjudicationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    @returns {Coding}
     */

    ItemAdjudicationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    Monitory amount associated with the code.
    @returns {Money}
     */

    ItemAdjudicationComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };


    /**
    A non-monitary value for example a percentage. Mutually exclusive to the amount element above.
    @returns {Array} an array of {@link Number} objects
     */

    ItemAdjudicationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return ItemAdjudicationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DetailAdjudicationComponent
  @exports  DetailAdjudicationComponent as DetailAdjudicationComponent
   */

  DetailAdjudicationComponent = (function(superClass) {
    extend(DetailAdjudicationComponent, superClass);

    function DetailAdjudicationComponent(json) {
      this.json = json;
      DetailAdjudicationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    @returns {Coding}
     */

    DetailAdjudicationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    Monitory amount associated with the code.
    @returns {Money}
     */

    DetailAdjudicationComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };


    /**
    A non-monitary value for example a percentage. Mutually exclusive to the amount element above.
    @returns {Array} an array of {@link Number} objects
     */

    DetailAdjudicationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return DetailAdjudicationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SubdetailAdjudicationComponent
  @exports  SubdetailAdjudicationComponent as SubdetailAdjudicationComponent
   */

  SubdetailAdjudicationComponent = (function(superClass) {
    extend(SubdetailAdjudicationComponent, superClass);

    function SubdetailAdjudicationComponent(json) {
      this.json = json;
      SubdetailAdjudicationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    @returns {Coding}
     */

    SubdetailAdjudicationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    Monitory amount associated with the code.
    @returns {Money}
     */

    SubdetailAdjudicationComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };


    /**
    A non-monitary value for example a percentage. Mutually exclusive to the amount element above.
    @returns {Array} an array of {@link Number} objects
     */

    SubdetailAdjudicationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return SubdetailAdjudicationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ItemSubdetailComponent
  @exports  ItemSubdetailComponent as ItemSubdetailComponent
   */

  ItemSubdetailComponent = (function(superClass) {
    extend(ItemSubdetailComponent, superClass);

    function ItemSubdetailComponent(json) {
      this.json = json;
      ItemSubdetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    ItemSubdetailComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };


    /**
    The adjudications results.
    @returns {Array} an array of {@link SubdetailAdjudicationComponent} objects
     */

    ItemSubdetailComponent.prototype.adjudication = function() {
      var i, item, len, ref, results;
      if (this.json['adjudication']) {
        ref = this.json['adjudication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SubdetailAdjudicationComponent(item));
        }
        return results;
      }
    };

    return ItemSubdetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ItemDetailComponent
  @exports  ItemDetailComponent as ItemDetailComponent
   */

  ItemDetailComponent = (function(superClass) {
    extend(ItemDetailComponent, superClass);

    function ItemDetailComponent(json) {
      this.json = json;
      ItemDetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    ItemDetailComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };


    /**
    The adjudications results.
    @returns {Array} an array of {@link DetailAdjudicationComponent} objects
     */

    ItemDetailComponent.prototype.adjudication = function() {
      var i, item, len, ref, results;
      if (this.json['adjudication']) {
        ref = this.json['adjudication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DetailAdjudicationComponent(item));
        }
        return results;
      }
    };


    /**
    The third tier service adjudications for submitted services.
    @returns {Array} an array of {@link ItemSubdetailComponent} objects
     */

    ItemDetailComponent.prototype.subdetail = function() {
      var i, item, len, ref, results;
      if (this.json['subdetail']) {
        ref = this.json['subdetail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemSubdetailComponent(item));
        }
        return results;
      }
    };

    return ItemDetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ItemsComponent
  @exports  ItemsComponent as ItemsComponent
   */

  ItemsComponent = (function(superClass) {
    extend(ItemsComponent, superClass);

    function ItemsComponent(json) {
      this.json = json;
      ItemsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };


    /**
    A list of note references to the notes provided below.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.noteNumber = function() {
      return this.json['noteNumber'];
    };


    /**
    The adjudications results.
    @returns {Array} an array of {@link ItemAdjudicationComponent} objects
     */

    ItemsComponent.prototype.adjudication = function() {
      var i, item, len, ref, results;
      if (this.json['adjudication']) {
        ref = this.json['adjudication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemAdjudicationComponent(item));
        }
        return results;
      }
    };


    /**
    The second tier service adjudications for submitted services.
    @returns {Array} an array of {@link ItemDetailComponent} objects
     */

    ItemsComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemDetailComponent(item));
        }
        return results;
      }
    };

    return ItemsComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class AddedItemAdjudicationComponent
  @exports  AddedItemAdjudicationComponent as AddedItemAdjudicationComponent
   */

  AddedItemAdjudicationComponent = (function(superClass) {
    extend(AddedItemAdjudicationComponent, superClass);

    function AddedItemAdjudicationComponent(json) {
      this.json = json;
      AddedItemAdjudicationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    @returns {Coding}
     */

    AddedItemAdjudicationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    Monitory amount associated with the code.
    @returns {Money}
     */

    AddedItemAdjudicationComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };


    /**
    A non-monitary value for example a percentage. Mutually exclusive to the amount element above.
    @returns {Array} an array of {@link Number} objects
     */

    AddedItemAdjudicationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return AddedItemAdjudicationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class AddedItemDetailAdjudicationComponent
  @exports  AddedItemDetailAdjudicationComponent as AddedItemDetailAdjudicationComponent
   */

  AddedItemDetailAdjudicationComponent = (function(superClass) {
    extend(AddedItemDetailAdjudicationComponent, superClass);

    function AddedItemDetailAdjudicationComponent(json) {
      this.json = json;
      AddedItemDetailAdjudicationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    @returns {Coding}
     */

    AddedItemDetailAdjudicationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    Monitory amount associated with the code.
    @returns {Money}
     */

    AddedItemDetailAdjudicationComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };


    /**
    A non-monitary value for example a percentage. Mutually exclusive to the amount element above.
    @returns {Array} an array of {@link Number} objects
     */

    AddedItemDetailAdjudicationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return AddedItemDetailAdjudicationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class AddedItemsDetailComponent
  @exports  AddedItemsDetailComponent as AddedItemsDetailComponent
   */

  AddedItemsDetailComponent = (function(superClass) {
    extend(AddedItemsDetailComponent, superClass);

    function AddedItemsDetailComponent(json) {
      this.json = json;
      AddedItemsDetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code to indicate the Professional Service or Product supplied.
    @returns {Coding}
     */

    AddedItemsDetailComponent.prototype.service = function() {
      if (this.json['service']) {
        return new Coding(this.json['service']);
      }
    };


    /**
    The fee charged for the professional service or product..
    @returns {Money}
     */

    AddedItemsDetailComponent.prototype.fee = function() {
      if (this.json['fee']) {
        return new Money(this.json['fee']);
      }
    };


    /**
    The adjudications results.
    @returns {Array} an array of {@link AddedItemDetailAdjudicationComponent} objects
     */

    AddedItemsDetailComponent.prototype.adjudication = function() {
      var i, item, len, ref, results;
      if (this.json['adjudication']) {
        ref = this.json['adjudication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AddedItemDetailAdjudicationComponent(item));
        }
        return results;
      }
    };

    return AddedItemsDetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class AddedItemComponent
  @exports  AddedItemComponent as AddedItemComponent
   */

  AddedItemComponent = (function(superClass) {
    extend(AddedItemComponent, superClass);

    function AddedItemComponent(json) {
      this.json = json;
      AddedItemComponent.__super__.constructor.call(this, this.json);
    }


    /**
    List of input service items which this service line is intended to replace.
    @returns {Array} an array of {@link Number} objects
     */

    AddedItemComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };


    /**
    A code to indicate the Professional Service or Product supplied.
    @returns {Coding}
     */

    AddedItemComponent.prototype.service = function() {
      if (this.json['service']) {
        return new Coding(this.json['service']);
      }
    };


    /**
    The fee charged for the professional service or product..
    @returns {Money}
     */

    AddedItemComponent.prototype.fee = function() {
      if (this.json['fee']) {
        return new Money(this.json['fee']);
      }
    };


    /**
    A list of note references to the notes provided below.
    @returns {Array} an array of {@link Number} objects
     */

    AddedItemComponent.prototype.noteNumberLinkId = function() {
      return this.json['noteNumberLinkId'];
    };


    /**
    The adjudications results.
    @returns {Array} an array of {@link AddedItemAdjudicationComponent} objects
     */

    AddedItemComponent.prototype.adjudication = function() {
      var i, item, len, ref, results;
      if (this.json['adjudication']) {
        ref = this.json['adjudication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AddedItemAdjudicationComponent(item));
        }
        return results;
      }
    };


    /**
    The second tier service adjudications for payor added services.
    @returns {Array} an array of {@link AddedItemsDetailComponent} objects
     */

    AddedItemComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AddedItemsDetailComponent(item));
        }
        return results;
      }
    };

    return AddedItemComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ErrorsComponent
  @exports  ErrorsComponent as ErrorsComponent
   */

  ErrorsComponent = (function(superClass) {
    extend(ErrorsComponent, superClass);

    function ErrorsComponent(json) {
      this.json = json;
      ErrorsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The sequence number of the line item submitted which contains the error. This value is ommitted when the error is elsewhere.
    @returns {Array} an array of {@link Number} objects
     */

    ErrorsComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };


    /**
    The sequence number of the addition within the line item submitted which contains the error. This value is ommitted when the error is not related to an Addition.
    @returns {Array} an array of {@link Number} objects
     */

    ErrorsComponent.prototype.detailSequenceLinkId = function() {
      return this.json['detailSequenceLinkId'];
    };


    /**
    The sequence number of the addition within the line item submitted which contains the error. This value is ommitted when the error is not related to an Addition.
    @returns {Array} an array of {@link Number} objects
     */

    ErrorsComponent.prototype.subdetailSequenceLinkId = function() {
      return this.json['subdetailSequenceLinkId'];
    };


    /**
    An error code,froma specified code system, which details why the claim could not be adjudicated.
    @returns {Coding}
     */

    ErrorsComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };

    return ErrorsComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NotesComponent
  @exports  NotesComponent as NotesComponent
   */

  NotesComponent = (function(superClass) {
    extend(NotesComponent, superClass);

    function NotesComponent(json) {
      this.json = json;
      NotesComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An integer associated with each note which may be referred to from each service line item.
    @returns {Array} an array of {@link Number} objects
     */

    NotesComponent.prototype.number = function() {
      return this.json['number'];
    };


    /**
    The note purpose: Print/Display.
    @returns {Coding}
     */

    NotesComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The note text.
    @returns {Array} an array of {@link String} objects
     */

    NotesComponent.prototype.text = function() {
      return this.json['text'];
    };

    return NotesComponent;

  })(BackboneElement);


  /**
  This resource provides the adjudication details from the processing of a Claim resource.
  @class ClaimResponse
  @exports ClaimResponse as ClaimResponse
   */

  ClaimResponse = (function(superClass) {
    extend(ClaimResponse, superClass);

    function ClaimResponse(json) {
      this.json = json;
      ClaimResponse.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    ClaimResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    ClaimResponse.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    ClaimResponse.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    ClaimResponse.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    ClaimResponse.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    ClaimResponse.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    ClaimResponse.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    ClaimResponse.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };


    /**
    Transaction status: error, complete.
    @returns {Array} an array of {@link String} objects
     */

    ClaimResponse.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A description of the status of the adjudication.
    @returns {Array} an array of {@link String} objects
     */

    ClaimResponse.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    Party to be reimbursed: Subscriber, provider, other.
    @returns {Coding}
     */

    ClaimResponse.prototype.payeeType = function() {
      if (this.json['payeeType']) {
        return new Coding(this.json['payeeType']);
      }
    };


    /**
    The first tier service adjudications for submitted services.
    @returns {Array} an array of {@link ItemsComponent} objects
     */

    ClaimResponse.prototype.item = function() {
      var i, item, len, ref, results;
      if (this.json['item']) {
        ref = this.json['item'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemsComponent(item));
        }
        return results;
      }
    };


    /**
    The first tier service adjudications for payor added services.
    @returns {Array} an array of {@link AddedItemComponent} objects
     */

    ClaimResponse.prototype.additem = function() {
      var i, item, len, ref, results;
      if (this.json['additem']) {
        ref = this.json['additem'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new AddedItemComponent(item));
        }
        return results;
      }
    };


    /**
    Mutually exclusive with Services Provided (Item).
    @returns {Array} an array of {@link ErrorsComponent} objects
     */

    ClaimResponse.prototype.error = function() {
      var i, item, len, ref, results;
      if (this.json['error']) {
        ref = this.json['error'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ErrorsComponent(item));
        }
        return results;
      }
    };


    /**
    The total cost of the services reported.
    @returns {Money}
     */

    ClaimResponse.prototype.totalCost = function() {
      if (this.json['totalCost']) {
        return new Money(this.json['totalCost']);
      }
    };


    /**
    The amount of deductable applied which was not allocated to any particular service line.
    @returns {Money}
     */

    ClaimResponse.prototype.unallocDeductable = function() {
      if (this.json['unallocDeductable']) {
        return new Money(this.json['unallocDeductable']);
      }
    };


    /**
    Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductable).
    @returns {Money}
     */

    ClaimResponse.prototype.totalBenefit = function() {
      if (this.json['totalBenefit']) {
        return new Money(this.json['totalBenefit']);
      }
    };


    /**
    Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
    @returns {Money}
     */

    ClaimResponse.prototype.paymentAdjustment = function() {
      if (this.json['paymentAdjustment']) {
        return new Money(this.json['paymentAdjustment']);
      }
    };


    /**
    Reason for the payment adjustment.
    @returns {Coding}
     */

    ClaimResponse.prototype.paymentAdjustmentReason = function() {
      if (this.json['paymentAdjustmentReason']) {
        return new Coding(this.json['paymentAdjustmentReason']);
      }
    };


    /**
    Estimated payment data.
    @returns {Array} an array of {@link Date} objects
     */

    ClaimResponse.prototype.paymentDate = function() {
      if (this.json['paymentDate']) {
        return DT.DateTime.parse(this.json['paymentDate']);
      }
    };


    /**
    Payable less any payment adjustment.
    @returns {Money}
     */

    ClaimResponse.prototype.paymentAmount = function() {
      if (this.json['paymentAmount']) {
        return new Money(this.json['paymentAmount']);
      }
    };


    /**
    Payment identifer.
    @returns {Identifier}
     */

    ClaimResponse.prototype.paymentRef = function() {
      if (this.json['paymentRef']) {
        return new Identifier(this.json['paymentRef']);
      }
    };


    /**
    Status of funds reservation (For provider, for Patient, None).
    @returns {Coding}
     */

    ClaimResponse.prototype.reserved = function() {
      if (this.json['reserved']) {
        return new Coding(this.json['reserved']);
      }
    };


    /**
    The form to be used for printing the content.
    @returns {Coding}
     */

    ClaimResponse.prototype.form = function() {
      if (this.json['form']) {
        return new Coding(this.json['form']);
      }
    };


    /**
    Note text.
    @returns {Array} an array of {@link NotesComponent} objects
     */

    ClaimResponse.prototype.note = function() {
      var i, item, len, ref, results;
      if (this.json['note']) {
        ref = this.json['note'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NotesComponent(item));
        }
        return results;
      }
    };

    return ClaimResponse;

  })(DomainResource);

  module.exports.ClaimResponse = ClaimResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],49:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, CommunicationRequest, CommunicationRequestMessagePartComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class CommunicationRequestMessagePartComponent
  @exports  CommunicationRequestMessagePartComponent as CommunicationRequestMessagePartComponent
   */

  CommunicationRequestMessagePartComponent = (function(superClass) {
    extend(CommunicationRequestMessagePartComponent, superClass);

    function CommunicationRequestMessagePartComponent(json) {
      this.json = json;
      CommunicationRequestMessagePartComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An individual message part for multi-part messages.
    @returns {Array} an array of {@link String} objects
     */

    CommunicationRequestMessagePartComponent.prototype.contentString = function() {
      return this.json['contentString'];
    };


    /**
    An individual message part for multi-part messages.
    @returns {Attachment}
     */

    CommunicationRequestMessagePartComponent.prototype.contentAttachment = function() {
      if (this.json['contentAttachment']) {
        return new Attachment(this.json['contentAttachment']);
      }
    };


    /**
    An individual message part for multi-part messages.
    @returns {Reference}
     */

    CommunicationRequestMessagePartComponent.prototype.contentReference = function() {
      if (this.json['contentReference']) {
        return new Reference(this.json['contentReference']);
      }
    };

    return CommunicationRequestMessagePartComponent;

  })(BackboneElement);


  /**
  A request to convey information. E.g., the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
  @class CommunicationRequest
  @exports CommunicationRequest as CommunicationRequest
   */

  CommunicationRequest = (function(superClass) {
    extend(CommunicationRequest, superClass);

    function CommunicationRequest(json) {
      this.json = json;
      CommunicationRequest.__super__.constructor.call(this, this.json);
    }


    /**
    A unique ID of this request for reference purposes. It must be provided if user wants it returned as part of any output, otherwise it will be auto-generated, if needed, by CDS system. Does not need to be the actual ID of the source system.
    @returns {Array} an array of {@link Identifier} objects
     */

    CommunicationRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The type of message such as alert, notification, reminder, instruction, etc.
    @returns {CodeableConcept}
     */

    CommunicationRequest.prototype.category = function() {
      if (this.json['category']) {
        return new CodeableConcept(this.json['category']);
      }
    };


    /**
    The entity (e.g., person, organization, clinical information system, or device) which is the source of the communication.
    @returns {Reference}
     */

    CommunicationRequest.prototype.sender = function() {
      if (this.json['sender']) {
        return new Reference(this.json['sender']);
      }
    };


    /**
    The entity (e.g., person, organization, clinical information system, or device) which is the intended target of the communication.
    @returns {Array} an array of {@link Reference} objects
     */

    CommunicationRequest.prototype.recipient = function() {
      var i, item, len, ref, results;
      if (this.json['recipient']) {
        ref = this.json['recipient'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Text, attachment(s), or resource(s) to be communicated to the recipient.
    @returns {Array} an array of {@link CommunicationRequestMessagePartComponent} objects
     */

    CommunicationRequest.prototype.messagePart = function() {
      var i, item, len, ref, results;
      if (this.json['messagePart']) {
        ref = this.json['messagePart'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CommunicationRequestMessagePartComponent(item));
        }
        return results;
      }
    };


    /**
    The communication medium, e.g., email, fax.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    CommunicationRequest.prototype.medium = function() {
      var i, item, len, ref, results;
      if (this.json['medium']) {
        ref = this.json['medium'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The responsible person who authorizes this order, e.g., physician. This may be different than the author of the order statement, e.g., clerk, who may have entered the statement into the order entry application.
    @returns {Reference}
     */

    CommunicationRequest.prototype.requester = function() {
      if (this.json['requester']) {
        return new Reference(this.json['requester']);
      }
    };


    /**
    The status of the proposal or order.
    @returns {Array} an array of {@link String} objects
     */

    CommunicationRequest.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Whether the communication is proposed, ordered, or planned.
    @returns {Array} an array of {@link String} objects
     */

    CommunicationRequest.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    The encounter within which the communication request was created.
    @returns {Reference}
     */

    CommunicationRequest.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    The time when this communication is to occur.
    @returns {Array} an array of {@link Date} objects
     */

    CommunicationRequest.prototype.scheduledTime = function() {
      if (this.json['scheduledTime']) {
        return DT.DateTime.parse(this.json['scheduledTime']);
      }
    };


    /**
    The reason or justification for the communication request.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    CommunicationRequest.prototype.indication = function() {
      var i, item, len, ref, results;
      if (this.json['indication']) {
        ref = this.json['indication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The time when the request was made.
    @returns {Array} an array of {@link Date} objects
     */

    CommunicationRequest.prototype.orderedOn = function() {
      if (this.json['orderedOn']) {
        return DT.DateTime.parse(this.json['orderedOn']);
      }
    };


    /**
    The patient who is the focus of this communication request.
    @returns {Reference}
     */

    CommunicationRequest.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
    @returns {CodeableConcept}
     */

    CommunicationRequest.prototype.priority = function() {
      if (this.json['priority']) {
        return new CodeableConcept(this.json['priority']);
      }
    };

    return CommunicationRequest;

  })(DomainResource);

  module.exports.CommunicationRequest = CommunicationRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],50:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, Composition, CompositionAttesterComponent, CompositionEventComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SectionComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class CompositionAttesterComponent
  @exports  CompositionAttesterComponent as CompositionAttesterComponent
   */

  CompositionAttesterComponent = (function(superClass) {
    extend(CompositionAttesterComponent, superClass);

    function CompositionAttesterComponent(json) {
      this.json = json;
      CompositionAttesterComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The type of attestation the authenticator offers.
    @returns {Array} an array of {@link String} objects
     */

    CompositionAttesterComponent.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    When composition was attested by the party.
    @returns {Array} an array of {@link Date} objects
     */

    CompositionAttesterComponent.prototype.time = function() {
      if (this.json['time']) {
        return DT.DateTime.parse(this.json['time']);
      }
    };


    /**
    Who attested the composition in the specified way.
    @returns {Reference}
     */

    CompositionAttesterComponent.prototype.party = function() {
      if (this.json['party']) {
        return new Reference(this.json['party']);
      }
    };

    return CompositionAttesterComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class CompositionEventComponent
  @exports  CompositionEventComponent as CompositionEventComponent
   */

  CompositionEventComponent = (function(superClass) {
    extend(CompositionEventComponent, superClass);

    function CompositionEventComponent(json) {
      this.json = json;
      CompositionEventComponent.__super__.constructor.call(this, this.json);
    }


    /**
    This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    CompositionEventComponent.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    @returns {Period}
     */

    CompositionEventComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Full details for the event(s) the composition/documentation consents.
    @returns {Array} an array of {@link Reference} objects
     */

    CompositionEventComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return CompositionEventComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SectionComponent
  @exports  SectionComponent as SectionComponent
   */

  SectionComponent = (function(superClass) {
    extend(SectionComponent, superClass);

    function SectionComponent(json) {
      this.json = json;
      SectionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    @returns {Array} an array of {@link String} objects
     */

    SectionComponent.prototype.title = function() {
      return this.json['title'];
    };


    /**
    A code identifying the kind of content contained within the section. This must be consistent with the section title.
    @returns {CodeableConcept}
     */

    SectionComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    A nested sub-section within this section.
    @returns {Array} an array of {@link SectionComponent} objects
     */

    SectionComponent.prototype.section = function() {
      var i, item, len, ref, results;
      if (this.json['section']) {
        ref = this.json['section'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SectionComponent(item));
        }
        return results;
      }
    };


    /**
    The content (narrative and data) associated with the section.
    @returns {Reference}
     */

    SectionComponent.prototype.content = function() {
      if (this.json['content']) {
        return new Reference(this.json['content']);
      }
    };

    return SectionComponent;

  })(BackboneElement);


  /**
  A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement.
  @class Composition
  @exports Composition as Composition
   */

  Composition = (function(superClass) {
    extend(Composition, superClass);

    function Composition(json) {
      this.json = json;
      Composition.__super__.constructor.call(this, this.json);
    }


    /**
    Logical Identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time.
    @returns {Identifier}
     */

    Composition.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The composition editing time, when the composition was last logically changed by the author.
    @returns {Array} an array of {@link Date} objects
     */

    Composition.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition.
    @returns {CodeableConcept}
     */

    Composition.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    A categorization for the type of the composition. This may be implied by or derived from the code specified in the Composition Type.
    @returns {CodeableConcept}
     */

    Composition.prototype["class"] = function() {
      if (this.json['class']) {
        return new CodeableConcept(this.json['class']);
      }
    };


    /**
    Official human-readable label for the composition.
    @returns {Array} an array of {@link String} objects
     */

    Composition.prototype.title = function() {
      return this.json['title'];
    };


    /**
    The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document.
    @returns {Array} an array of {@link String} objects
     */

    Composition.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The code specifying the level of confidentiality of the Composition.
    @returns {Coding}
     */

    Composition.prototype.confidentiality = function() {
      if (this.json['confidentiality']) {
        return new Coding(this.json['confidentiality']);
      }
    };


    /**
    Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (I.e. machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure).
    @returns {Reference}
     */

    Composition.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Identifies who is responsible for the information in the composition.  (Not necessarily who typed it in.).
    @returns {Array} an array of {@link Reference} objects
     */

    Composition.prototype.author = function() {
      var i, item, len, ref, results;
      if (this.json['author']) {
        ref = this.json['author'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A participant who has attested to the accuracy of the composition/document.
    @returns {Array} an array of {@link CompositionAttesterComponent} objects
     */

    Composition.prototype.attester = function() {
      var i, item, len, ref, results;
      if (this.json['attester']) {
        ref = this.json['attester'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CompositionAttesterComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information.
    @returns {Reference}
     */

    Composition.prototype.custodian = function() {
      if (this.json['custodian']) {
        return new Reference(this.json['custodian']);
      }
    };


    /**
    The clinical service, such as a colonoscopy or an appendectomy, being documented.
    @returns {Array} an array of {@link CompositionEventComponent} objects
     */

    Composition.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CompositionEventComponent(item));
        }
        return results;
      }
    };


    /**
    Describes the clinical encounter or type of care this documentation is associated with.
    @returns {Reference}
     */

    Composition.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    The root of the sections that make up the composition.
    @returns {Array} an array of {@link SectionComponent} objects
     */

    Composition.prototype.section = function() {
      var i, item, len, ref, results;
      if (this.json['section']) {
        ref = this.json['section'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SectionComponent(item));
        }
        return results;
      }
    };

    return Composition;

  })(DomainResource);

  module.exports.Composition = Composition;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],51:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ConceptMap, ConceptMapElementComponent, ConceptMapElementMapComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, OtherElementComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class OtherElementComponent
  @exports  OtherElementComponent as OtherElementComponent
   */

  OtherElementComponent = (function(superClass) {
    extend(OtherElementComponent, superClass);

    function OtherElementComponent(json) {
      this.json = json;
      OtherElementComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    @returns {Array} an array of {@link String} objects
     */

    OtherElementComponent.prototype.element = function() {
      return this.json['element'];
    };


    /**
    The code system of the dependency code (if the source/dependency is a value set that cross code systems).
    @returns {Array} an array of {@link String} objects
     */

    OtherElementComponent.prototype.codeSystem = function() {
      return this.json['codeSystem'];
    };


    /**
    Identity (code or path) or the element/item that the map depends on / refers to.
    @returns {Array} an array of {@link String} objects
     */

    OtherElementComponent.prototype.code = function() {
      return this.json['code'];
    };

    return OtherElementComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptMapElementMapComponent
  @exports  ConceptMapElementMapComponent as ConceptMapElementMapComponent
   */

  ConceptMapElementMapComponent = (function(superClass) {
    extend(ConceptMapElementMapComponent, superClass);

    function ConceptMapElementMapComponent(json) {
      this.json = json;
      ConceptMapElementMapComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The code system of the target code (if the target is a value set that cross code systems).
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementMapComponent.prototype.codeSystem = function() {
      return this.json['codeSystem'];
    };


    /**
    Identity (code or path) or the element/item that the map refers to.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementMapComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from source to target (e.g. the source is 'wider' than the target.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementMapComponent.prototype.equivalence = function() {
      return this.json['equivalence'];
    };


    /**
    A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementMapComponent.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    @returns {Array} an array of {@link OtherElementComponent} objects
     */

    ConceptMapElementMapComponent.prototype.product = function() {
      var i, item, len, ref, results;
      if (this.json['product']) {
        ref = this.json['product'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new OtherElementComponent(item));
        }
        return results;
      }
    };

    return ConceptMapElementMapComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptMapElementComponent
  @exports  ConceptMapElementComponent as ConceptMapElementComponent
   */

  ConceptMapElementComponent = (function(superClass) {
    extend(ConceptMapElementComponent, superClass);

    function ConceptMapElementComponent(json) {
      this.json = json;
      ConceptMapElementComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code System (if the source is a value value set that crosses more than one code system).
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementComponent.prototype.codeSystem = function() {
      return this.json['codeSystem'];
    };


    /**
    Identity (code or path) or the element/item being mapped.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMapElementComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    @returns {Array} an array of {@link OtherElementComponent} objects
     */

    ConceptMapElementComponent.prototype.dependsOn = function() {
      var i, item, len, ref, results;
      if (this.json['dependsOn']) {
        ref = this.json['dependsOn'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new OtherElementComponent(item));
        }
        return results;
      }
    };


    /**
    A concept from the target value set that this concept maps to.
    @returns {Array} an array of {@link ConceptMapElementMapComponent} objects
     */

    ConceptMapElementComponent.prototype.map = function() {
      var i, item, len, ref, results;
      if (this.json['map']) {
        ref = this.json['map'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptMapElementMapComponent(item));
        }
        return results;
      }
    };

    return ConceptMapElementComponent;

  })(BackboneElement);


  /**
  A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
  @class ConceptMap
  @exports ConceptMap as ConceptMap
   */

  ConceptMap = (function(superClass) {
    extend(ConceptMap, superClass);

    function ConceptMap(json) {
      this.json = json;
      ConceptMap.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this concept map when it is referenced in a specification, model, design or an instance (should be globally unique OID, UUID, or URI).
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A free text natural language name describing the concept map.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.name = function() {
      return this.json['name'];
    };


    /**
    The name of the individual or organization that published the concept map.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contacts of the publisher to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    ConceptMap.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the use of the concept map - reason for definition, conditions of use, etc.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A copyright statement relating to the concept map and/or its contents.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.copyright = function() {
      return this.json['copyright'];
    };


    /**
    The status of the concept map.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.status = function() {
      return this.json['status'];
    };


    /**
    This ConceptMap was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    ConceptMap.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    The date that the concept map status was last changed.
    @returns {Array} an array of {@link Date} objects
     */

    ConceptMap.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The source value set that specifies the concepts that are being mapped.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.sourceUri = function() {
      return this.json['sourceUri'];
    };


    /**
    The source value set that specifies the concepts that are being mapped.
    @returns {Reference}
     */

    ConceptMap.prototype.sourceReference = function() {
      if (this.json['sourceReference']) {
        return new Reference(this.json['sourceReference']);
      }
    };


    /**
    The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
    @returns {Array} an array of {@link String} objects
     */

    ConceptMap.prototype.targetUri = function() {
      return this.json['targetUri'];
    };


    /**
    The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
    @returns {Reference}
     */

    ConceptMap.prototype.targetReference = function() {
      if (this.json['targetReference']) {
        return new Reference(this.json['targetReference']);
      }
    };


    /**
    Mappings for an individual concept in the source to one or more concepts in the target.
    @returns {Array} an array of {@link ConceptMapElementComponent} objects
     */

    ConceptMap.prototype.element = function() {
      var i, item, len, ref, results;
      if (this.json['element']) {
        ref = this.json['element'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptMapElementComponent(item));
        }
        return results;
      }
    };

    return ConceptMap;

  })(DomainResource);

  module.exports.ConceptMap = ConceptMap;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],52:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, Condition, ConditionDueToComponent, ConditionEvidenceComponent, ConditionLocationComponent, ConditionOccurredFollowingComponent, ConditionStageComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ConditionStageComponent
  @exports  ConditionStageComponent as ConditionStageComponent
   */

  ConditionStageComponent = (function(superClass) {
    extend(ConditionStageComponent, superClass);

    function ConditionStageComponent(json) {
      this.json = json;
      ConditionStageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    @returns {CodeableConcept}
     */

    ConditionStageComponent.prototype.summary = function() {
      if (this.json['summary']) {
        return new CodeableConcept(this.json['summary']);
      }
    };


    /**
    Reference to a formal record of the evidence on which the staging assessment is based.
    @returns {Array} an array of {@link Reference} objects
     */

    ConditionStageComponent.prototype.assessment = function() {
      var i, item, len, ref, results;
      if (this.json['assessment']) {
        ref = this.json['assessment'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return ConditionStageComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConditionEvidenceComponent
  @exports  ConditionEvidenceComponent as ConditionEvidenceComponent
   */

  ConditionEvidenceComponent = (function(superClass) {
    extend(ConditionEvidenceComponent, superClass);

    function ConditionEvidenceComponent(json) {
      this.json = json;
      ConditionEvidenceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A manifestation or symptom that led to the recording of this condition.
    @returns {CodeableConcept}
     */

    ConditionEvidenceComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Links to other relevant information, including pathology reports.
    @returns {Array} an array of {@link Reference} objects
     */

    ConditionEvidenceComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return ConditionEvidenceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConditionLocationComponent
  @exports  ConditionLocationComponent as ConditionLocationComponent
   */

  ConditionLocationComponent = (function(superClass) {
    extend(ConditionLocationComponent, superClass);

    function ConditionLocationComponent(json) {
      this.json = json;
      ConditionLocationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code that identifies the structural location.
    @returns {CodeableConcept}
     */

    ConditionLocationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Detailed anatomical location information.
    @returns {Array} an array of {@link String} objects
     */

    ConditionLocationComponent.prototype.detail = function() {
      return this.json['detail'];
    };

    return ConditionLocationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConditionDueToComponent
  @exports  ConditionDueToComponent as ConditionDueToComponent
   */

  ConditionDueToComponent = (function(superClass) {
    extend(ConditionDueToComponent, superClass);

    function ConditionDueToComponent(json) {
      this.json = json;
      ConditionDueToComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code that identifies the target of this relationship. The code takes the place of a detailed instance target.
    @returns {CodeableConcept}
     */

    ConditionDueToComponent.prototype.codeableConcept = function() {
      if (this.json['codeableConcept']) {
        return new CodeableConcept(this.json['codeableConcept']);
      }
    };


    /**
    Target of the relationship.
    @returns {Reference}
     */

    ConditionDueToComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return ConditionDueToComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConditionOccurredFollowingComponent
  @exports  ConditionOccurredFollowingComponent as ConditionOccurredFollowingComponent
   */

  ConditionOccurredFollowingComponent = (function(superClass) {
    extend(ConditionOccurredFollowingComponent, superClass);

    function ConditionOccurredFollowingComponent(json) {
      this.json = json;
      ConditionOccurredFollowingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code that identifies the target of this relationship. The code takes the place of a detailed instance target.
    @returns {CodeableConcept}
     */

    ConditionOccurredFollowingComponent.prototype.codeableConcept = function() {
      if (this.json['codeableConcept']) {
        return new CodeableConcept(this.json['codeableConcept']);
      }
    };


    /**
    Target of the relationship.
    @returns {Reference}
     */

    ConditionOccurredFollowingComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return ConditionOccurredFollowingComponent;

  })(BackboneElement);


  /**
  Use to record detailed information about conditions, problems or diagnoses recognized by a clinician. There are many uses including: recording a Diagnosis during an Encounter; populating a problem List or a Summary Statement, such as a Discharge Summary.
  @class Condition
  @exports Condition as Condition
   */

  Condition = (function(superClass) {
    extend(Condition, superClass);

    function Condition(json) {
      this.json = json;
      Condition.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this condition that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    Condition.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Indicates the patient who the condition record is associated with.
    @returns {Reference}
     */

    Condition.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Encounter during which the condition was first asserted.
    @returns {Reference}
     */

    Condition.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Person who takes responsibility for asserting the existence of the condition as part of the electronic record.
    @returns {Reference}
     */

    Condition.prototype.asserter = function() {
      if (this.json['asserter']) {
        return new Reference(this.json['asserter']);
      }
    };


    /**
    Estimated or actual date the condition/problem/diagnosis was first detected/suspected.
    @returns {Array} an array of {@link Date} objects
     */

    Condition.prototype.dateAsserted = function() {
      if (this.json['dateAsserted']) {
        return DT.DateTime.parse(this.json['dateAsserted']);
      }
    };


    /**
    Identification of the condition, problem or diagnosis.
    @returns {CodeableConcept}
     */

    Condition.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    A category assigned to the condition. E.g. complaint | symptom | finding | diagnosis.
    @returns {CodeableConcept}
     */

    Condition.prototype.category = function() {
      if (this.json['category']) {
        return new CodeableConcept(this.json['category']);
      }
    };


    /**
    The clinical status of the condition.
    @returns {Array} an array of {@link String} objects
     */

    Condition.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The degree of confidence that this condition is correct.
    @returns {CodeableConcept}
     */

    Condition.prototype.certainty = function() {
      if (this.json['certainty']) {
        return new CodeableConcept(this.json['certainty']);
      }
    };


    /**
    A subjective assessment of the severity of the condition as evaluated by the clinician.
    @returns {CodeableConcept}
     */

    Condition.prototype.severity = function() {
      if (this.json['severity']) {
        return new CodeableConcept(this.json['severity']);
      }
    };


    /**
    Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    @returns {Array} an array of {@link Date} objects
     */

    Condition.prototype.onsetDateTime = function() {
      if (this.json['onsetDateTime']) {
        return DT.DateTime.parse(this.json['onsetDateTime']);
      }
    };

    Condition.prototype.onsetAge = function() {
      return new Quantity(this.json['onsetAge']);
    };


    /**
    The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    @returns {Array} an array of {@link Date} objects
     */

    Condition.prototype.abatementDate = function() {
      if (this.json['abatementDate']) {
        return DT.DateTime.parse(this.json['abatementDate']);
      }
    };

    Condition.prototype.abatementAge = function() {
      return new Quantity(this.json['abatementAge']);
    };


    /**
    The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    @returns {Array} an array of {@link boolean} objects
     */

    Condition.prototype.abatementBoolean = function() {
      return this.json['abatementBoolean'];
    };


    /**
    Clinical stage or grade of a condition. May include formal severity assessments.
    @returns {ConditionStageComponent}
     */

    Condition.prototype.stage = function() {
      if (this.json['stage']) {
        return new ConditionStageComponent(this.json['stage']);
      }
    };


    /**
    Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
    @returns {Array} an array of {@link ConditionEvidenceComponent} objects
     */

    Condition.prototype.evidence = function() {
      var i, item, len, ref, results;
      if (this.json['evidence']) {
        ref = this.json['evidence'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConditionEvidenceComponent(item));
        }
        return results;
      }
    };


    /**
    The anatomical location where this condition manifests itself.
    @returns {Array} an array of {@link ConditionLocationComponent} objects
     */

    Condition.prototype.location = function() {
      var i, item, len, ref, results;
      if (this.json['location']) {
        ref = this.json['location'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConditionLocationComponent(item));
        }
        return results;
      }
    };


    /**
    Further conditions, problems, diagnoses, procedures or events or the substance that caused/triggered this Condition.
    @returns {Array} an array of {@link ConditionDueToComponent} objects
     */

    Condition.prototype.dueTo = function() {
      var i, item, len, ref, results;
      if (this.json['dueTo']) {
        ref = this.json['dueTo'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConditionDueToComponent(item));
        }
        return results;
      }
    };


    /**
    Further conditions, problems, diagnoses, procedures or events or the substance that preceded this Condition.
    @returns {Array} an array of {@link ConditionOccurredFollowingComponent} objects
     */

    Condition.prototype.occurredFollowing = function() {
      var i, item, len, ref, results;
      if (this.json['occurredFollowing']) {
        ref = this.json['occurredFollowing'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConditionOccurredFollowingComponent(item));
        }
        return results;
      }
    };


    /**
    Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    @returns {Array} an array of {@link String} objects
     */

    Condition.prototype.notes = function() {
      return this.json['notes'];
    };

    return Condition;

  })(DomainResource);

  module.exports.Condition = Condition;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],53:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, Conformance, ConformanceDocumentComponent, ConformanceImplementationComponent, ConformanceMessagingComponent, ConformanceMessagingEventComponent, ConformanceRestComponent, ConformanceRestOperationComponent, ConformanceRestResourceComponent, ConformanceRestResourceSearchParamComponent, ConformanceRestSecurityCertificateComponent, ConformanceRestSecurityComponent, ConformanceSoftwareComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, ResourceInteractionComponent, SampledData, SystemInteractionComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ConformanceSoftwareComponent
  @exports  ConformanceSoftwareComponent as ConformanceSoftwareComponent
   */

  ConformanceSoftwareComponent = (function(superClass) {
    extend(ConformanceSoftwareComponent, superClass);

    function ConformanceSoftwareComponent(json) {
      this.json = json;
      ConformanceSoftwareComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Name software is known by.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceSoftwareComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    The version identifier for the software covered by this statement.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceSoftwareComponent.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Date this version of the software released.
    @returns {Array} an array of {@link Date} objects
     */

    ConformanceSoftwareComponent.prototype.releaseDate = function() {
      if (this.json['releaseDate']) {
        return DT.DateTime.parse(this.json['releaseDate']);
      }
    };

    return ConformanceSoftwareComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceImplementationComponent
  @exports  ConformanceImplementationComponent as ConformanceImplementationComponent
   */

  ConformanceImplementationComponent = (function(superClass) {
    extend(ConformanceImplementationComponent, superClass);

    function ConformanceImplementationComponent(json) {
      this.json = json;
      ConformanceImplementationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Information about the specific installation that this conformance statement relates to.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceImplementationComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceImplementationComponent.prototype.url = function() {
      return this.json['url'];
    };

    return ConformanceImplementationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestSecurityCertificateComponent
  @exports  ConformanceRestSecurityCertificateComponent as ConformanceRestSecurityCertificateComponent
   */

  ConformanceRestSecurityCertificateComponent = (function(superClass) {
    extend(ConformanceRestSecurityCertificateComponent, superClass);

    function ConformanceRestSecurityCertificateComponent(json) {
      this.json = json;
      ConformanceRestSecurityCertificateComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Mime type for certificate.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestSecurityCertificateComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Actual certificate.
    @returns {Array} an array of {@link } objects
     */

    ConformanceRestSecurityCertificateComponent.prototype.blob = function() {
      return this.json['blob'];
    };

    return ConformanceRestSecurityCertificateComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestSecurityComponent
  @exports  ConformanceRestSecurityComponent as ConformanceRestSecurityComponent
   */

  ConformanceRestSecurityComponent = (function(superClass) {
    extend(ConformanceRestSecurityComponent, superClass);

    function ConformanceRestSecurityComponent(json) {
      this.json = json;
      ConformanceRestSecurityComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Server adds CORS headers when responding to requests - this enables javascript applications to use the server.
    @returns {Array} an array of {@link boolean} objects
     */

    ConformanceRestSecurityComponent.prototype.cors = function() {
      return this.json['cors'];
    };


    /**
    Types of security services are supported/required by the system.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ConformanceRestSecurityComponent.prototype.service = function() {
      var i, item, len, ref, results;
      if (this.json['service']) {
        ref = this.json['service'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    General description of how security works.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestSecurityComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Certificates associated with security profiles.
    @returns {Array} an array of {@link ConformanceRestSecurityCertificateComponent} objects
     */

    ConformanceRestSecurityComponent.prototype.certificate = function() {
      var i, item, len, ref, results;
      if (this.json['certificate']) {
        ref = this.json['certificate'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceRestSecurityCertificateComponent(item));
        }
        return results;
      }
    };

    return ConformanceRestSecurityComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ResourceInteractionComponent
  @exports  ResourceInteractionComponent as ResourceInteractionComponent
   */

  ResourceInteractionComponent = (function(superClass) {
    extend(ResourceInteractionComponent, superClass);

    function ResourceInteractionComponent(json) {
      this.json = json;
      ResourceInteractionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Coded identifier of the operation, supported by the system resource.
    @returns {Array} an array of {@link String} objects
     */

    ResourceInteractionComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    @returns {Array} an array of {@link String} objects
     */

    ResourceInteractionComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };

    return ResourceInteractionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestResourceSearchParamComponent
  @exports  ConformanceRestResourceSearchParamComponent as ConformanceRestResourceSearchParamComponent
   */

  ConformanceRestResourceSearchParamComponent = (function(superClass) {
    extend(ConformanceRestResourceSearchParamComponent, superClass);

    function ConformanceRestResourceSearchParamComponent(json) {
      this.json = json;
      ConformanceRestResourceSearchParamComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The name of the search parameter used in the interface.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.definition = function() {
      return this.json['definition'];
    };


    /**
    The type of value a search parameter refers to, and how the content is interpreted.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };


    /**
    Types of resource (if a resource is referenced).
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.target = function() {
      return this.json['target'];
    };


    /**
    Chained names supported.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceSearchParamComponent.prototype.chain = function() {
      return this.json['chain'];
    };

    return ConformanceRestResourceSearchParamComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestResourceComponent
  @exports  ConformanceRestResourceComponent as ConformanceRestResourceComponent
   */

  ConformanceRestResourceComponent = (function(superClass) {
    extend(ConformanceRestResourceComponent, superClass);

    function ConformanceRestResourceComponent(json) {
      this.json = json;
      ConformanceRestResourceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A type of resource exposed via the restful interface.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    A specification of the profile that describes the solution's support for the resource, including any constraints on cardinality, bindings, lengths or other limitations.
    @returns {Reference}
     */

    ConformanceRestResourceComponent.prototype.profile = function() {
      if (this.json['profile']) {
        return new Reference(this.json['profile']);
      }
    };


    /**
    Identifies a restful operation supported by the solution.
    @returns {Array} an array of {@link ResourceInteractionComponent} objects
     */

    ConformanceRestResourceComponent.prototype.interaction = function() {
      var i, item, len, ref, results;
      if (this.json['interaction']) {
        ref = this.json['interaction'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ResourceInteractionComponent(item));
        }
        return results;
      }
    };


    /**
    Thi field is set to true to specify that the system does not support (server) or use (client) versioning for this resource type. If this is not set to true, the server must at least correctly track and populate the versionId meta-property on resources.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceComponent.prototype.versioning = function() {
      return this.json['versioning'];
    };


    /**
    A flag for whether the server is able to return past versions as part of the vRead operation.
    @returns {Array} an array of {@link boolean} objects
     */

    ConformanceRestResourceComponent.prototype.readHistory = function() {
      return this.json['readHistory'];
    };


    /**
    A flag to indicate that the server allows the client to create new identities on the server. If the update operation is used (client) or allowed (server) to a new location where a resource doesn't already exist. This means that the server allows the client to create new identities on the server.
    @returns {Array} an array of {@link boolean} objects
     */

    ConformanceRestResourceComponent.prototype.updateCreate = function() {
      return this.json['updateCreate'];
    };


    /**
    A list of _include values supported by the server.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestResourceComponent.prototype.searchInclude = function() {
      return this.json['searchInclude'];
    };


    /**
    Additional search parameters for implementations to support and/or make use of.
    @returns {Array} an array of {@link ConformanceRestResourceSearchParamComponent} objects
     */

    ConformanceRestResourceComponent.prototype.searchParam = function() {
      var i, item, len, ref, results;
      if (this.json['searchParam']) {
        ref = this.json['searchParam'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceRestResourceSearchParamComponent(item));
        }
        return results;
      }
    };

    return ConformanceRestResourceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SystemInteractionComponent
  @exports  SystemInteractionComponent as SystemInteractionComponent
   */

  SystemInteractionComponent = (function(superClass) {
    extend(SystemInteractionComponent, superClass);

    function SystemInteractionComponent(json) {
      this.json = json;
      SystemInteractionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A coded identifier of the operation, supported by the system.
    @returns {Array} an array of {@link String} objects
     */

    SystemInteractionComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    @returns {Array} an array of {@link String} objects
     */

    SystemInteractionComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };

    return SystemInteractionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestOperationComponent
  @exports  ConformanceRestOperationComponent as ConformanceRestOperationComponent
   */

  ConformanceRestOperationComponent = (function(superClass) {
    extend(ConformanceRestOperationComponent, superClass);

    function ConformanceRestOperationComponent(json) {
      this.json = json;
      ConformanceRestOperationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The name of a query, which is used in the _query parameter when the query is called.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestOperationComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Where the formal definition can be found.
    @returns {Reference}
     */

    ConformanceRestOperationComponent.prototype.definition = function() {
      if (this.json['definition']) {
        return new Reference(this.json['definition']);
      }
    };

    return ConformanceRestOperationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceRestComponent
  @exports  ConformanceRestComponent as ConformanceRestComponent
   */

  ConformanceRestComponent = (function(superClass) {
    extend(ConformanceRestComponent, superClass);

    function ConformanceRestComponent(json) {
      this.json = json;
      ConformanceRestComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestComponent.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    Information about the system's restful capabilities that apply across all applications, such as security.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };


    /**
    Information about security of implementation.
    @returns {ConformanceRestSecurityComponent}
     */

    ConformanceRestComponent.prototype.security = function() {
      if (this.json['security']) {
        return new ConformanceRestSecurityComponent(this.json['security']);
      }
    };


    /**
    A specification of the restful capabilities of the solution for a specific resource type.
    @returns {Array} an array of {@link ConformanceRestResourceComponent} objects
     */

    ConformanceRestComponent.prototype.resource = function() {
      var i, item, len, ref, results;
      if (this.json['resource']) {
        ref = this.json['resource'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceRestResourceComponent(item));
        }
        return results;
      }
    };


    /**
    A specification of restful operations supported by the system.
    @returns {Array} an array of {@link SystemInteractionComponent} objects
     */

    ConformanceRestComponent.prototype.interaction = function() {
      var i, item, len, ref, results;
      if (this.json['interaction']) {
        ref = this.json['interaction'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SystemInteractionComponent(item));
        }
        return results;
      }
    };


    /**
    Definition of an operation or a named query and with its parameters and their meaning and type.
    @returns {Array} an array of {@link ConformanceRestOperationComponent} objects
     */

    ConformanceRestComponent.prototype.operation = function() {
      var i, item, len, ref, results;
      if (this.json['operation']) {
        ref = this.json['operation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceRestOperationComponent(item));
        }
        return results;
      }
    };


    /**
    A list of profiles that this server implements for accepting documents in the mailbox. If this list is empty, then documents are not accepted. The base specification has the profile identifier "http://hl7.org/fhir/documents/mailbox". Other specifications can declare their own identifier for this purpose.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceRestComponent.prototype.documentMailbox = function() {
      return this.json['documentMailbox'];
    };

    return ConformanceRestComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceMessagingEventComponent
  @exports  ConformanceMessagingEventComponent as ConformanceMessagingEventComponent
   */

  ConformanceMessagingEventComponent = (function(superClass) {
    extend(ConformanceMessagingEventComponent, superClass);

    function ConformanceMessagingEventComponent(json) {
      this.json = json;
      ConformanceMessagingEventComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A coded identifier of a supported messaging event.
    @returns {Coding}
     */

    ConformanceMessagingEventComponent.prototype.code = function() {
      if (this.json['code']) {
        return new Coding(this.json['code']);
      }
    };


    /**
    The impact of the content of the message.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingEventComponent.prototype.category = function() {
      return this.json['category'];
    };


    /**
    The mode of this event declaration - whether application is sender or receiver.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingEventComponent.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    @returns {Array} an array of {@link Coding} objects
     */

    ConformanceMessagingEventComponent.prototype.protocol = function() {
      var i, item, len, ref, results;
      if (this.json['protocol']) {
        ref = this.json['protocol'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    A resource associated with the event.  This is the resource that defines the event.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingEventComponent.prototype.focus = function() {
      return this.json['focus'];
    };


    /**
    Information about the request for this event.
    @returns {Reference}
     */

    ConformanceMessagingEventComponent.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Information about the response for this event.
    @returns {Reference}
     */

    ConformanceMessagingEventComponent.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };


    /**
    Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingEventComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };

    return ConformanceMessagingEventComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceMessagingComponent
  @exports  ConformanceMessagingComponent as ConformanceMessagingComponent
   */

  ConformanceMessagingComponent = (function(superClass) {
    extend(ConformanceMessagingComponent, superClass);

    function ConformanceMessagingComponent(json) {
      this.json = json;
      ConformanceMessagingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An address to which messages and/or replies are to be sent.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingComponent.prototype.endpoint = function() {
      return this.json['endpoint'];
    };


    /**
    Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    @returns {Array} an array of {@link Number} objects
     */

    ConformanceMessagingComponent.prototype.reliableCache = function() {
      return this.json['reliableCache'];
    };


    /**
    Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceMessagingComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };


    /**
    A description of the solution's support for an event at this end point.
    @returns {Array} an array of {@link ConformanceMessagingEventComponent} objects
     */

    ConformanceMessagingComponent.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceMessagingEventComponent(item));
        }
        return results;
      }
    };

    return ConformanceMessagingComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConformanceDocumentComponent
  @exports  ConformanceDocumentComponent as ConformanceDocumentComponent
   */

  ConformanceDocumentComponent = (function(superClass) {
    extend(ConformanceDocumentComponent, superClass);

    function ConformanceDocumentComponent(json) {
      this.json = json;
      ConformanceDocumentComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Mode of this document declaration - whether application is producer or consumer.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceDocumentComponent.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    @returns {Array} an array of {@link String} objects
     */

    ConformanceDocumentComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };


    /**
    A constraint on a resource used in the document.
    @returns {Reference}
     */

    ConformanceDocumentComponent.prototype.profile = function() {
      if (this.json['profile']) {
        return new Reference(this.json['profile']);
      }
    };

    return ConformanceDocumentComponent;

  })(BackboneElement);


  /**
  A conformance statement is a set of requirements for a desired implementation or a description of how a target application fulfills those requirements in a particular implementation.
  @class Conformance
  @exports Conformance as Conformance
   */

  Conformance = (function(superClass) {
    extend(Conformance, superClass);

    function Conformance(json) {
      this.json = json;
      Conformance.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this conformance statement when it is referenced in a specification, model, design or an instance (should be globally unique OID, UUID, or URI).
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    The identifier that is used to identify this version of the conformance statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A free text natural language name identifying the conformance statement.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Name of Organization publishing this conformance statement.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contacts for Organization relevant to this conformance statement.  The contacts may be a website, email, phone numbers, etc.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Conformance.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the conformance statement and its use. Typically, this is used when the profile describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.description = function() {
      return this.json['description'];
    };


    /**
    The status of this conformance statement.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.status = function() {
      return this.json['status'];
    };


    /**
    A flag to indicate that this conformance statement is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    Conformance.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    The date  (and optionally time) when the conformance statement was published.
    @returns {Array} an array of {@link Date} objects
     */

    Conformance.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Software that is covered by this conformance statement.  It is used when the profile describes the capabilities of a particular software version, independent of an installation.
    @returns {ConformanceSoftwareComponent}
     */

    Conformance.prototype.software = function() {
      if (this.json['software']) {
        return new ConformanceSoftwareComponent(this.json['software']);
      }
    };


    /**
    Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program.
    @returns {ConformanceImplementationComponent}
     */

    Conformance.prototype.implementation = function() {
      if (this.json['implementation']) {
        return new ConformanceImplementationComponent(this.json['implementation']);
      }
    };


    /**
    The version of the FHIR specification on which this conformance statement is based.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.fhirVersion = function() {
      return this.json['fhirVersion'];
    };


    /**
    A flag that indicates whether the application accepts unknown elements as part of a resource.
    @returns {Array} an array of {@link boolean} objects
     */

    Conformance.prototype.acceptUnknown = function() {
      return this.json['acceptUnknown'];
    };


    /**
    A list of the formats supported by this implementation.
    @returns {Array} an array of {@link String} objects
     */

    Conformance.prototype.format = function() {
      return this.json['format'];
    };


    /**
    A list of profiles supported by the system. For a server, "supported by the system" means the system hosts/produces a set of resources, conformant to a particular profile, and allows its clients to search using this profile and to find appropriate data. For a client, it means the system will search by this profile and process data according to the guidance implicit in the profile.
    @returns {Array} an array of {@link Reference} objects
     */

    Conformance.prototype.profile = function() {
      var i, item, len, ref, results;
      if (this.json['profile']) {
        ref = this.json['profile'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A definition of the restful capabilities of the solution, if any.
    @returns {Array} an array of {@link ConformanceRestComponent} objects
     */

    Conformance.prototype.rest = function() {
      var i, item, len, ref, results;
      if (this.json['rest']) {
        ref = this.json['rest'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceRestComponent(item));
        }
        return results;
      }
    };


    /**
    A description of the messaging capabilities of the solution.
    @returns {Array} an array of {@link ConformanceMessagingComponent} objects
     */

    Conformance.prototype.messaging = function() {
      var i, item, len, ref, results;
      if (this.json['messaging']) {
        ref = this.json['messaging'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceMessagingComponent(item));
        }
        return results;
      }
    };


    /**
    A document definition.
    @returns {Array} an array of {@link ConformanceDocumentComponent} objects
     */

    Conformance.prototype.document = function() {
      var i, item, len, ref, results;
      if (this.json['document']) {
        ref = this.json['document'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConformanceDocumentComponent(item));
        }
        return results;
      }
    };

    return Conformance;

  })(DomainResource);

  module.exports.Conformance = Conformance;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],54:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, Contract, ContractSignerComponent, ContractTermComponent, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ContractSignerComponent
  @exports  ContractSignerComponent as ContractSignerComponent
   */

  ContractSignerComponent = (function(superClass) {
    extend(ContractSignerComponent, superClass);

    function ContractSignerComponent(json) {
      this.json = json;
      ContractSignerComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Party or role who is signing.
    @returns {Coding}
     */

    ContractSignerComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The DSIG signature contents in Base64.
    @returns {Array} an array of {@link String} objects
     */

    ContractSignerComponent.prototype.singnature = function() {
      return this.json['singnature'];
    };

    return ContractSignerComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ContractTermComponent
  @exports  ContractTermComponent as ContractTermComponent
   */

  ContractTermComponent = (function(superClass) {
    extend(ContractTermComponent, superClass);

    function ContractTermComponent(json) {
      this.json = json;
      ContractTermComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Unique Id for this particular term.
    @returns {Identifier}
     */

    ContractTermComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The type of the term.
    @returns {CodeableConcept}
     */

    ContractTermComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The subttype of the term which is appropriate to the term type.
    @returns {CodeableConcept}
     */

    ContractTermComponent.prototype.subtype = function() {
      if (this.json['subtype']) {
        return new CodeableConcept(this.json['subtype']);
      }
    };


    /**
    Who or what the contract term is about.
    @returns {Reference}
     */

    ContractTermComponent.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Human readable form of the term of the contract.
    @returns {Array} an array of {@link String} objects
     */

    ContractTermComponent.prototype.text = function() {
      return this.json['text'];
    };

    return ContractTermComponent;

  })(BackboneElement);


  /**
  A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
  @class Contract
  @exports Contract as Contract
   */

  Contract = (function(superClass) {
    extend(Contract, superClass);

    function Contract(json) {
      this.json = json;
      Contract.__super__.constructor.call(this, this.json);
    }


    /**
    Unique Id for this contract.
    @returns {Array} an array of {@link Identifier} objects
     */

    Contract.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Who and/or what this is about: typically Patient, Organization, property.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.subject = function() {
      var i, item, len, ref, results;
      if (this.json['subject']) {
        ref = this.json['subject'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Type of contract (Privacy-Security, Agreement, Insurance).
    @returns {CodeableConcept}
     */

    Contract.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    More specific type of contract (Privacy, Disclosure-Authorization, Advanced-Directive, DNR, Authorization-to-Treat).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Contract.prototype.subtype = function() {
      var i, item, len, ref, results;
      if (this.json['subtype']) {
        ref = this.json['subtype'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    When this was issued.
    @returns {Array} an array of {@link Date} objects
     */

    Contract.prototype.issued = function() {
      if (this.json['issued']) {
        return DT.DateTime.parse(this.json['issued']);
      }
    };


    /**
    Relevant time/time-period when applicable.
    @returns {Period}
     */

    Contract.prototype.applies = function() {
      if (this.json['applies']) {
        return new Period(this.json['applies']);
      }
    };


    /**
    The number of repetitions of a service or product.
    @returns {Quantity}
     */

    Contract.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    The unit price product.
    @returns {Money}
     */

    Contract.prototype.unitPrice = function() {
      if (this.json['unitPrice']) {
        return new Money(this.json['unitPrice']);
      }
    };


    /**
    A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    @returns {Array} an array of {@link Number} objects
     */

    Contract.prototype.factor = function() {
      return this.json['factor'];
    };


    /**
    An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    @returns {Array} an array of {@link Number} objects
     */

    Contract.prototype.points = function() {
      return this.json['points'];
    };


    /**
    The quantity times the unit price for an addtional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    @returns {Money}
     */

    Contract.prototype.net = function() {
      if (this.json['net']) {
        return new Money(this.json['net']);
      }
    };


    /**
    Contract author or responsible party.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.author = function() {
      var i, item, len, ref, results;
      if (this.json['author']) {
        ref = this.json['author'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    First Party to the contract, may be the party who confers or delegates the rights defined in the contract.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.grantor = function() {
      var i, item, len, ref, results;
      if (this.json['grantor']) {
        ref = this.json['grantor'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The Second party to the contract, may be the party who accepts obligations or be that to which rights are delegated.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.grantee = function() {
      var i, item, len, ref, results;
      if (this.json['grantee']) {
        ref = this.json['grantee'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Who witnesses the contract.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.witness = function() {
      var i, item, len, ref, results;
      if (this.json['witness']) {
        ref = this.json['witness'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    First Party to the contract, may be the party who confers or delegates the rights defined in the contract.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.executor = function() {
      var i, item, len, ref, results;
      if (this.json['executor']) {
        ref = this.json['executor'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    First Party to the contract, may be the party who confers or delegates the rights defined in the contract.
    @returns {Array} an array of {@link Reference} objects
     */

    Contract.prototype.notary = function() {
      var i, item, len, ref, results;
      if (this.json['notary']) {
        ref = this.json['notary'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    List or contract signatures.
    @returns {Array} an array of {@link ContractSignerComponent} objects
     */

    Contract.prototype.signer = function() {
      var i, item, len, ref, results;
      if (this.json['signer']) {
        ref = this.json['signer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContractSignerComponent(item));
        }
        return results;
      }
    };


    /**
    A contract provision.
    @returns {Array} an array of {@link ContractTermComponent} objects
     */

    Contract.prototype.term = function() {
      var i, item, len, ref, results;
      if (this.json['term']) {
        ref = this.json['term'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContractTermComponent(item));
        }
        return results;
      }
    };


    /**
    Friendly Human readable form (might be a reference to the UI used to capture the contract).
    @returns {Attachment}
     */

    Contract.prototype.friendly = function() {
      if (this.json['friendly']) {
        return new Attachment(this.json['friendly']);
      }
    };


    /**
    Legal text in Human readable form.
    @returns {Attachment}
     */

    Contract.prototype.legal = function() {
      if (this.json['legal']) {
        return new Attachment(this.json['legal']);
      }
    };


    /**
    Computable Policy rules (e.g. XACML, DKAL, SecPal).
    @returns {Attachment}
     */

    Contract.prototype.rule = function() {
      if (this.json['rule']) {
        return new Attachment(this.json['rule']);
      }
    };

    return Contract;

  })(DomainResource);

  module.exports.Contract = Contract;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],55:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, Contraindication, ContraindicationMitigationComponent, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ContraindicationMitigationComponent
  @exports  ContraindicationMitigationComponent as ContraindicationMitigationComponent
   */

  ContraindicationMitigationComponent = (function(superClass) {
    extend(ContraindicationMitigationComponent, superClass);

    function ContraindicationMitigationComponent(json) {
      this.json = json;
      ContraindicationMitigationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified contraindication.
    @returns {CodeableConcept}
     */

    ContraindicationMitigationComponent.prototype.action = function() {
      if (this.json['action']) {
        return new CodeableConcept(this.json['action']);
      }
    };


    /**
    Indicates when the mitigating action was documented.
    @returns {Array} an array of {@link Date} objects
     */

    ContraindicationMitigationComponent.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
    @returns {Reference}
     */

    ContraindicationMitigationComponent.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };

    return ContraindicationMitigationComponent;

  })(BackboneElement);


  /**
  Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient.  E.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
  @class Contraindication
  @exports Contraindication as Contraindication
   */

  Contraindication = (function(superClass) {
    extend(Contraindication, superClass);

    function Contraindication(json) {
      this.json = json;
      Contraindication.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the patient whose record the contraindication is associated with.
    @returns {Reference}
     */

    Contraindication.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Identifies the general type of issue identified.
    @returns {CodeableConcept}
     */

    Contraindication.prototype.category = function() {
      if (this.json['category']) {
        return new CodeableConcept(this.json['category']);
      }
    };


    /**
    Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
    @returns {Array} an array of {@link String} objects
     */

    Contraindication.prototype.severity = function() {
      return this.json['severity'];
    };


    /**
    Indicates the resource representing the current activity or proposed activity that.
    @returns {Array} an array of {@link Reference} objects
     */

    Contraindication.prototype.implicated = function() {
      var i, item, len, ref, results;
      if (this.json['implicated']) {
        ref = this.json['implicated'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A textual explanation of the contraindication.
    @returns {Array} an array of {@link String} objects
     */

    Contraindication.prototype.detail = function() {
      return this.json['detail'];
    };


    /**
    The date or date-time when the contraindication was initially identified.
    @returns {Array} an array of {@link Date} objects
     */

    Contraindication.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Identifies the provider or software that identified the.
    @returns {Reference}
     */

    Contraindication.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    Business identifier associated with the contraindication record.
    @returns {Identifier}
     */

    Contraindication.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The literature, knowledge-base or similar reference that describes the propensity for the contraindication identified.
    @returns {Array} an array of {@link String} objects
     */

    Contraindication.prototype.reference = function() {
      return this.json['reference'];
    };


    /**
    Indicates an action that has been taken or is committed to to reduce or eliminate the likelihood of the risk identified by the contraindicaiton from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
    @returns {Array} an array of {@link ContraindicationMitigationComponent} objects
     */

    Contraindication.prototype.mitigation = function() {
      var i, item, len, ref, results;
      if (this.json['mitigation']) {
        ref = this.json['mitigation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContraindicationMitigationComponent(item));
        }
        return results;
      }
    };

    return Contraindication;

  })(DomainResource);

  module.exports.Contraindication = Contraindication;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],56:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, Base, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, ElementDefinitionBindingComponent, ElementDefinitionConstraintComponent, ElementDefinitionMappingComponent, ElementDefinitionSlicingComponent, Extension, HumanName, Identifier, Narrative, Parameters, ParametersParameterComponent, Period, Quantity, Range, Ratio, Reference, Resource, ResourceMetaComponent, SampledData, Timing, TimingRepeatComponent, TypeRefComponent,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Base = (function() {
    function Base(json) {
      this.json = json;
    }

    return Base;

  })();

  module.exports.Base = Base;

  DT = require('../cql-datatypes');


  /**
  Base definition for all elements in a resource.
  @class Element
  @exports Element as Element
   */

  Element = (function(superClass) {
    extend(Element, superClass);

    function Element(json) {
      this.json = json;
      Element.__super__.constructor.call(this, this.json);
    }


    /**
    unique id for the element within a resource (for internal references).
    @returns {Array} an array of {@link String} objects
     */

    Element.prototype.id = function() {
      return this.json['id'];
    };


    /**
    May be used to represent additional information that is not part of the basic definition of the element. In order to make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
    @returns {Array} an array of {@link Extension} objects
     */

    Element.prototype.extension = function() {
      var i, item, len, ref, results;
      if (this.json['extension']) {
        ref = this.json['extension'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };

    return Element;

  })(Base);

  module.exports.Element = Element;


  /**
  Base definition for all elements that are defined inside a resource - but not those in a data type.
  @class BackboneElement
  @exports BackboneElement as BackboneElement
   */

  BackboneElement = (function(superClass) {
    extend(BackboneElement, superClass);

    function BackboneElement(json) {
      this.json = json;
      BackboneElement.__super__.constructor.call(this, this.json);
    }


    /**
    May be used to represent additional information that is not part of the basic definition of the element, and that modifies the understanding of the element that contains it. Usually modifier elements provide negation or qualification. In order to make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
    @returns {Array} an array of {@link Extension} objects
     */

    BackboneElement.prototype.modifierExtension = function() {
      var i, item, len, ref, results;
      if (this.json['modifierExtension']) {
        ref = this.json['modifierExtension'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };

    return BackboneElement;

  })(Element);

  module.exports.BackboneElement = BackboneElement;


  /**
  Optional Extensions Element - found in all resources.
  @class Extension
  @exports Extension as Extension
   */

  Extension = (function(superClass) {
    extend(Extension, superClass);

    function Extension(json) {
      this.json = json;
      Extension.__super__.constructor.call(this, this.json);
    }


    /**
    Source of the definition for the extension code - a logical name or a URL.
    @returns {Array} an array of {@link String} objects
     */

    Extension.prototype.url = function() {
      return this.json['url'];
    };


    /**
    Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
    @returns {Array} an array of {@link } objects
     */

    Extension.prototype.value = function() {
      return this.json['value'];
    };

    return Extension;

  })(Element);

  module.exports.Extension = Extension;


  /**
  A human-readable formatted text, including images.
  @class Narrative
  @exports Narrative as Narrative
   */

  Narrative = (function(superClass) {
    extend(Narrative, superClass);

    function Narrative(json) {
      this.json = json;
      Narrative.__super__.constructor.call(this, this.json);
    }


    /**
    The status of the narrative - whether it's entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
    @returns {Array} an array of {@link String} objects
     */

    Narrative.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The actual narrative content, a stripped down version of XHTML.
    @returns {xhtml}
     */

    Narrative.prototype.div = function() {
      if (this.json['div']) {
        return new xhtml(this.json['div']);
      }
    };

    return Narrative;

  })(Element);

  module.exports.Narrative = Narrative;


  /**
  A time period defined by a start and end date and optionally time.
  @class Period
  @exports Period as Period
   */

  Period = (function(superClass) {
    extend(Period, superClass);

    function Period(json) {
      this.json = json;
      Period.__super__.constructor.call(this, this.json);
    }


    /**
    The start of the period. The boundary is inclusive.
    @returns {Array} an array of {@link Date} objects
     */

    Period.prototype.start = function() {
      if (this.json['start']) {
        return DT.DateTime.parse(this.json['start']);
      }
    };


    /**
    The end of the period. If the end of the period is missing, it means that the period is ongoing.
    @returns {Array} an array of {@link Date} objects
     */

    Period.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };

    return Period;

  })(Element);

  module.exports.Period = Period;


  /**
  A reference to a code defined by a terminology system.
  @class Coding
  @exports Coding as Coding
   */

  Coding = (function(superClass) {
    extend(Coding, superClass);

    function Coding(json) {
      this.json = json;
      Coding.__super__.constructor.call(this, this.json);
    }


    /**
    The identification of the code system that defines the meaning of the symbol in the code.
    @returns {Array} an array of {@link String} objects
     */

    Coding.prototype.system = function() {
      return this.json['system'];
    };


    /**
    The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured. and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
    @returns {Array} an array of {@link String} objects
     */

    Coding.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
    @returns {Array} an array of {@link String} objects
     */

    Coding.prototype.code = function() {
      return this.json['code'];
    };


    /**
    A representation of the meaning of the code in the system, following the rules of the system.
    @returns {Array} an array of {@link String} objects
     */

    Coding.prototype.display = function() {
      return this.json['display'];
    };


    /**
    Indicates that this code was chosen by a user directly - i.e. off a pick list of available items (codes or displays).
    @returns {Array} an array of {@link boolean} objects
     */

    Coding.prototype.primary = function() {
      return this.json['primary'];
    };


    /**
    The set of possible coded values this coding was chosen from or constrained by.
    @returns {Reference}
     */

    Coding.prototype.valueSet = function() {
      if (this.json['valueSet']) {
        return new Reference(this.json['valueSet']);
      }
    };

    return Coding;

  })(Element);

  module.exports.Coding = Coding;


  /**
  A set of ordered Quantities defined by a low and high limit.
  @class Range
  @exports Range as Range
   */

  Range = (function(superClass) {
    extend(Range, superClass);

    function Range(json) {
      this.json = json;
      Range.__super__.constructor.call(this, this.json);
    }


    /**
    The low limit. The boundary is inclusive.
    @returns {Quantity}
     */

    Range.prototype.low = function() {
      if (this.json['low']) {
        return new Quantity(this.json['low']);
      }
    };


    /**
    The high limit. The boundary is inclusive.
    @returns {Quantity}
     */

    Range.prototype.high = function() {
      if (this.json['high']) {
        return new Quantity(this.json['high']);
      }
    };

    return Range;

  })(Element);

  module.exports.Range = Range;


  /**
  A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
  @class Quantity
  @exports Quantity as Quantity
   */

  Quantity = (function(superClass) {
    extend(Quantity, superClass);

    function Quantity(json) {
      this.json = json;
      Quantity.__super__.constructor.call(this, this.json);
    }


    /**
    The value of the measured amount. The value includes an implicit precision in the presentation of the value.
    @returns {Array} an array of {@link Number} objects
     */

    Quantity.prototype.value = function() {
      return this.json['value'];
    };


    /**
    How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues. E.g. if the comparator is "<" , then the real value is < stated value.
    @returns {Array} an array of {@link String} objects
     */

    Quantity.prototype.comparator = function() {
      return this.json['comparator'];
    };


    /**
    A human-readable form of the units.
    @returns {Array} an array of {@link String} objects
     */

    Quantity.prototype.units = function() {
      return this.json['units'];
    };


    /**
    The identification of the system that provides the coded form of the unit.
    @returns {Array} an array of {@link String} objects
     */

    Quantity.prototype.system = function() {
      return this.json['system'];
    };


    /**
    A computer processable form of the units in some unit representation system.
    @returns {Array} an array of {@link String} objects
     */

    Quantity.prototype.code = function() {
      return this.json['code'];
    };

    return Quantity;

  })(Element);

  module.exports.Quantity = Quantity;


  /**
  For referring to data content defined in other formats.
  @class Attachment
  @exports Attachment as Attachment
   */

  Attachment = (function(superClass) {
    extend(Attachment, superClass);

    function Attachment(json) {
      this.json = json;
      Attachment.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
    @returns {Array} an array of {@link String} objects
     */

    Attachment.prototype.contentType = function() {
      return this.json['contentType'];
    };


    /**
    The human language of the content. The value can be any valid value according to BCP 47.
    @returns {Array} an array of {@link String} objects
     */

    Attachment.prototype.language = function() {
      return this.json['language'];
    };


    /**
    The actual data of the attachment - a sequence of bytes. In XML, represented using base64.
    @returns {Array} an array of {@link } objects
     */

    Attachment.prototype.data = function() {
      return this.json['data'];
    };


    /**
    An alternative location where the data can be accessed.
    @returns {Array} an array of {@link String} objects
     */

    Attachment.prototype.url = function() {
      return this.json['url'];
    };


    /**
    The number of bytes of data that make up this attachment.
    @returns {Array} an array of {@link Number} objects
     */

    Attachment.prototype.size = function() {
      return this.json['size'];
    };


    /**
    The calculated hash of the data using SHA-1. Represented using base64.
    @returns {Array} an array of {@link } objects
     */

    Attachment.prototype.hash = function() {
      return this.json['hash'];
    };


    /**
    A label or set of text to display in place of the data.
    @returns {Array} an array of {@link String} objects
     */

    Attachment.prototype.title = function() {
      return this.json['title'];
    };

    return Attachment;

  })(Element);

  module.exports.Attachment = Attachment;


  /**
  A relationship of two Quantity values - expressed as a numerator and a denominator.
  @class Ratio
  @exports Ratio as Ratio
   */

  Ratio = (function(superClass) {
    extend(Ratio, superClass);

    function Ratio(json) {
      this.json = json;
      Ratio.__super__.constructor.call(this, this.json);
    }


    /**
    The value of the numerator.
    @returns {Quantity}
     */

    Ratio.prototype.numerator = function() {
      if (this.json['numerator']) {
        return new Quantity(this.json['numerator']);
      }
    };


    /**
    The value of the denominator.
    @returns {Quantity}
     */

    Ratio.prototype.denominator = function() {
      if (this.json['denominator']) {
        return new Quantity(this.json['denominator']);
      }
    };

    return Ratio;

  })(Element);

  module.exports.Ratio = Ratio;


  /**
  A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
  @class SampledData
  @exports SampledData as SampledData
   */

  SampledData = (function(superClass) {
    extend(SampledData, superClass);

    function SampledData(json) {
      this.json = json;
      SampledData.__super__.constructor.call(this, this.json);
    }


    /**
    The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
    @returns {Quantity}
     */

    SampledData.prototype.origin = function() {
      if (this.json['origin']) {
        return new Quantity(this.json['origin']);
      }
    };


    /**
    The length of time between sampling times, measured in milliseconds.
    @returns {Array} an array of {@link Number} objects
     */

    SampledData.prototype.period = function() {
      return this.json['period'];
    };


    /**
    A correction factor that is applied to the sampled data points before they are added to the origin.
    @returns {Array} an array of {@link Number} objects
     */

    SampledData.prototype.factor = function() {
      return this.json['factor'];
    };


    /**
    The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
    @returns {Array} an array of {@link Number} objects
     */

    SampledData.prototype.lowerLimit = function() {
      return this.json['lowerLimit'];
    };


    /**
    The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
    @returns {Array} an array of {@link Number} objects
     */

    SampledData.prototype.upperLimit = function() {
      return this.json['upperLimit'];
    };


    /**
    The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
    @returns {Array} an array of {@link Number} objects
     */

    SampledData.prototype.dimensions = function() {
      return this.json['dimensions'];
    };


    /**
    A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
    @returns {Array} an array of {@link String} objects
     */

    SampledData.prototype.data = function() {
      return this.json['data'];
    };

    return SampledData;

  })(Element);

  module.exports.SampledData = SampledData;


  /**
  A reference from one resource to another.
  @class Reference
  @exports Reference as Reference
   */

  Reference = (function(superClass) {
    extend(Reference, superClass);

    function Reference(json) {
      this.json = json;
      Reference.__super__.constructor.call(this, this.json);
    }


    /**
    A reference to a location at which the other resource is found. The reference may a relative reference, in which case it is relative to the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with '#') refer to contained resources.
    @returns {Array} an array of {@link String} objects
     */

    Reference.prototype.reference = function() {
      return this.json['reference'];
    };


    /**
    Plain text narrative that identifies the resource in addition to the resource reference.
    @returns {Array} an array of {@link String} objects
     */

    Reference.prototype.display = function() {
      return this.json['display'];
    };

    return Reference;

  })(Element);

  module.exports.Reference = Reference;


  /**
  A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
  @class CodeableConcept
  @exports CodeableConcept as CodeableConcept
   */

  CodeableConcept = (function(superClass) {
    extend(CodeableConcept, superClass);

    function CodeableConcept(json) {
      this.json = json;
      CodeableConcept.__super__.constructor.call(this, this.json);
    }


    /**
    A reference to a code defined by a terminology system.
    @returns {Array} an array of {@link Coding} objects
     */

    CodeableConcept.prototype.coding = function() {
      var i, item, len, ref, results;
      if (this.json['coding']) {
        ref = this.json['coding'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    A human language representation of the concept as seen/selected/uttered by the user who entered the data and/or which represents the intended meaning of the user.
    @returns {Array} an array of {@link String} objects
     */

    CodeableConcept.prototype.text = function() {
      return this.json['text'];
    };

    return CodeableConcept;

  })(Element);

  module.exports.CodeableConcept = CodeableConcept;


  /**
  A technical identifier - identifies some entity uniquely and unambiguously.
  @class Identifier
  @exports Identifier as Identifier
   */

  Identifier = (function(superClass) {
    extend(Identifier, superClass);

    function Identifier(json) {
      this.json = json;
      Identifier.__super__.constructor.call(this, this.json);
    }


    /**
    The purpose of this identifier.
    @returns {Array} an array of {@link String} objects
     */

    Identifier.prototype.use = function() {
      return this.json['use'];
    };


    /**
    A text string for the identifier that can be displayed to a human so they can recognize the identifier.
    @returns {Array} an array of {@link String} objects
     */

    Identifier.prototype.label = function() {
      return this.json['label'];
    };


    /**
    Establishes the namespace in which set of possible id values is unique.
    @returns {Array} an array of {@link String} objects
     */

    Identifier.prototype.system = function() {
      return this.json['system'];
    };


    /**
    The portion of the identifier typically displayed to the user and which is unique within the context of the system.
    @returns {Array} an array of {@link String} objects
     */

    Identifier.prototype.value = function() {
      return this.json['value'];
    };


    /**
    Time period during which identifier is/was valid for use.
    @returns {Period}
     */

    Identifier.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Organization that issued/manages the identifier.
    @returns {Reference}
     */

    Identifier.prototype.assigner = function() {
      if (this.json['assigner']) {
        return new Reference(this.json['assigner']);
      }
    };

    return Identifier;

  })(Element);

  module.exports.Identifier = Identifier;


  /** 
  Embedded class
  @class ElementDefinitionSlicingComponent
  @exports  ElementDefinitionSlicingComponent as ElementDefinitionSlicingComponent
   */

  ElementDefinitionSlicingComponent = (function(superClass) {
    extend(ElementDefinitionSlicingComponent, superClass);

    function ElementDefinitionSlicingComponent(json) {
      this.json = json;
      ElementDefinitionSlicingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionSlicingComponent.prototype.discriminator = function() {
      return this.json['discriminator'];
    };


    /**
    A humane readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionSlicingComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    If the matching elements have to occur in the same order as defined in the profile.
    @returns {Array} an array of {@link boolean} objects
     */

    ElementDefinitionSlicingComponent.prototype.ordered = function() {
      return this.json['ordered'];
    };


    /**
    Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionSlicingComponent.prototype.rules = function() {
      return this.json['rules'];
    };

    return ElementDefinitionSlicingComponent;

  })(Element);


  /** 
  Embedded class
  @class TypeRefComponent
  @exports  TypeRefComponent as TypeRefComponent
   */

  TypeRefComponent = (function(superClass) {
    extend(TypeRefComponent, superClass);

    function TypeRefComponent(json) {
      this.json = json;
      TypeRefComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Name of Data type or Resource that is a(or the) type used for this element.
    @returns {Array} an array of {@link String} objects
     */

    TypeRefComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    Identifies a profile structure that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    @returns {Array} an array of {@link String} objects
     */

    TypeRefComponent.prototype.profile = function() {
      return this.json['profile'];
    };


    /**
    If the type is a reference to another resource, how the resource is or can be aggreated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    @returns {Array} an array of {@link String} objects
     */

    TypeRefComponent.prototype.aggregation = function() {
      return this.json['aggregation'];
    };

    return TypeRefComponent;

  })(Element);


  /** 
  Embedded class
  @class ElementDefinitionConstraintComponent
  @exports  ElementDefinitionConstraintComponent as ElementDefinitionConstraintComponent
   */

  ElementDefinitionConstraintComponent = (function(superClass) {
    extend(ElementDefinitionConstraintComponent, superClass);

    function ElementDefinitionConstraintComponent(json) {
      this.json = json;
      ElementDefinitionConstraintComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionConstraintComponent.prototype.key = function() {
      return this.json['key'];
    };


    /**
    Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionConstraintComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Identifies the impact constraint violation has on the conformance of the instance.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionConstraintComponent.prototype.severity = function() {
      return this.json['severity'];
    };


    /**
    Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionConstraintComponent.prototype.human = function() {
      return this.json['human'];
    };


    /**
    An XPath expression of constraint that can be executed to see if this constraint is met.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionConstraintComponent.prototype.xpath = function() {
      return this.json['xpath'];
    };

    return ElementDefinitionConstraintComponent;

  })(Element);


  /** 
  Embedded class
  @class ElementDefinitionBindingComponent
  @exports  ElementDefinitionBindingComponent as ElementDefinitionBindingComponent
   */

  ElementDefinitionBindingComponent = (function(superClass) {
    extend(ElementDefinitionBindingComponent, superClass);

    function ElementDefinitionBindingComponent(json) {
      this.json = json;
      ElementDefinitionBindingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A descriptive name for this - can be useful for generating implementation artifacts.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionBindingComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    @returns {Array} an array of {@link boolean} objects
     */

    ElementDefinitionBindingComponent.prototype.isExtensible = function() {
      return this.json['isExtensible'];
    };


    /**
    Indicates the degree of conformance expectations associated with this binding.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionBindingComponent.prototype.conformance = function() {
      return this.json['conformance'];
    };


    /**
    Describes the intended use of this particular set of codes.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionBindingComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Points to the value set or external definition that identifies the set of codes to be used.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionBindingComponent.prototype.referenceUri = function() {
      return this.json['referenceUri'];
    };


    /**
    Points to the value set or external definition that identifies the set of codes to be used.
    @returns {Reference}
     */

    ElementDefinitionBindingComponent.prototype.referenceReference = function() {
      if (this.json['referenceReference']) {
        return new Reference(this.json['referenceReference']);
      }
    };

    return ElementDefinitionBindingComponent;

  })(Element);


  /** 
  Embedded class
  @class ElementDefinitionMappingComponent
  @exports  ElementDefinitionMappingComponent as ElementDefinitionMappingComponent
   */

  ElementDefinitionMappingComponent = (function(superClass) {
    extend(ElementDefinitionMappingComponent, superClass);

    function ElementDefinitionMappingComponent(json) {
      this.json = json;
      ElementDefinitionMappingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An internal reference to the definition of a mapping.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionMappingComponent.prototype.identity = function() {
      return this.json['identity'];
    };


    /**
    Expresses what part of the target specification corresponds to this element.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinitionMappingComponent.prototype.map = function() {
      return this.json['map'];
    };

    return ElementDefinitionMappingComponent;

  })(Element);


  /**
  Captures constraints on each element within the resource, profile, or extension.
  @class ElementDefinition
  @exports ElementDefinition as ElementDefinition
   */

  ElementDefinition = (function(superClass) {
    extend(ElementDefinition, superClass);

    function ElementDefinition(json) {
      this.json = json;
      ElementDefinition.__super__.constructor.call(this, this.json);
    }


    /**
    The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.path = function() {
      return this.json['path'];
    };


    /**
    Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.representation = function() {
      return this.json['representation'];
    };


    /**
    The name of this element definition (to refer to it from other element definitions using ElementDefinition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    @returns {ElementDefinitionSlicingComponent}
     */

    ElementDefinition.prototype.slicing = function() {
      if (this.json['slicing']) {
        return new ElementDefinitionSlicingComponent(this.json['slicing']);
      }
    };


    /**
    A concise definition that  is shown in the generated XML format that summarizes profiles (used throughout the specification).
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.short = function() {
      return this.json['short'];
    };


    /**
    The definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.formal = function() {
      return this.json['formal'];
    };


    /**
    Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    Explains why this element is needed and why it's been constrained as it has.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    Identifies additional names by which this element might also be known.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.synonym = function() {
      return this.json['synonym'];
    };


    /**
    The minimum number of times this element SHALL appear in the instance.
    @returns {Array} an array of {@link Number} objects
     */

    ElementDefinition.prototype.min = function() {
      return this.json['min'];
    };


    /**
    The maximum number of times this element is permitted to appear in the instance.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.max = function() {
      return this.json['max'];
    };


    /**
    The data type or resource that the value of this element is permitted to be.
    @returns {Array} an array of {@link TypeRefComponent} objects
     */

    ElementDefinition.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new TypeRefComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.nameReference = function() {
      return this.json['nameReference'];
    };


    /**
    The value that should be used if there is no value stated in the instance.
    @returns {Array} an array of {@link } objects
     */

    ElementDefinition.prototype.defaultValue = function() {
      return this.json['defaultValue'];
    };


    /**
    The Implicit meaning that is to be understood when this element is missing.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.meaningWhenMissing = function() {
      return this.json['meaningWhenMissing'];
    };


    /**
    Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-signficant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    @returns {Array} an array of {@link } objects
     */

    ElementDefinition.prototype.fixed = function() {
      return this.json['fixed'];
    };


    /**
    Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-senstive, accent-sensitive, etc.).
    @returns {Array} an array of {@link } objects
     */

    ElementDefinition.prototype.pattern = function() {
      return this.json['pattern'];
    };


    /**
    An example value for this element.
    @returns {Array} an array of {@link } objects
     */

    ElementDefinition.prototype.example = function() {
      return this.json['example'];
    };


    /**
    Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
    @returns {Array} an array of {@link Number} objects
     */

    ElementDefinition.prototype.maxLength = function() {
      return this.json['maxLength'];
    };


    /**
    A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    @returns {Array} an array of {@link String} objects
     */

    ElementDefinition.prototype.condition = function() {
      return this.json['condition'];
    };


    /**
    Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    @returns {Array} an array of {@link ElementDefinitionConstraintComponent} objects
     */

    ElementDefinition.prototype.constraint = function() {
      var i, item, len, ref, results;
      if (this.json['constraint']) {
        ref = this.json['constraint'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ElementDefinitionConstraintComponent(item));
        }
        return results;
      }
    };


    /**
    If true, conformant resource authors SHALL be capable of providing a value for the element and resource consumers SHALL be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    @returns {Array} an array of {@link boolean} objects
     */

    ElementDefinition.prototype.mustSupport = function() {
      return this.json['mustSupport'];
    };


    /**
    If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    @returns {Array} an array of {@link boolean} objects
     */

    ElementDefinition.prototype.isModifier = function() {
      return this.json['isModifier'];
    };


    /**
    Whether the element should be included if a client requests a search with the parameter _summary=true.
    @returns {Array} an array of {@link boolean} objects
     */

    ElementDefinition.prototype.isSummary = function() {
      return this.json['isSummary'];
    };


    /**
    Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    @returns {ElementDefinitionBindingComponent}
     */

    ElementDefinition.prototype.binding = function() {
      if (this.json['binding']) {
        return new ElementDefinitionBindingComponent(this.json['binding']);
      }
    };


    /**
    Identifies a concept from an external specification that roughly corresponds to this element.
    @returns {Array} an array of {@link ElementDefinitionMappingComponent} objects
     */

    ElementDefinition.prototype.mapping = function() {
      var i, item, len, ref, results;
      if (this.json['mapping']) {
        ref = this.json['mapping'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ElementDefinitionMappingComponent(item));
        }
        return results;
      }
    };

    return ElementDefinition;

  })(Element);

  module.exports.ElementDefinition = ElementDefinition;


  /** 
  Embedded class
  @class TimingRepeatComponent
  @exports  TimingRepeatComponent as TimingRepeatComponent
   */

  TimingRepeatComponent = (function(superClass) {
    extend(TimingRepeatComponent, superClass);

    function TimingRepeatComponent(json) {
      this.json = json;
      TimingRepeatComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates how often the event should occur.
    @returns {Array} an array of {@link Number} objects
     */

    TimingRepeatComponent.prototype.frequency = function() {
      return this.json['frequency'];
    };


    /**
    Identifies the occurrence of daily life that determines timing.
    @returns {Array} an array of {@link String} objects
     */

    TimingRepeatComponent.prototype.when = function() {
      return this.json['when'];
    };


    /**
    How long each repetition should last.
    @returns {Array} an array of {@link Number} objects
     */

    TimingRepeatComponent.prototype.duration = function() {
      return this.json['duration'];
    };


    /**
    The units of time for the duration.
    @returns {Array} an array of {@link String} objects
     */

    TimingRepeatComponent.prototype.units = function() {
      return this.json['units'];
    };


    /**
    A total count of the desired number of repetitions.
    @returns {Array} an array of {@link Number} objects
     */

    TimingRepeatComponent.prototype.count = function() {
      return this.json['count'];
    };


    /**
    When to stop repeating the timing schedule.
    @returns {Array} an array of {@link Date} objects
     */

    TimingRepeatComponent.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };

    return TimingRepeatComponent;

  })(Element);


  /**
  Specifies an event that may occur multiple times. Timing schedules are used for to record when things are expected or requested to occur.
  @class Timing
  @exports Timing as Timing
   */

  Timing = (function(superClass) {
    extend(Timing, superClass);

    function Timing(json) {
      this.json = json;
      Timing.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies specific time periods when the event should occur.
    @returns {Array} an array of {@link Period} objects
     */

    Timing.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Period(item));
        }
        return results;
      }
    };


    /**
    Identifies a repeating pattern to the intended time periods.
    @returns {TimingRepeatComponent}
     */

    Timing.prototype.repeat = function() {
      if (this.json['repeat']) {
        return new TimingRepeatComponent(this.json['repeat']);
      }
    };

    return Timing;

  })(Element);

  module.exports.Timing = Timing;


  /**
  There is a variety of postal address formats defined around the world. This format defines a superset that is the basis for all addresses around the world.
  @class Address
  @exports Address as Address
   */

  Address = (function(superClass) {
    extend(Address, superClass);

    function Address(json) {
      this.json = json;
      Address.__super__.constructor.call(this, this.json);
    }


    /**
    The purpose of this address.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.use = function() {
      return this.json['use'];
    };


    /**
    A full text representation of the address.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.text = function() {
      return this.json['text'];
    };


    /**
    This component contains the house number, apartment number, street name, street direction, 
    P.O. Box number, delivery hints, and similar address information.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.line = function() {
      return this.json['line'];
    };


    /**
    The name of the city, town, village or other community or delivery center.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.city = function() {
      return this.json['city'];
    };


    /**
    Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes).
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.state = function() {
      return this.json['state'];
    };


    /**
    A postal code designating a region defined by the postal service.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.postalCode = function() {
      return this.json['postalCode'];
    };


    /**
    Country - a nation as commonly understood or generally accepted.
    @returns {Array} an array of {@link String} objects
     */

    Address.prototype.country = function() {
      return this.json['country'];
    };


    /**
    Time period when address was/is in use.
    @returns {Period}
     */

    Address.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return Address;

  })(Element);

  module.exports.Address = Address;


  /**
  A human's name with the ability to identify parts and usage.
  @class HumanName
  @exports HumanName as HumanName
   */

  HumanName = (function(superClass) {
    extend(HumanName, superClass);

    function HumanName(json) {
      this.json = json;
      HumanName.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the purpose for this name.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.use = function() {
      return this.json['use'];
    };


    /**
    A full text representation of the name.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.text = function() {
      return this.json['text'];
    };


    /**
    The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.family = function() {
      return this.json['family'];
    };


    /**
    Given name.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.given = function() {
      return this.json['given'];
    };


    /**
    Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.prefix = function() {
      return this.json['prefix'];
    };


    /**
    Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
    @returns {Array} an array of {@link String} objects
     */

    HumanName.prototype.suffix = function() {
      return this.json['suffix'];
    };


    /**
    Indicates the period of time when this name was valid for the named person.
    @returns {Period}
     */

    HumanName.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return HumanName;

  })(Element);

  module.exports.HumanName = HumanName;


  /**
  Details for All kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
  @class ContactPoint
  @exports ContactPoint as ContactPoint
   */

  ContactPoint = (function(superClass) {
    extend(ContactPoint, superClass);

    function ContactPoint(json) {
      this.json = json;
      ContactPoint.__super__.constructor.call(this, this.json);
    }


    /**
    Telecommunications form for contact point - what communications system is required to make use of the contact.
    @returns {Array} an array of {@link String} objects
     */

    ContactPoint.prototype.system = function() {
      return this.json['system'];
    };


    /**
    The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
    @returns {Array} an array of {@link String} objects
     */

    ContactPoint.prototype.value = function() {
      return this.json['value'];
    };


    /**
    Identifies the purpose for the contact point.
    @returns {Array} an array of {@link String} objects
     */

    ContactPoint.prototype.use = function() {
      return this.json['use'];
    };


    /**
    Time period when the contact point was/is in use.
    @returns {Period}
     */

    ContactPoint.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return ContactPoint;

  })(Element);

  module.exports.ContactPoint = ContactPoint;


  /** 
  Embedded class
  @class ResourceMetaComponent
  @exports  ResourceMetaComponent as ResourceMetaComponent
   */

  ResourceMetaComponent = (function(superClass) {
    extend(ResourceMetaComponent, superClass);

    function ResourceMetaComponent(json) {
      this.json = json;
      ResourceMetaComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The version specific identifier, as it appears in the version portion of the url. This values changes when the resource is created, updated, or deleted.
    @returns {Array} an array of {@link String} objects
     */

    ResourceMetaComponent.prototype.versionId = function() {
      return this.json['versionId'];
    };


    /**
    When the resource last changed - e.g. when the version changed.
    @returns {Array} an array of {@link Date} objects
     */

    ResourceMetaComponent.prototype.lastUpdated = function() {
      if (this.json['lastUpdated']) {
        return DT.DateTime.parse(this.json['lastUpdated']);
      }
    };


    /**
    A list of profiles that this resource claims to conform to. The URL is a reference to Profile.url.
    @returns {Array} an array of {@link String} objects
     */

    ResourceMetaComponent.prototype.profile = function() {
      return this.json['profile'];
    };


    /**
    Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
    @returns {Array} an array of {@link Coding} objects
     */

    ResourceMetaComponent.prototype.security = function() {
      var i, item, len, ref, results;
      if (this.json['security']) {
        ref = this.json['security'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Tags applied to this resource. Tags are intended to to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
    @returns {Array} an array of {@link Coding} objects
     */

    ResourceMetaComponent.prototype.tag = function() {
      var i, item, len, ref, results;
      if (this.json['tag']) {
        ref = this.json['tag'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };

    return ResourceMetaComponent;

  })(BackboneElement);


  /**
  Base Resource for everything.
  @class Resource
  @exports Resource as Resource
   */

  Resource = (function(superClass) {
    extend(Resource, superClass);

    function Resource(json) {
      this.json = json;
      Resource.__super__.constructor.call(this, this.json);
    }


    /**
    The logical id of the resource, as used in the url for the resoure. Once assigned, this value never changes.
    @returns {Array} an array of {@link String} objects
     */

    Resource.prototype.id = function() {
      return this.json['id'];
    };


    /**
    The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.
    @returns {ResourceMetaComponent}
     */

    Resource.prototype.meta = function() {
      if (this.json['meta']) {
        return new ResourceMetaComponent(this.json['meta']);
      }
    };


    /**
    A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content.
    @returns {Array} an array of {@link String} objects
     */

    Resource.prototype.implicitRules = function() {
      return this.json['implicitRules'];
    };


    /**
    The base language in which the resource is written.
    @returns {Array} an array of {@link String} objects
     */

    Resource.prototype.language = function() {
      return this.json['language'];
    };

    return Resource;

  })(Base);

  module.exports.Resource = Resource;


  /**
  
  @class DomainResource
  @exports DomainResource as DomainResource
   */

  DomainResource = (function(superClass) {
    extend(DomainResource, superClass);

    function DomainResource(json) {
      this.json = json;
      DomainResource.__super__.constructor.call(this, this.json);
    }


    /**
    A human-readable narrative that contains a summary of the resource, and may be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
    @returns {Narrative}
     */

    DomainResource.prototype.text = function() {
      if (this.json['text']) {
        return new Narrative(this.json['text']);
      }
    };


    /**
    These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
    @returns {Array} an array of {@link Resource} objects
     */

    DomainResource.prototype.contained = function() {
      var i, item, len, ref, req, results, typeName;
      if (this.json['contained']) {
        ref = this.json['contained'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          typeName = this.json['contained'].resourceType;
          req = require('./' + typeName.toLowerCase())[typeName];
          results.push(new req(item));
        }
        return results;
      }
    };


    /**
    May be used to represent additional information that is not part of the basic definition of the resource. In order to make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
    @returns {Array} an array of {@link Extension} objects
     */

    DomainResource.prototype.extension = function() {
      var i, item, len, ref, results;
      if (this.json['extension']) {
        ref = this.json['extension'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    May be used to represent additional information that is not part of the basic definition of the resource, and that modifies the understanding of the element that contains it. Usually modifier elements provide negation or qualification. In order to make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
    @returns {Array} an array of {@link Extension} objects
     */

    DomainResource.prototype.modifierExtension = function() {
      var i, item, len, ref, results;
      if (this.json['modifierExtension']) {
        ref = this.json['modifierExtension'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };

    return DomainResource;

  })(Resource);

  module.exports.DomainResource = DomainResource;


  /** 
  Embedded class
  @class ParametersParameterComponent
  @exports  ParametersParameterComponent as ParametersParameterComponent
   */

  ParametersParameterComponent = (function(superClass) {
    extend(ParametersParameterComponent, superClass);

    function ParametersParameterComponent(json) {
      this.json = json;
      ParametersParameterComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The name of the parameter (reference to the operation definition).
    @returns {Array} an array of {@link String} objects
     */

    ParametersParameterComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    If the parameter is a data type.
    @returns {Array} an array of {@link } objects
     */

    ParametersParameterComponent.prototype.value = function() {
      return this.json['value'];
    };


    /**
    If the parameter is a whole resource.
    @returns {Resource}
     */

    ParametersParameterComponent.prototype.resource = function() {
      var req, typeName;
      if (this.json['resource']) {
        typeName = this.json['resource'].resourceType;
        req = require('./' + typeName.toLowerCase())[typeName];
        return new req(this.json['resource']);
      }
    };

    return ParametersParameterComponent;

  })(BackboneElement);


  /**
  This special resource type is used to represent [operation](operations.html] request and response. It has no other use, and there is no RESTful end=point associated with it.
  @class Parameters
  @exports Parameters as Parameters
   */

  Parameters = (function(superClass) {
    extend(Parameters, superClass);

    function Parameters(json) {
      this.json = json;
      Parameters.__super__.constructor.call(this, this.json);
    }


    /**
    A parameter passed to or received from the operation.
    @returns {Array} an array of {@link ParametersParameterComponent} objects
     */

    Parameters.prototype.parameter = function() {
      var i, item, len, ref, results;
      if (this.json['parameter']) {
        ref = this.json['parameter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ParametersParameterComponent(item));
        }
        return results;
      }
    };

    return Parameters;

  })(Resource);

  module.exports.Parameters = Parameters;

}).call(this);



},{"../cql-datatypes":2}],57:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, Coverage, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Financial instrument which may be used to pay for or reimburse for health care products and services.
  @class Coverage
  @exports Coverage as Coverage
   */

  Coverage = (function(superClass) {
    extend(Coverage, superClass);

    function Coverage(json) {
      this.json = json;
      Coverage.__super__.constructor.call(this, this.json);
    }


    /**
    The program or plan underwriter or payor.
    @returns {Reference}
     */

    Coverage.prototype.issuer = function() {
      if (this.json['issuer']) {
        return new Reference(this.json['issuer']);
      }
    };


    /**
    Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    @returns {Period}
     */

    Coverage.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health.
    @returns {Coding}
     */

    Coverage.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The main (and possibly only) identifier for the coverage - often referred to as a Subscriber Id, Certificate number or Personal Health Number or Case ID.
    @returns {Array} an array of {@link Identifier} objects
     */

    Coverage.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    @returns {Array} an array of {@link String} objects
     */

    Coverage.prototype.group = function() {
      return this.json['group'];
    };


    /**
    Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    @returns {Array} an array of {@link String} objects
     */

    Coverage.prototype.plan = function() {
      return this.json['plan'];
    };


    /**
    Identifies a sub-style or sub-collective of coverage issues by the underwriter, for example may be used to identify a specific employer group within a class of employers. May be referred to as a Section or Division ID.
    @returns {Array} an array of {@link String} objects
     */

    Coverage.prototype.subplan = function() {
      return this.json['subplan'];
    };


    /**
    A unique identifier for a dependent under the coverage.
    @returns {Array} an array of {@link Number} objects
     */

    Coverage.prototype.dependent = function() {
      return this.json['dependent'];
    };


    /**
    An optional counter for a particular instance of the identified coverage which increments upon each renewal.
    @returns {Array} an array of {@link Number} objects
     */

    Coverage.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The party who 'owns' the insurance contractual relationship to the policy or to whom the benefit of the policy is due.
    @returns {Reference}
     */

    Coverage.prototype.subscriber = function() {
      if (this.json['subscriber']) {
        return new Reference(this.json['subscriber']);
      }
    };


    /**
    The identifier for a community of providers.
    @returns {Identifier}
     */

    Coverage.prototype.network = function() {
      if (this.json['network']) {
        return new Identifier(this.json['network']);
      }
    };


    /**
    The policy(s) which constitute this insurance coverage.
    @returns {Array} an array of {@link Reference} objects
     */

    Coverage.prototype.contract = function() {
      var i, item, len, ref, results;
      if (this.json['contract']) {
        ref = this.json['contract'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return Coverage;

  })(DomainResource);

  module.exports.Coverage = Coverage;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],58:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DataElement, DataElementBindingComponent, DataElementMappingComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DataElementBindingComponent
  @exports  DataElementBindingComponent as DataElementBindingComponent
   */

  DataElementBindingComponent = (function(superClass) {
    extend(DataElementBindingComponent, superClass);

    function DataElementBindingComponent(json) {
      this.json = json;
      DataElementBindingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    @returns {Array} an array of {@link boolean} objects
     */

    DataElementBindingComponent.prototype.isExtensible = function() {
      return this.json['isExtensible'];
    };


    /**
    Indicates the degree of conformance expectations associated with this binding.
    @returns {Array} an array of {@link String} objects
     */

    DataElementBindingComponent.prototype.conformance = function() {
      return this.json['conformance'];
    };


    /**
    Describes the intended use of this particular set of codes.
    @returns {Array} an array of {@link String} objects
     */

    DataElementBindingComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Points to the value set that identifies the set of codes to be used.
    @returns {Reference}
     */

    DataElementBindingComponent.prototype.valueSet = function() {
      if (this.json['valueSet']) {
        return new Reference(this.json['valueSet']);
      }
    };

    return DataElementBindingComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DataElementMappingComponent
  @exports  DataElementMappingComponent as DataElementMappingComponent
   */

  DataElementMappingComponent = (function(superClass) {
    extend(DataElementMappingComponent, superClass);

    function DataElementMappingComponent(json) {
      this.json = json;
      DataElementMappingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A URI that identifies the specification that this mapping is expressed to.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.uri = function() {
      return this.json['uri'];
    };


    /**
    If true, indicates that the official meaning of the data element is exactly equivalent to the mapped element.
    @returns {Array} an array of {@link boolean} objects
     */

    DataElementMappingComponent.prototype.definitional = function() {
      return this.json['definitional'];
    };


    /**
    A name for the specification that is being mapped to.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    Expresses what part of the target specification corresponds to this element.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.map = function() {
      return this.json['map'];
    };

    return DataElementMappingComponent;

  })(BackboneElement);


  /**
  The formal description of a single piece of information that can be gathered and reported.
  @class DataElement
  @exports DataElement as DataElement
   */

  DataElement = (function(superClass) {
    extend(DataElement, superClass);

    function DataElement(json) {
      this.json = json;
      DataElement.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this data element when it is referenced in a Profile, Questionnaire or an instance.
    @returns {Identifier}
     */

    DataElement.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The identifier that is used to identify this version of the data element when it is referenced in a Profile, Questionnaire or instance. This is an arbitrary value managed by the definition author manually.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    DataElement.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    The status of the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The date that this version of the data element was published.
    @returns {Array} an array of {@link Date} objects
     */

    DataElement.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The term used by humans to refer to the data element.  Should ideally be unique within the context in which the data element is expected to be used.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.name = function() {
      return this.json['name'];
    };


    /**
    A set of terms from external terminologies that may be used to assist with indexing and searching of data element definitions.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DataElement.prototype.category = function() {
      var i, item, len, ref, results;
      if (this.json['category']) {
        ref = this.json['category'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A code that provides the meaning for a data element according to a particular terminology.
    @returns {Array} an array of {@link Coding} objects
     */

    DataElement.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    The default/suggested phrasing to use when prompting a human to capture the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.question = function() {
      return this.json['question'];
    };


    /**
    Provides a complete explanation of the meaning of the data element for human readability.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.definition = function() {
      return this.json['definition'];
    };


    /**
    Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    Explains why this element is needed and why it's been constrained as it has.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    Identifies additional names by which this element might also be known.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.synonym = function() {
      return this.json['synonym'];
    };


    /**
    The FHIR data type that is the type for this element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.type = function() {
      return this.json['type'];
    };


    /**
    An sample value for this element demonstrating the type of information that would typically be captured.
    @returns {Array} an array of {@link } objects
     */

    DataElement.prototype.example = function() {
      return this.json['example'];
    };


    /**
    Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    @returns {Array} an array of {@link Number} objects
     */

    DataElement.prototype.maxLength = function() {
      return this.json['maxLength'];
    };


    /**
    Identifies the units of measure in which the data element should be captured or expressed.
    @returns {CodeableConcept}
     */

    DataElement.prototype.units = function() {
      if (this.json['units']) {
        return new CodeableConcept(this.json['units']);
      }
    };


    /**
    Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    @returns {DataElementBindingComponent}
     */

    DataElement.prototype.binding = function() {
      if (this.json['binding']) {
        return new DataElementBindingComponent(this.json['binding']);
      }
    };


    /**
    Identifies a concept from an external specification that roughly corresponds to this element.
    @returns {Array} an array of {@link DataElementMappingComponent} objects
     */

    DataElement.prototype.mapping = function() {
      var i, item, len, ref, results;
      if (this.json['mapping']) {
        ref = this.json['mapping'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DataElementMappingComponent(item));
        }
        return results;
      }
    };

    return DataElement;

  })(DomainResource);

  module.exports.DataElement = DataElement;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],59:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, Device, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource identifies an instance of a manufactured thing that is used in the provision of healthcare without being substantially changed through that activity. The device may be a machine, an insert, a computer, an application, etc. This includes durable (reusable) medical equipment as well as disposable equipment used for diagnostic, treatment, and research for healthcare and public health.
  @class Device
  @exports Device as Device
   */

  Device = (function(superClass) {
    extend(Device, superClass);

    function Device(json) {
      this.json = json;
      Device.__super__.constructor.call(this, this.json);
    }


    /**
    Identifiers assigned to this device by various organizations. The most likely organizations to assign identifiers are the manufacturer and the owner, though regulatory agencies may also assign an identifier. The identifiers identify the particular device, not the kind of device.
    @returns {Array} an array of {@link Identifier} objects
     */

    Device.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A kind of this device.
    @returns {CodeableConcept}
     */

    Device.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    A name of the manufacturer.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.manufacturer = function() {
      return this.json['manufacturer'];
    };


    /**
    The "model" - an identifier assigned by the manufacturer to identify the product by its type. This number is shared by the all devices sold as the same type.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.model = function() {
      return this.json['model'];
    };


    /**
    The version of the device, if the device has multiple releases under the same model, or if the device is software or carries firmware.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Date of expiry of this device (if applicable).
    @returns {Array} an array of {@link Date} objects
     */

    Device.prototype.expiry = function() {
      if (this.json['expiry']) {
        return DT.DateTime.parse(this.json['expiry']);
      }
    };


    /**
    FDA Mandated Unique Device Identifier. Use the human readable information (the content that the user sees, which is sometimes different to the exact syntax represented in the barcode)  - see http://www.fda.gov/MedicalDevices/DeviceRegulationandGuidance/UniqueDeviceIdentification/default.htm.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.udi = function() {
      return this.json['udi'];
    };


    /**
    Lot number assigned by the manufacturer.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.lotNumber = function() {
      return this.json['lotNumber'];
    };


    /**
    An organization that is responsible for the provision and ongoing maintenance of the device.
    @returns {Reference}
     */

    Device.prototype.owner = function() {
      if (this.json['owner']) {
        return new Reference(this.json['owner']);
      }
    };


    /**
    The resource may be found in a literal location (i.e. GPS coordinates), a logical place (i.e. "in/with the patient"), or a coded location.
    @returns {Reference}
     */

    Device.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Patient information, if the resource is affixed to a person.
    @returns {Reference}
     */

    Device.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Contact details for an organization or a particular human that is responsible for the device.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Device.prototype.contact = function() {
      var i, item, len, ref, results;
      if (this.json['contact']) {
        ref = this.json['contact'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A network address on which the device may be contacted directly.
    @returns {Array} an array of {@link String} objects
     */

    Device.prototype.url = function() {
      return this.json['url'];
    };

    return Device;

  })(DomainResource);

  module.exports.Device = Device;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],60:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DeviceComponent, DeviceComponentProductionSpecificationComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DeviceComponentProductionSpecificationComponent
  @exports  DeviceComponentProductionSpecificationComponent as DeviceComponentProductionSpecificationComponent
   */

  DeviceComponentProductionSpecificationComponent = (function(superClass) {
    extend(DeviceComponentProductionSpecificationComponent, superClass);

    function DeviceComponentProductionSpecificationComponent(json) {
      this.json = json;
      DeviceComponentProductionSpecificationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Describes the specification type, such as, serial number, part number, hardware revision, software revision, etc.
    @returns {CodeableConcept}
     */

    DeviceComponentProductionSpecificationComponent.prototype.specType = function() {
      if (this.json['specType']) {
        return new CodeableConcept(this.json['specType']);
      }
    };


    /**
    Describes the internal component unique identification. This is a provision for manufacture specific standard components using a private OID. 11073-10101 has a partition for private OID semantic that the manufacture can make use of.
    @returns {Identifier}
     */

    DeviceComponentProductionSpecificationComponent.prototype.componentId = function() {
      if (this.json['componentId']) {
        return new Identifier(this.json['componentId']);
      }
    };


    /**
    Describes the printable string defining the component.
    @returns {Array} an array of {@link String} objects
     */

    DeviceComponentProductionSpecificationComponent.prototype.productionSpec = function() {
      return this.json['productionSpec'];
    };

    return DeviceComponentProductionSpecificationComponent;

  })(BackboneElement);


  /**
  Describes the characteristics, operational status and capabilities of a medical-related component of a medical device.
  @class DeviceComponent
  @exports DeviceComponent as DeviceComponent
   */

  DeviceComponent = (function(superClass) {
    extend(DeviceComponent, superClass);

    function DeviceComponent(json) {
      this.json = json;
      DeviceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Describes the specific component type as defined in the object-oriented or metric nomenclature partition.
    @returns {CodeableConcept}
     */

    DeviceComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Describes the local assigned unique identification by the software. For example: handle ID.
    @returns {Identifier}
     */

    DeviceComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Describes the timestamp for the most recent system change which includes device configuration or setting change.
    @returns {Array} an array of {@link Date} objects
     */

    DeviceComponent.prototype.lastSystemChange = function() {
      if (this.json['lastSystemChange']) {
        return DT.DateTime.parse(this.json['lastSystemChange']);
      }
    };


    /**
    Describes the link to the source Device that contains administrative device information such as manufacture, serial number, etc.
    @returns {Reference}
     */

    DeviceComponent.prototype.source = function() {
      if (this.json['source']) {
        return new Reference(this.json['source']);
      }
    };


    /**
    Describes the link to the parent resource. For example: Channel is linked to its VMD parent.
    @returns {Reference}
     */

    DeviceComponent.prototype.parent = function() {
      if (this.json['parent']) {
        return new Reference(this.json['parent']);
      }
    };


    /**
    Indicates current operational status of the device. For example: On, Off, Standby, etc.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceComponent.prototype.operationalStatus = function() {
      var i, item, len, ref, results;
      if (this.json['operationalStatus']) {
        ref = this.json['operationalStatus'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Describes the parameter group supported by the current device component that is based on some nomenclature, e.g., cardiovascular.
    @returns {CodeableConcept}
     */

    DeviceComponent.prototype.parameterGroup = function() {
      if (this.json['parameterGroup']) {
        return new CodeableConcept(this.json['parameterGroup']);
      }
    };


    /**
    Describes the physical principle of the measurement. For example: thermal, chemical, acoustical, etc.
    @returns {Array} an array of {@link String} objects
     */

    DeviceComponent.prototype.measurementPrinciple = function() {
      return this.json['measurementPrinciple'];
    };


    /**
    Describes the production specification such as component revision, serial number, etc.
    @returns {Array} an array of {@link DeviceComponentProductionSpecificationComponent} objects
     */

    DeviceComponent.prototype.productionSpecification = function() {
      var i, item, len, ref, results;
      if (this.json['productionSpecification']) {
        ref = this.json['productionSpecification'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DeviceComponentProductionSpecificationComponent(item));
        }
        return results;
      }
    };


    /**
    Describes the language code for the human-readable text string produced by the device. This language code will follow the IETF language tag. Example: en-US.
    @returns {CodeableConcept}
     */

    DeviceComponent.prototype.languageCode = function() {
      if (this.json['languageCode']) {
        return new CodeableConcept(this.json['languageCode']);
      }
    };

    return DeviceComponent;

  })(DomainResource);

  module.exports.DeviceComponent = DeviceComponent;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],61:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DeviceUseRequest, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Represents a request for the use of a device.
  @class DeviceUseRequest
  @exports DeviceUseRequest as DeviceUseRequest
   */

  DeviceUseRequest = (function(superClass) {
    extend(DeviceUseRequest, superClass);

    function DeviceUseRequest(json) {
      this.json = json;
      DeviceUseRequest.__super__.constructor.call(this, this.json);
    }


    /**
    Body site where the device is to be used.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceUseRequest.prototype.bodySite = function() {
      var i, item, len, ref, results;
      if (this.json['bodySite']) {
        ref = this.json['bodySite'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The status of the request.
    @returns {Array} an array of {@link String} objects
     */

    DeviceUseRequest.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The mode of the request.
    @returns {Array} an array of {@link String} objects
     */

    DeviceUseRequest.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    The details of the device  to be used.
    @returns {Reference}
     */

    DeviceUseRequest.prototype.device = function() {
      if (this.json['device']) {
        return new Reference(this.json['device']);
      }
    };


    /**
    An encounter that provides additional context in which this request is made.
    @returns {Reference}
     */

    DeviceUseRequest.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Identifiers assigned to this order by the orderer or by the receiver.
    @returns {Array} an array of {@link Identifier} objects
     */

    DeviceUseRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Reason or justification for the use of this device.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceUseRequest.prototype.indication = function() {
      var i, item, len, ref, results;
      if (this.json['indication']) {
        ref = this.json['indication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Details about this request that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    @returns {Array} an array of {@link String} objects
     */

    DeviceUseRequest.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    The proposed act must be performed if the indicated conditions occur, e.g.., shortness of breath, SpO2 less than x%.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceUseRequest.prototype.prnReason = function() {
      var i, item, len, ref, results;
      if (this.json['prnReason']) {
        ref = this.json['prnReason'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The time when the request was made.
    @returns {Array} an array of {@link Date} objects
     */

    DeviceUseRequest.prototype.orderedOn = function() {
      if (this.json['orderedOn']) {
        return DT.DateTime.parse(this.json['orderedOn']);
      }
    };


    /**
    The time at which the request was made/recorded.
    @returns {Array} an array of {@link Date} objects
     */

    DeviceUseRequest.prototype.recordedOn = function() {
      if (this.json['recordedOn']) {
        return DT.DateTime.parse(this.json['recordedOn']);
      }
    };


    /**
    The patient who will use the device.
    @returns {Reference}
     */

    DeviceUseRequest.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The timing schedule for the use of the device The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Timing}
     */

    DeviceUseRequest.prototype.timingTiming = function() {
      if (this.json['timingTiming']) {
        return new Timing(this.json['timingTiming']);
      }
    };


    /**
    The timing schedule for the use of the device The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Period}
     */

    DeviceUseRequest.prototype.timingPeriod = function() {
      if (this.json['timingPeriod']) {
        return new Period(this.json['timingPeriod']);
      }
    };


    /**
    The timing schedule for the use of the device The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Array} an array of {@link Date} objects
     */

    DeviceUseRequest.prototype.timingDateTime = function() {
      if (this.json['timingDateTime']) {
        return DT.DateTime.parse(this.json['timingDateTime']);
      }
    };


    /**
    Characterizes how quickly the  use of device must be initiated. Includes concepts such as stat, urgent, routine.
    @returns {Array} an array of {@link String} objects
     */

    DeviceUseRequest.prototype.priority = function() {
      return this.json['priority'];
    };

    return DeviceUseRequest;

  })(DomainResource);

  module.exports.DeviceUseRequest = DeviceUseRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],62:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DeviceUseStatement, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.
  @class DeviceUseStatement
  @exports DeviceUseStatement as DeviceUseStatement
   */

  DeviceUseStatement = (function(superClass) {
    extend(DeviceUseStatement, superClass);

    function DeviceUseStatement(json) {
      this.json = json;
      DeviceUseStatement.__super__.constructor.call(this, this.json);
    }


    /**
    Body site where the device was used.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceUseStatement.prototype.bodySite = function() {
      var i, item, len, ref, results;
      if (this.json['bodySite']) {
        ref = this.json['bodySite'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The time period over which the device was used.
    @returns {Period}
     */

    DeviceUseStatement.prototype.whenUsed = function() {
      if (this.json['whenUsed']) {
        return new Period(this.json['whenUsed']);
      }
    };


    /**
    The details of the device used.
    @returns {Reference}
     */

    DeviceUseStatement.prototype.device = function() {
      if (this.json['device']) {
        return new Reference(this.json['device']);
      }
    };


    /**
    An external identifier for this statement such as an IRI.
    @returns {Array} an array of {@link Identifier} objects
     */

    DeviceUseStatement.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Reason or justification for the use of the device.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DeviceUseStatement.prototype.indication = function() {
      var i, item, len, ref, results;
      if (this.json['indication']) {
        ref = this.json['indication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    @returns {Array} an array of {@link String} objects
     */

    DeviceUseStatement.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    The time at which the statement was made/recorded.
    @returns {Array} an array of {@link Date} objects
     */

    DeviceUseStatement.prototype.recordedOn = function() {
      if (this.json['recordedOn']) {
        return DT.DateTime.parse(this.json['recordedOn']);
      }
    };


    /**
    The patient who used the device.
    @returns {Reference}
     */

    DeviceUseStatement.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    How often the device was used.
    @returns {Timing}
     */

    DeviceUseStatement.prototype.timingTiming = function() {
      if (this.json['timingTiming']) {
        return new Timing(this.json['timingTiming']);
      }
    };


    /**
    How often the device was used.
    @returns {Period}
     */

    DeviceUseStatement.prototype.timingPeriod = function() {
      if (this.json['timingPeriod']) {
        return new Period(this.json['timingPeriod']);
      }
    };


    /**
    How often the device was used.
    @returns {Array} an array of {@link Date} objects
     */

    DeviceUseStatement.prototype.timingDateTime = function() {
      if (this.json['timingDateTime']) {
        return DT.DateTime.parse(this.json['timingDateTime']);
      }
    };

    return DeviceUseStatement;

  })(DomainResource);

  module.exports.DeviceUseStatement = DeviceUseStatement;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],63:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DiagnosticOrder, DiagnosticOrderEventComponent, DiagnosticOrderItemComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DiagnosticOrderEventComponent
  @exports  DiagnosticOrderEventComponent as DiagnosticOrderEventComponent
   */

  DiagnosticOrderEventComponent = (function(superClass) {
    extend(DiagnosticOrderEventComponent, superClass);

    function DiagnosticOrderEventComponent(json) {
      this.json = json;
      DiagnosticOrderEventComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The status for the event.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticOrderEventComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Additional information about the event that occurred - e.g. if the status remained unchanged.
    @returns {CodeableConcept}
     */

    DiagnosticOrderEventComponent.prototype.description = function() {
      if (this.json['description']) {
        return new CodeableConcept(this.json['description']);
      }
    };


    /**
    The date/time at which the event occurred.
    @returns {Array} an array of {@link Date} objects
     */

    DiagnosticOrderEventComponent.prototype.dateTime = function() {
      if (this.json['dateTime']) {
        return DT.DateTime.parse(this.json['dateTime']);
      }
    };


    /**
    The person who was responsible for performing or recording the action.
    @returns {Reference}
     */

    DiagnosticOrderEventComponent.prototype.actor = function() {
      if (this.json['actor']) {
        return new Reference(this.json['actor']);
      }
    };

    return DiagnosticOrderEventComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DiagnosticOrderItemComponent
  @exports  DiagnosticOrderItemComponent as DiagnosticOrderItemComponent
   */

  DiagnosticOrderItemComponent = (function(superClass) {
    extend(DiagnosticOrderItemComponent, superClass);

    function DiagnosticOrderItemComponent(json) {
      this.json = json;
      DiagnosticOrderItemComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code that identifies a particular diagnostic investigation, or panel of investigations, that have been requested.
    @returns {CodeableConcept}
     */

    DiagnosticOrderItemComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    If the item is related to a specific speciment.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticOrderItemComponent.prototype.specimen = function() {
      var i, item, len, ref, results;
      if (this.json['specimen']) {
        ref = this.json['specimen'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Anatomical location where the request test should be performed.
    @returns {CodeableConcept}
     */

    DiagnosticOrderItemComponent.prototype.bodySite = function() {
      if (this.json['bodySite']) {
        return new CodeableConcept(this.json['bodySite']);
      }
    };


    /**
    The status of this individual item within the order.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticOrderItemComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    A summary of the events of interest that have occurred as this item of the request is processed.
    @returns {Array} an array of {@link DiagnosticOrderEventComponent} objects
     */

    DiagnosticOrderItemComponent.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DiagnosticOrderEventComponent(item));
        }
        return results;
      }
    };

    return DiagnosticOrderItemComponent;

  })(BackboneElement);


  /**
  A request for a diagnostic investigation service to be performed.
  @class DiagnosticOrder
  @exports DiagnosticOrder as DiagnosticOrder
   */

  DiagnosticOrder = (function(superClass) {
    extend(DiagnosticOrder, superClass);

    function DiagnosticOrder(json) {
      this.json = json;
      DiagnosticOrder.__super__.constructor.call(this, this.json);
    }


    /**
    Who or what the investigation is to be performed on. This is usually a human patient, but diagnostic tests can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans).
    @returns {Reference}
     */

    DiagnosticOrder.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The practitioner that holds legal responsibility for ordering the investigation.
    @returns {Reference}
     */

    DiagnosticOrder.prototype.orderer = function() {
      if (this.json['orderer']) {
        return new Reference(this.json['orderer']);
      }
    };


    /**
    Identifiers assigned to this order by the order or by the receiver.
    @returns {Array} an array of {@link Identifier} objects
     */

    DiagnosticOrder.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    An encounter that provides additional information about the healthcare context in which this request is made.
    @returns {Reference}
     */

    DiagnosticOrder.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    An explanation or justification for why this diagnostic investigation is being requested.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticOrder.prototype.clinicalNotes = function() {
      return this.json['clinicalNotes'];
    };


    /**
    Additional clinical information about the patient or specimen that may influence test interpretations.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticOrder.prototype.supportingInformation = function() {
      var i, item, len, ref, results;
      if (this.json['supportingInformation']) {
        ref = this.json['supportingInformation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    One or more specimens that the diagnostic investigation is about.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticOrder.prototype.specimen = function() {
      var i, item, len, ref, results;
      if (this.json['specimen']) {
        ref = this.json['specimen'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The status of the order.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticOrder.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The clinical priority associated with this order.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticOrder.prototype.priority = function() {
      return this.json['priority'];
    };


    /**
    A summary of the events of interest that have occurred as the request is processed. E.g. when the order was made, various processing steps (specimens received), when it was completed.
    @returns {Array} an array of {@link DiagnosticOrderEventComponent} objects
     */

    DiagnosticOrder.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DiagnosticOrderEventComponent(item));
        }
        return results;
      }
    };


    /**
    The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
    @returns {Array} an array of {@link DiagnosticOrderItemComponent} objects
     */

    DiagnosticOrder.prototype.item = function() {
      var i, item, len, ref, results;
      if (this.json['item']) {
        ref = this.json['item'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DiagnosticOrderItemComponent(item));
        }
        return results;
      }
    };

    return DiagnosticOrder;

  })(DomainResource);

  module.exports.DiagnosticOrder = DiagnosticOrder;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],64:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DiagnosticReport, DiagnosticReportImageComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DiagnosticReportImageComponent
  @exports  DiagnosticReportImageComponent as DiagnosticReportImageComponent
   */

  DiagnosticReportImageComponent = (function(superClass) {
    extend(DiagnosticReportImageComponent, superClass);

    function DiagnosticReportImageComponent(json) {
      this.json = json;
      DiagnosticReportImageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticReportImageComponent.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    Reference to the image source.
    @returns {Reference}
     */

    DiagnosticReportImageComponent.prototype.link = function() {
      if (this.json['link']) {
        return new Reference(this.json['link']);
      }
    };

    return DiagnosticReportImageComponent;

  })(BackboneElement);


  /**
  The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretation, and formatted representation of diagnostic reports.
  @class DiagnosticReport
  @exports DiagnosticReport as DiagnosticReport
   */

  DiagnosticReport = (function(superClass) {
    extend(DiagnosticReport, superClass);

    function DiagnosticReport(json) {
      this.json = json;
      DiagnosticReport.__super__.constructor.call(this, this.json);
    }


    /**
    A code or name that describes this diagnostic report.
    @returns {CodeableConcept}
     */

    DiagnosticReport.prototype.name = function() {
      if (this.json['name']) {
        return new CodeableConcept(this.json['name']);
      }
    };


    /**
    The status of the diagnostic report as a whole.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticReport.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The date and/or time that this version of the report was released from the source diagnostic service.
    @returns {Array} an array of {@link Date} objects
     */

    DiagnosticReport.prototype.issued = function() {
      if (this.json['issued']) {
        return DT.DateTime.parse(this.json['issued']);
      }
    };


    /**
    The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources.
    @returns {Reference}
     */

    DiagnosticReport.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The diagnostic service that is responsible for issuing the report.
    @returns {Reference}
     */

    DiagnosticReport.prototype.performer = function() {
      if (this.json['performer']) {
        return new Reference(this.json['performer']);
      }
    };


    /**
    The local ID assigned to the report by the order filler, usually by the Information System of the diagnostic service provider.
    @returns {Identifier}
     */

    DiagnosticReport.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Details concerning a test requested.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticReport.prototype.requestDetail = function() {
      var i, item, len, ref, results;
      if (this.json['requestDetail']) {
        ref = this.json['requestDetail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The section of the diagnostic service that performs the examination e.g. biochemistry, hematology, MRI.
    @returns {CodeableConcept}
     */

    DiagnosticReport.prototype.serviceCategory = function() {
      if (this.json['serviceCategory']) {
        return new CodeableConcept(this.json['serviceCategory']);
      }
    };


    /**
    The time or time-period the observed values are related to. This is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    @returns {Array} an array of {@link Date} objects
     */

    DiagnosticReport.prototype.diagnosticDateTime = function() {
      if (this.json['diagnosticDateTime']) {
        return DT.DateTime.parse(this.json['diagnosticDateTime']);
      }
    };


    /**
    The time or time-period the observed values are related to. This is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    @returns {Period}
     */

    DiagnosticReport.prototype.diagnosticPeriod = function() {
      if (this.json['diagnosticPeriod']) {
        return new Period(this.json['diagnosticPeriod']);
      }
    };


    /**
    Details about the specimens on which this Disagnostic report is based.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticReport.prototype.specimen = function() {
      var i, item, len, ref, results;
      if (this.json['specimen']) {
        ref = this.json['specimen'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Observations that are part of this diagnostic report. Observations can be simple name/value pairs (e.g. "atomic" results), or they can be grouping observations that include references to other members of the group (e.g. "panels").
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticReport.prototype.result = function() {
      var i, item, len, ref, results;
      if (this.json['result']) {
        ref = this.json['result'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    @returns {Array} an array of {@link Reference} objects
     */

    DiagnosticReport.prototype.imagingStudy = function() {
      var i, item, len, ref, results;
      if (this.json['imagingStudy']) {
        ref = this.json['imagingStudy'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    @returns {Array} an array of {@link DiagnosticReportImageComponent} objects
     */

    DiagnosticReport.prototype.image = function() {
      var i, item, len, ref, results;
      if (this.json['image']) {
        ref = this.json['image'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DiagnosticReportImageComponent(item));
        }
        return results;
      }
    };


    /**
    Concise and clinically contextualized narrative interpretation of the diagnostic report.
    @returns {Array} an array of {@link String} objects
     */

    DiagnosticReport.prototype.conclusion = function() {
      return this.json['conclusion'];
    };


    /**
    Codes for the conclusion.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DiagnosticReport.prototype.codedDiagnosis = function() {
      var i, item, len, ref, results;
      if (this.json['codedDiagnosis']) {
        ref = this.json['codedDiagnosis'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Rich text representation of the entire result as issued by the diagnostic service. Multiple formats are allowed but they SHALL be semantically equivalent.
    @returns {Array} an array of {@link Attachment} objects
     */

    DiagnosticReport.prototype.presentedForm = function() {
      var i, item, len, ref, results;
      if (this.json['presentedForm']) {
        ref = this.json['presentedForm'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Attachment(item));
        }
        return results;
      }
    };

    return DiagnosticReport;

  })(DomainResource);

  module.exports.DiagnosticReport = DiagnosticReport;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],65:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DocumentManifest, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A manifest that defines a set of documents.
  @class DocumentManifest
  @exports DocumentManifest as DocumentManifest
   */

  DocumentManifest = (function(superClass) {
    extend(DocumentManifest, superClass);

    function DocumentManifest(json) {
      this.json = json;
      DocumentManifest.__super__.constructor.call(this, this.json);
    }


    /**
    A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts.
    @returns {Identifier}
     */

    DocumentManifest.prototype.masterIdentifier = function() {
      if (this.json['masterIdentifier']) {
        return new Identifier(this.json['masterIdentifier']);
      }
    };


    /**
    Other identifiers associated with the document, including version independent, source record and workflow related identifiers.
    @returns {Array} an array of {@link Identifier} objects
     */

    DocumentManifest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case).
    @returns {Array} an array of {@link Reference} objects
     */

    DocumentManifest.prototype.subject = function() {
      var i, item, len, ref, results;
      if (this.json['subject']) {
        ref = this.json['subject'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A patient, practitioner, or organization for which this set of documents is intended.
    @returns {Array} an array of {@link Reference} objects
     */

    DocumentManifest.prototype.recipient = function() {
      var i, item, len, ref, results;
      if (this.json['recipient']) {
        ref = this.json['recipient'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Specifies the kind of this set of documents (e.g. Patient Summary, Discharge Summary, Prescription, etc.). The type of a set of documents may be the same as one of the documents in it - especially if there is only one - but it may be wider.
    @returns {CodeableConcept}
     */

    DocumentManifest.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Identifies who is responsible for adding the information to the document.
    @returns {Array} an array of {@link Reference} objects
     */

    DocumentManifest.prototype.author = function() {
      var i, item, len, ref, results;
      if (this.json['author']) {
        ref = this.json['author'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated etc).
    @returns {Array} an array of {@link Date} objects
     */

    DocumentManifest.prototype.created = function() {
      if (this.json['created']) {
        return DT.DateTime.parse(this.json['created']);
      }
    };


    /**
    Identifies the source system, application, or software that produced the document manifest.
    @returns {Array} an array of {@link String} objects
     */

    DocumentManifest.prototype.source = function() {
      return this.json['source'];
    };


    /**
    The status of this document manifest.
    @returns {Array} an array of {@link String} objects
     */

    DocumentManifest.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Whether this document manifest replaces another.
    @returns {Reference}
     */

    DocumentManifest.prototype.supercedes = function() {
      if (this.json['supercedes']) {
        return new Reference(this.json['supercedes']);
      }
    };


    /**
    Human-readable description of the source document. This is sometimes known as the "title".
    @returns {Array} an array of {@link String} objects
     */

    DocumentManifest.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A code specifying the level of confidentiality of this set of Documents.
    @returns {CodeableConcept}
     */

    DocumentManifest.prototype.confidentiality = function() {
      if (this.json['confidentiality']) {
        return new CodeableConcept(this.json['confidentiality']);
      }
    };


    /**
    The list of resources that describe the parts of this document reference. Usually, these would be document references, but direct references to binary attachments and images are also allowed.
    @returns {Array} an array of {@link Reference} objects
     */

    DocumentManifest.prototype.content = function() {
      var i, item, len, ref, results;
      if (this.json['content']) {
        ref = this.json['content'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return DocumentManifest;

  })(DomainResource);

  module.exports.DocumentManifest = DocumentManifest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],66:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DocumentReference, DocumentReferenceContextComponent, DocumentReferenceRelatesToComponent, DocumentReferenceServiceComponent, DocumentReferenceServiceParameterComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DocumentReferenceRelatesToComponent
  @exports  DocumentReferenceRelatesToComponent as DocumentReferenceRelatesToComponent
   */

  DocumentReferenceRelatesToComponent = (function(superClass) {
    extend(DocumentReferenceRelatesToComponent, superClass);

    function DocumentReferenceRelatesToComponent(json) {
      this.json = json;
      DocumentReferenceRelatesToComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The type of relationship that this document has with anther document.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReferenceRelatesToComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    The target document of this relationship.
    @returns {Reference}
     */

    DocumentReferenceRelatesToComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return DocumentReferenceRelatesToComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DocumentReferenceServiceParameterComponent
  @exports  DocumentReferenceServiceParameterComponent as DocumentReferenceServiceParameterComponent
   */

  DocumentReferenceServiceParameterComponent = (function(superClass) {
    extend(DocumentReferenceServiceParameterComponent, superClass);

    function DocumentReferenceServiceParameterComponent(json) {
      this.json = json;
      DocumentReferenceServiceParameterComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The name of a parameter.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReferenceServiceParameterComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    The value of the named parameter.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReferenceServiceParameterComponent.prototype.value = function() {
      return this.json['value'];
    };

    return DocumentReferenceServiceParameterComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DocumentReferenceServiceComponent
  @exports  DocumentReferenceServiceComponent as DocumentReferenceServiceComponent
   */

  DocumentReferenceServiceComponent = (function(superClass) {
    extend(DocumentReferenceServiceComponent, superClass);

    function DocumentReferenceServiceComponent(json) {
      this.json = json;
      DocumentReferenceServiceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The type of the service that can be used to access the documents.
    @returns {CodeableConcept}
     */

    DocumentReferenceServiceComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Where the service end-point is located.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReferenceServiceComponent.prototype.address = function() {
      return this.json['address'];
    };


    /**
    A list of named parameters that is used in the service call.
    @returns {Array} an array of {@link DocumentReferenceServiceParameterComponent} objects
     */

    DocumentReferenceServiceComponent.prototype.parameter = function() {
      var i, item, len, ref, results;
      if (this.json['parameter']) {
        ref = this.json['parameter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DocumentReferenceServiceParameterComponent(item));
        }
        return results;
      }
    };

    return DocumentReferenceServiceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DocumentReferenceContextComponent
  @exports  DocumentReferenceContextComponent as DocumentReferenceContextComponent
   */

  DocumentReferenceContextComponent = (function(superClass) {
    extend(DocumentReferenceContextComponent, superClass);

    function DocumentReferenceContextComponent(json) {
      this.json = json;
      DocumentReferenceContextComponent.__super__.constructor.call(this, this.json);
    }


    /**
    This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DocumentReferenceContextComponent.prototype.event = function() {
      var i, item, len, ref, results;
      if (this.json['event']) {
        ref = this.json['event'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The time period over which the service that is described by the document was provided.
    @returns {Period}
     */

    DocumentReferenceContextComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    The kind of facility where the patient was seen.
    @returns {CodeableConcept}
     */

    DocumentReferenceContextComponent.prototype.facilityType = function() {
      if (this.json['facilityType']) {
        return new CodeableConcept(this.json['facilityType']);
      }
    };

    return DocumentReferenceContextComponent;

  })(BackboneElement);


  /**
  A reference to a document.
  @class DocumentReference
  @exports DocumentReference as DocumentReference
   */

  DocumentReference = (function(superClass) {
    extend(DocumentReference, superClass);

    function DocumentReference(json) {
      this.json = json;
      DocumentReference.__super__.constructor.call(this, this.json);
    }


    /**
    Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document.
    @returns {Identifier}
     */

    DocumentReference.prototype.masterIdentifier = function() {
      if (this.json['masterIdentifier']) {
        return new Identifier(this.json['masterIdentifier']);
      }
    };


    /**
    Other identifiers associated with the document, including version independent, source record and workflow related identifiers.
    @returns {Array} an array of {@link Identifier} objects
     */

    DocumentReference.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (I.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure).
    @returns {Reference}
     */

    DocumentReference.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Specifies the particular kind of document (e.g. Patient Summary, Discharge Summary, Prescription, etc.).
    @returns {CodeableConcept}
     */

    DocumentReference.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    A categorization for the type of the document. This may be implied by or derived from the code specified in the Document Type.
    @returns {CodeableConcept}
     */

    DocumentReference.prototype["class"] = function() {
      if (this.json['class']) {
        return new CodeableConcept(this.json['class']);
      }
    };


    /**
    Identifies who is responsible for adding the information to the document.
    @returns {Array} an array of {@link Reference} objects
     */

    DocumentReference.prototype.author = function() {
      var i, item, len, ref, results;
      if (this.json['author']) {
        ref = this.json['author'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Identifies the organization or group who is responsible for ongoing maintenance of and access to the document.
    @returns {Reference}
     */

    DocumentReference.prototype.custodian = function() {
      if (this.json['custodian']) {
        return new Reference(this.json['custodian']);
      }
    };


    /**
    A reference to a domain or server that manages policies under which the document is accessed and/or made available.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.policyManager = function() {
      return this.json['policyManager'];
    };


    /**
    Which person or organization authenticates that this document is valid.
    @returns {Reference}
     */

    DocumentReference.prototype.authenticator = function() {
      if (this.json['authenticator']) {
        return new Reference(this.json['authenticator']);
      }
    };


    /**
    When the document was created.
    @returns {Array} an array of {@link Date} objects
     */

    DocumentReference.prototype.created = function() {
      if (this.json['created']) {
        return DT.DateTime.parse(this.json['created']);
      }
    };


    /**
    When the document reference was created.
    @returns {Array} an array of {@link Date} objects
     */

    DocumentReference.prototype.indexed = function() {
      if (this.json['indexed']) {
        return DT.DateTime.parse(this.json['indexed']);
      }
    };


    /**
    The status of this document reference.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The status of the underlying document.
    @returns {CodeableConcept}
     */

    DocumentReference.prototype.docStatus = function() {
      if (this.json['docStatus']) {
        return new CodeableConcept(this.json['docStatus']);
      }
    };


    /**
    Relationships that this document has with other document references that already exist.
    @returns {Array} an array of {@link DocumentReferenceRelatesToComponent} objects
     */

    DocumentReference.prototype.relatesTo = function() {
      var i, item, len, ref, results;
      if (this.json['relatesTo']) {
        ref = this.json['relatesTo'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DocumentReferenceRelatesToComponent(item));
        }
        return results;
      }
    };


    /**
    Human-readable description of the source document. This is sometimes known as the "title".
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A code specifying the level of confidentiality of the XDS Document.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DocumentReference.prototype.confidentiality = function() {
      var i, item, len, ref, results;
      if (this.json['confidentiality']) {
        ref = this.json['confidentiality'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The primary language in which the source document is written.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.primaryLanguage = function() {
      return this.json['primaryLanguage'];
    };


    /**
    The mime type of the source document.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.mimeType = function() {
      return this.json['mimeType'];
    };


    /**
    An identifier that identifies that the format and content of the document conforms to additional rules beyond the base format indicated in the mimeType.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.format = function() {
      return this.json['format'];
    };


    /**
    The size of the source document this reference refers to in bytes.
    @returns {Array} an array of {@link Number} objects
     */

    DocumentReference.prototype.size = function() {
      return this.json['size'];
    };


    /**
    A hash of the source document to ensure that changes have not occurred.
    @returns {Array} an array of {@link } objects
     */

    DocumentReference.prototype.hash = function() {
      return this.json['hash'];
    };


    /**
    A url at which the document can be accessed.
    @returns {Array} an array of {@link String} objects
     */

    DocumentReference.prototype.location = function() {
      return this.json['location'];
    };


    /**
    A description of a service call that can be used to retrieve the document.
    @returns {DocumentReferenceServiceComponent}
     */

    DocumentReference.prototype.service = function() {
      if (this.json['service']) {
        return new DocumentReferenceServiceComponent(this.json['service']);
      }
    };


    /**
    The clinical context in which the document was prepared.
    @returns {DocumentReferenceContextComponent}
     */

    DocumentReference.prototype.context = function() {
      if (this.json['context']) {
        return new DocumentReferenceContextComponent(this.json['context']);
      }
    };

    return DocumentReference;

  })(DomainResource);

  module.exports.DocumentReference = DocumentReference;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],67:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Eligibility, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides the insurance eligibility details from the insurer regarding a specified coverage and optionally some class of service.
  @class Eligibility
  @exports Eligibility as Eligibility
   */

  Eligibility = (function(superClass) {
    extend(Eligibility, superClass);

    function Eligibility(json) {
      this.json = json;
      Eligibility.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    Eligibility.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    Eligibility.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    Eligibility.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    Eligibility.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    Eligibility.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Eligibility.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Eligibility.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };

    return Eligibility;

  })(DomainResource);

  module.exports.Eligibility = Eligibility;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],68:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, EligibilityResponse, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides eligibility and plan details from the processing of an Eligibility resource.
  @class EligibilityResponse
  @exports EligibilityResponse as EligibilityResponse
   */

  EligibilityResponse = (function(superClass) {
    extend(EligibilityResponse, superClass);

    function EligibilityResponse(json) {
      this.json = json;
      EligibilityResponse.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    EligibilityResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    EligibilityResponse.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Transaction status: error, complete.
    @returns {Array} an array of {@link String} objects
     */

    EligibilityResponse.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A description of the status of the adjudication.
    @returns {Array} an array of {@link String} objects
     */

    EligibilityResponse.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    EligibilityResponse.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    EligibilityResponse.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    EligibilityResponse.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    EligibilityResponse.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    EligibilityResponse.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    EligibilityResponse.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };

    return EligibilityResponse;

  })(DomainResource);

  module.exports.EligibilityResponse = EligibilityResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],69:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Encounter, EncounterHospitalizationAccomodationComponent, EncounterHospitalizationComponent, EncounterLocationComponent, EncounterParticipantComponent, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class EncounterParticipantComponent
  @exports  EncounterParticipantComponent as EncounterParticipantComponent
   */

  EncounterParticipantComponent = (function(superClass) {
    extend(EncounterParticipantComponent, superClass);

    function EncounterParticipantComponent(json) {
      this.json = json;
      EncounterParticipantComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Role of participant in encounter.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    EncounterParticipantComponent.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Persons involved in the encounter other than the patient.
    @returns {Reference}
     */

    EncounterParticipantComponent.prototype.individual = function() {
      if (this.json['individual']) {
        return new Reference(this.json['individual']);
      }
    };

    return EncounterParticipantComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class EncounterHospitalizationAccomodationComponent
  @exports  EncounterHospitalizationAccomodationComponent as EncounterHospitalizationAccomodationComponent
   */

  EncounterHospitalizationAccomodationComponent = (function(superClass) {
    extend(EncounterHospitalizationAccomodationComponent, superClass);

    function EncounterHospitalizationAccomodationComponent(json) {
      this.json = json;
      EncounterHospitalizationAccomodationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The bed that is assigned to the patient.
    @returns {Reference}
     */

    EncounterHospitalizationAccomodationComponent.prototype.bed = function() {
      if (this.json['bed']) {
        return new Reference(this.json['bed']);
      }
    };


    /**
    Period during which the patient was assigned the bed.
    @returns {Period}
     */

    EncounterHospitalizationAccomodationComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return EncounterHospitalizationAccomodationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class EncounterHospitalizationComponent
  @exports  EncounterHospitalizationComponent as EncounterHospitalizationComponent
   */

  EncounterHospitalizationComponent = (function(superClass) {
    extend(EncounterHospitalizationComponent, superClass);

    function EncounterHospitalizationComponent(json) {
      this.json = json;
      EncounterHospitalizationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Pre-admission identifier.
    @returns {Identifier}
     */

    EncounterHospitalizationComponent.prototype.preAdmissionIdentifier = function() {
      if (this.json['preAdmissionIdentifier']) {
        return new Identifier(this.json['preAdmissionIdentifier']);
      }
    };


    /**
    The location from which the patient came before admission.
    @returns {Reference}
     */

    EncounterHospitalizationComponent.prototype.origin = function() {
      if (this.json['origin']) {
        return new Reference(this.json['origin']);
      }
    };


    /**
    From where patient was admitted (physician referral, transfer).
    @returns {CodeableConcept}
     */

    EncounterHospitalizationComponent.prototype.admitSource = function() {
      if (this.json['admitSource']) {
        return new CodeableConcept(this.json['admitSource']);
      }
    };


    /**
    Period during which the patient was admitted.
    @returns {Period}
     */

    EncounterHospitalizationComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Where the patient stays during this encounter.
    @returns {Array} an array of {@link EncounterHospitalizationAccomodationComponent} objects
     */

    EncounterHospitalizationComponent.prototype.accomodation = function() {
      var i, item, len, ref, results;
      if (this.json['accomodation']) {
        ref = this.json['accomodation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new EncounterHospitalizationAccomodationComponent(item));
        }
        return results;
      }
    };


    /**
    Dietary restrictions for the patient.
    @returns {CodeableConcept}
     */

    EncounterHospitalizationComponent.prototype.diet = function() {
      if (this.json['diet']) {
        return new CodeableConcept(this.json['diet']);
      }
    };


    /**
    Special courtesies (VIP, board member).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    EncounterHospitalizationComponent.prototype.specialCourtesy = function() {
      var i, item, len, ref, results;
      if (this.json['specialCourtesy']) {
        ref = this.json['specialCourtesy'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Wheelchair, translator, stretcher, etc.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    EncounterHospitalizationComponent.prototype.specialArrangement = function() {
      var i, item, len, ref, results;
      if (this.json['specialArrangement']) {
        ref = this.json['specialArrangement'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Location to which the patient is discharged.
    @returns {Reference}
     */

    EncounterHospitalizationComponent.prototype.destination = function() {
      if (this.json['destination']) {
        return new Reference(this.json['destination']);
      }
    };


    /**
    Category or kind of location after discharge.
    @returns {CodeableConcept}
     */

    EncounterHospitalizationComponent.prototype.dischargeDisposition = function() {
      if (this.json['dischargeDisposition']) {
        return new CodeableConcept(this.json['dischargeDisposition']);
      }
    };


    /**
    The final diagnosis given a patient before release from the hospital after all testing, surgery, and workup are complete.
    @returns {Reference}
     */

    EncounterHospitalizationComponent.prototype.dischargeDiagnosis = function() {
      if (this.json['dischargeDiagnosis']) {
        return new Reference(this.json['dischargeDiagnosis']);
      }
    };


    /**
    Whether this hospitalization is a readmission.
    @returns {Array} an array of {@link boolean} objects
     */

    EncounterHospitalizationComponent.prototype.reAdmission = function() {
      return this.json['reAdmission'];
    };

    return EncounterHospitalizationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class EncounterLocationComponent
  @exports  EncounterLocationComponent as EncounterLocationComponent
   */

  EncounterLocationComponent = (function(superClass) {
    extend(EncounterLocationComponent, superClass);

    function EncounterLocationComponent(json) {
      this.json = json;
      EncounterLocationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The location where the encounter takes place.
    @returns {Reference}
     */

    EncounterLocationComponent.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Time period during which the patient was present at the location.
    @returns {Period}
     */

    EncounterLocationComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return EncounterLocationComponent;

  })(BackboneElement);


  /**
  An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
  @class Encounter
  @exports Encounter as Encounter
   */

  Encounter = (function(superClass) {
    extend(Encounter, superClass);

    function Encounter(json) {
      this.json = json;
      Encounter.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier(s) by which this encounter is known.
    @returns {Array} an array of {@link Identifier} objects
     */

    Encounter.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    planned | in progress | onleave | finished | cancelled.
    @returns {Array} an array of {@link String} objects
     */

    Encounter.prototype.status = function() {
      return this.json['status'];
    };


    /**
    inpatient | outpatient | ambulatory | emergency +.
    @returns {Array} an array of {@link String} objects
     */

    Encounter.prototype["class"] = function() {
      return this.json['class'];
    };


    /**
    Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Encounter.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The patient present at the encounter.
    @returns {Reference}
     */

    Encounter.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The main practitioner responsible for providing the service.
    @returns {Array} an array of {@link EncounterParticipantComponent} objects
     */

    Encounter.prototype.participant = function() {
      var i, item, len, ref, results;
      if (this.json['participant']) {
        ref = this.json['participant'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new EncounterParticipantComponent(item));
        }
        return results;
      }
    };


    /**
    The appointment that scheduled this encounter.
    @returns {Reference}
     */

    Encounter.prototype.fulfills = function() {
      if (this.json['fulfills']) {
        return new Reference(this.json['fulfills']);
      }
    };


    /**
    The start and end time of the encounter.
    @returns {Period}
     */

    Encounter.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Quantity of time the encounter lasted. This excludes the time during leaves of absence.
    @returns {Duration}
     */

    Encounter.prototype.length = function() {
      if (this.json['length']) {
        return new Duration(this.json['length']);
      }
    };


    /**
    Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis.
    @returns {CodeableConcept}
     */

    Encounter.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };


    /**
    Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis.
    @returns {Reference}
     */

    Encounter.prototype.indication = function() {
      if (this.json['indication']) {
        return new Reference(this.json['indication']);
      }
    };


    /**
    Indicates the urgency of the encounter.
    @returns {CodeableConcept}
     */

    Encounter.prototype.priority = function() {
      if (this.json['priority']) {
        return new CodeableConcept(this.json['priority']);
      }
    };


    /**
    Details about an admission to a clinic.
    @returns {EncounterHospitalizationComponent}
     */

    Encounter.prototype.hospitalization = function() {
      if (this.json['hospitalization']) {
        return new EncounterHospitalizationComponent(this.json['hospitalization']);
      }
    };


    /**
    List of locations at which the patient has been.
    @returns {Array} an array of {@link EncounterLocationComponent} objects
     */

    Encounter.prototype.location = function() {
      var i, item, len, ref, results;
      if (this.json['location']) {
        ref = this.json['location'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new EncounterLocationComponent(item));
        }
        return results;
      }
    };


    /**
    Department or team providing care.
    @returns {Reference}
     */

    Encounter.prototype.serviceProvider = function() {
      if (this.json['serviceProvider']) {
        return new Reference(this.json['serviceProvider']);
      }
    };


    /**
    Another Encounter of which this encounter is a part of (administratively or in time).
    @returns {Reference}
     */

    Encounter.prototype.partOf = function() {
      if (this.json['partOf']) {
        return new Reference(this.json['partOf']);
      }
    };

    return Encounter;

  })(DomainResource);

  module.exports.Encounter = Encounter;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],70:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Enrollment, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides the insurance Enrollment details to the insurer regarding a specified coverage.
  @class Enrollment
  @exports Enrollment as Enrollment
   */

  Enrollment = (function(superClass) {
    extend(Enrollment, superClass);

    function Enrollment(json) {
      this.json = json;
      Enrollment.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    Enrollment.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    Enrollment.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    Enrollment.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    Enrollment.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    Enrollment.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Enrollment.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Enrollment.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Patient Resource.
    @returns {Reference}
     */

    Enrollment.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Reference to the program or plan identification, underwriter or payor.
    @returns {Reference}
     */

    Enrollment.prototype.coverage = function() {
      if (this.json['coverage']) {
        return new Reference(this.json['coverage']);
      }
    };


    /**
    The relationship of the patient to the subscriber.
    @returns {Coding}
     */

    Enrollment.prototype.relationship = function() {
      if (this.json['relationship']) {
        return new Coding(this.json['relationship']);
      }
    };

    return Enrollment;

  })(DomainResource);

  module.exports.Enrollment = Enrollment;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],71:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, EnrollmentResponse, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides Enrollment and plan details from the processing of an Enrollment resource.
  @class EnrollmentResponse
  @exports EnrollmentResponse as EnrollmentResponse
   */

  EnrollmentResponse = (function(superClass) {
    extend(EnrollmentResponse, superClass);

    function EnrollmentResponse(json) {
      this.json = json;
      EnrollmentResponse.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    EnrollmentResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    EnrollmentResponse.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Transaction status: error, complete.
    @returns {Array} an array of {@link String} objects
     */

    EnrollmentResponse.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A description of the status of the adjudication.
    @returns {Array} an array of {@link String} objects
     */

    EnrollmentResponse.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    EnrollmentResponse.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    EnrollmentResponse.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    EnrollmentResponse.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    EnrollmentResponse.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    EnrollmentResponse.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    EnrollmentResponse.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };

    return EnrollmentResponse;

  })(DomainResource);

  module.exports.EnrollmentResponse = EnrollmentResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],72:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, ExplanationOfBenefit, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information , for informing the subscriber of the benefits provided.
  @class ExplanationOfBenefit
  @exports ExplanationOfBenefit as ExplanationOfBenefit
   */

  ExplanationOfBenefit = (function(superClass) {
    extend(ExplanationOfBenefit, superClass);

    function ExplanationOfBenefit(json) {
      this.json = json;
      ExplanationOfBenefit.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    ExplanationOfBenefit.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    ExplanationOfBenefit.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Transaction status: error, complete.
    @returns {Array} an array of {@link String} objects
     */

    ExplanationOfBenefit.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A description of the status of the adjudication.
    @returns {Array} an array of {@link String} objects
     */

    ExplanationOfBenefit.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    ExplanationOfBenefit.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    ExplanationOfBenefit.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    ExplanationOfBenefit.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    ExplanationOfBenefit.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    ExplanationOfBenefit.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    ExplanationOfBenefit.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };

    return ExplanationOfBenefit;

  })(DomainResource);

  module.exports.ExplanationOfBenefit = ExplanationOfBenefit;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],73:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, ExtensionDefinition, ExtensionDefinitionMappingComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ExtensionDefinitionMappingComponent
  @exports  ExtensionDefinitionMappingComponent as ExtensionDefinitionMappingComponent
   */

  ExtensionDefinitionMappingComponent = (function(superClass) {
    extend(ExtensionDefinitionMappingComponent, superClass);

    function ExtensionDefinitionMappingComponent(json) {
      this.json = json;
      ExtensionDefinitionMappingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An Internal id that is used to identify this mapping set when specific mappings are made.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinitionMappingComponent.prototype.identity = function() {
      return this.json['identity'];
    };


    /**
    A URI that identifies the specification that this mapping is expressed to.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinitionMappingComponent.prototype.uri = function() {
      return this.json['uri'];
    };


    /**
    A name for the specification that is being mapped to.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinitionMappingComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinitionMappingComponent.prototype.comments = function() {
      return this.json['comments'];
    };

    return ExtensionDefinitionMappingComponent;

  })(BackboneElement);


  /**
  Defines an extension that can be used in resources.
  @class ExtensionDefinition
  @exports ExtensionDefinition as ExtensionDefinition
   */

  ExtensionDefinition = (function(superClass) {
    extend(ExtensionDefinition, superClass);

    function ExtensionDefinition(json) {
      this.json = json;
      ExtensionDefinition.__super__.constructor.call(this, this.json);
    }


    /**
    The URL at which this definition is (or will be) published, and which is used to reference this profile in extension urls in operational FHIR systems.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.url = function() {
      return this.json['url'];
    };


    /**
    Formal identifier that is used to identify this profile when it is represented in other formats (e.g. ISO 11179(, or referenced in a specification, model, design or an instance  (should be globally unique OID, UUID, or URI), (if it's not possible to use the literal URI).
    @returns {Array} an array of {@link Identifier} objects
     */

    ExtensionDefinition.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A free text natural language name identifying the extension.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Defined so that applications can use this name when displaying the value of the extension to the user.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.display = function() {
      return this.json['display'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the extension definition.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    ExtensionDefinition.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the extension and its use.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A set of terms from external terminologies that may be used to assist with indexing and searching of extension definitions.
    @returns {Array} an array of {@link Coding} objects
     */

    ExtensionDefinition.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    The status of the extension.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.status = function() {
      return this.json['status'];
    };


    /**
    This extension definition was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    ExtensionDefinition.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    The date that this version of the extension was published.
    @returns {Array} an array of {@link Date} objects
     */

    ExtensionDefinition.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Scope and Usage that this extension was created to meet.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    An external specification that the content is mapped to.
    @returns {Array} an array of {@link ExtensionDefinitionMappingComponent} objects
     */

    ExtensionDefinition.prototype.mapping = function() {
      var i, item, len, ref, results;
      if (this.json['mapping']) {
        ref = this.json['mapping'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ExtensionDefinitionMappingComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies the type of context to which the extension applies.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.contextType = function() {
      return this.json['contextType'];
    };


    /**
    Identifies the types of resource or data type elements to which the extension can be applied.
    @returns {Array} an array of {@link String} objects
     */

    ExtensionDefinition.prototype.context = function() {
      return this.json['context'];
    };


    /**
    Definition of the elements that are defined to be in the extension.
    @returns {Array} an array of {@link ElementDefinition} objects
     */

    ExtensionDefinition.prototype.element = function() {
      var i, item, len, ref, results;
      if (this.json['element']) {
        ref = this.json['element'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ElementDefinition(item));
        }
        return results;
      }
    };

    return ExtensionDefinition;

  })(DomainResource);

  module.exports.ExtensionDefinition = ExtensionDefinition;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],74:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, FamilyHistory, FamilyHistoryRelationComponent, FamilyHistoryRelationConditionComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class FamilyHistoryRelationConditionComponent
  @exports  FamilyHistoryRelationConditionComponent as FamilyHistoryRelationConditionComponent
   */

  FamilyHistoryRelationConditionComponent = (function(superClass) {
    extend(FamilyHistoryRelationConditionComponent, superClass);

    function FamilyHistoryRelationConditionComponent(json) {
      this.json = json;
      FamilyHistoryRelationConditionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    @returns {CodeableConcept}
     */

    FamilyHistoryRelationConditionComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    @returns {CodeableConcept}
     */

    FamilyHistoryRelationConditionComponent.prototype.outcome = function() {
      if (this.json['outcome']) {
        return new CodeableConcept(this.json['outcome']);
      }
    };

    FamilyHistoryRelationConditionComponent.prototype.onsetAge = function() {
      return new Quantity(this.json['onsetAge']);
    };


    /**
    Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    @returns {Range}
     */

    FamilyHistoryRelationConditionComponent.prototype.onsetRange = function() {
      if (this.json['onsetRange']) {
        return new Range(this.json['onsetRange']);
      }
    };


    /**
    Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationConditionComponent.prototype.onsetString = function() {
      return this.json['onsetString'];
    };


    /**
    An area where general notes can be placed about this specific condition.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationConditionComponent.prototype.note = function() {
      return this.json['note'];
    };

    return FamilyHistoryRelationConditionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class FamilyHistoryRelationComponent
  @exports  FamilyHistoryRelationComponent as FamilyHistoryRelationComponent
   */

  FamilyHistoryRelationComponent = (function(superClass) {
    extend(FamilyHistoryRelationComponent, superClass);

    function FamilyHistoryRelationComponent(json) {
      this.json = json;
      FamilyHistoryRelationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    The type of relationship this person has to the patient (father, mother, brother etc.).
    @returns {CodeableConcept}
     */

    FamilyHistoryRelationComponent.prototype.relationship = function() {
      if (this.json['relationship']) {
        return new CodeableConcept(this.json['relationship']);
      }
    };


    /**
    The actual or approximate date of birth of the relative.
    @returns {Period}
     */

    FamilyHistoryRelationComponent.prototype.bornPeriod = function() {
      if (this.json['bornPeriod']) {
        return new Period(this.json['bornPeriod']);
      }
    };


    /**
    The actual or approximate date of birth of the relative.
    @returns {Array} an array of {@link Date} objects
     */

    FamilyHistoryRelationComponent.prototype.bornDate = function() {
      if (this.json['bornDate']) {
        return DT.DateTime.parse(this.json['bornDate']);
      }
    };


    /**
    The actual or approximate date of birth of the relative.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationComponent.prototype.bornString = function() {
      return this.json['bornString'];
    };

    FamilyHistoryRelationComponent.prototype.ageAge = function() {
      return new Quantity(this.json['ageAge']);
    };


    /**
    The actual or approximate age of the relative at the time the family history is recorded.
    @returns {Range}
     */

    FamilyHistoryRelationComponent.prototype.ageRange = function() {
      if (this.json['ageRange']) {
        return new Range(this.json['ageRange']);
      }
    };


    /**
    The actual or approximate age of the relative at the time the family history is recorded.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationComponent.prototype.ageString = function() {
      return this.json['ageString'];
    };


    /**
    If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    @returns {Array} an array of {@link boolean} objects
     */

    FamilyHistoryRelationComponent.prototype.deceasedBoolean = function() {
      return this.json['deceasedBoolean'];
    };

    FamilyHistoryRelationComponent.prototype.deceasedAge = function() {
      return new Quantity(this.json['deceasedAge']);
    };


    /**
    If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    @returns {Range}
     */

    FamilyHistoryRelationComponent.prototype.deceasedRange = function() {
      if (this.json['deceasedRange']) {
        return new Range(this.json['deceasedRange']);
      }
    };


    /**
    If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    @returns {Array} an array of {@link Date} objects
     */

    FamilyHistoryRelationComponent.prototype.deceasedDate = function() {
      if (this.json['deceasedDate']) {
        return DT.DateTime.parse(this.json['deceasedDate']);
      }
    };


    /**
    If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationComponent.prototype.deceasedString = function() {
      return this.json['deceasedString'];
    };


    /**
    This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistoryRelationComponent.prototype.note = function() {
      return this.json['note'];
    };


    /**
    The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    @returns {Array} an array of {@link FamilyHistoryRelationConditionComponent} objects
     */

    FamilyHistoryRelationComponent.prototype.condition = function() {
      var i, item, len, ref, results;
      if (this.json['condition']) {
        ref = this.json['condition'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new FamilyHistoryRelationConditionComponent(item));
        }
        return results;
      }
    };

    return FamilyHistoryRelationComponent;

  })(BackboneElement);


  /**
  Significant health events and conditions for people related to the subject relevant in the context of care for the subject.
  @class FamilyHistory
  @exports FamilyHistory as FamilyHistory
   */

  FamilyHistory = (function(superClass) {
    extend(FamilyHistory, superClass);

    function FamilyHistory(json) {
      this.json = json;
      FamilyHistory.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this family history record that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    FamilyHistory.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The person who this history concerns.
    @returns {Reference}
     */

    FamilyHistory.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The date (and possibly time) when the family history was taken.
    @returns {Array} an array of {@link Date} objects
     */

    FamilyHistory.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Conveys information about family history not specific to individual relations.
    @returns {Array} an array of {@link String} objects
     */

    FamilyHistory.prototype.note = function() {
      return this.json['note'];
    };


    /**
    The related person. Each FamilyHistory resource contains the entire family history for a single person.
    @returns {Array} an array of {@link FamilyHistoryRelationComponent} objects
     */

    FamilyHistory.prototype.relation = function() {
      var i, item, len, ref, results;
      if (this.json['relation']) {
        ref = this.json['relation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new FamilyHistoryRelationComponent(item));
        }
        return results;
      }
    };

    return FamilyHistory;

  })(DomainResource);

  module.exports.FamilyHistory = FamilyHistory;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],75:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, Group, GroupCharacteristicComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class GroupCharacteristicComponent
  @exports  GroupCharacteristicComponent as GroupCharacteristicComponent
   */

  GroupCharacteristicComponent = (function(superClass) {
    extend(GroupCharacteristicComponent, superClass);

    function GroupCharacteristicComponent(json) {
      this.json = json;
      GroupCharacteristicComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code that identifies the kind of trait being asserted.
    @returns {CodeableConcept}
     */

    GroupCharacteristicComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    @returns {CodeableConcept}
     */

    GroupCharacteristicComponent.prototype.valueCodeableConcept = function() {
      if (this.json['valueCodeableConcept']) {
        return new CodeableConcept(this.json['valueCodeableConcept']);
      }
    };


    /**
    The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    @returns {Array} an array of {@link boolean} objects
     */

    GroupCharacteristicComponent.prototype.valueBoolean = function() {
      return this.json['valueBoolean'];
    };


    /**
    The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    @returns {Quantity}
     */

    GroupCharacteristicComponent.prototype.valueQuantity = function() {
      if (this.json['valueQuantity']) {
        return new Quantity(this.json['valueQuantity']);
      }
    };


    /**
    The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    @returns {Range}
     */

    GroupCharacteristicComponent.prototype.valueRange = function() {
      if (this.json['valueRange']) {
        return new Range(this.json['valueRange']);
      }
    };


    /**
    If true, indicates the characteristic is one that is NOT held by members of the group.
    @returns {Array} an array of {@link boolean} objects
     */

    GroupCharacteristicComponent.prototype.exclude = function() {
      return this.json['exclude'];
    };

    return GroupCharacteristicComponent;

  })(BackboneElement);


  /**
  Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized.  I.e. A collection of entities that isn't an Organization.
  @class Group
  @exports Group as Group
   */

  Group = (function(superClass) {
    extend(Group, superClass);

    function Group(json) {
      this.json = json;
      Group.__super__.constructor.call(this, this.json);
    }


    /**
    A unique business identifier for this group.
    @returns {Identifier}
     */

    Group.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Identifies the broad classification of the kind of resources the group includes.
    @returns {Array} an array of {@link String} objects
     */

    Group.prototype.type = function() {
      return this.json['type'];
    };


    /**
    If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    @returns {Array} an array of {@link boolean} objects
     */

    Group.prototype.actual = function() {
      return this.json['actual'];
    };


    /**
    Provides a specific type of resource the group includes.  E.g. "cow", "syringe", etc.
    @returns {CodeableConcept}
     */

    Group.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    A label assigned to the group for human identification and communication.
    @returns {Array} an array of {@link String} objects
     */

    Group.prototype.name = function() {
      return this.json['name'];
    };


    /**
    A count of the number of resource instances that are part of the group.
    @returns {Array} an array of {@link Number} objects
     */

    Group.prototype.quantity = function() {
      return this.json['quantity'];
    };


    /**
    Identifies the traits shared by members of the group.
    @returns {Array} an array of {@link GroupCharacteristicComponent} objects
     */

    Group.prototype.characteristic = function() {
      var i, item, len, ref, results;
      if (this.json['characteristic']) {
        ref = this.json['characteristic'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new GroupCharacteristicComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies the resource instances that are members of the group.
    @returns {Array} an array of {@link Reference} objects
     */

    Group.prototype.member = function() {
      var i, item, len, ref, results;
      if (this.json['member']) {
        ref = this.json['member'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return Group;

  })(DomainResource);

  module.exports.Group = Group;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],76:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HealthcareService, HealthcareServiceAvailableTimeComponent, HealthcareServiceNotAvailableTimeComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, ServiceTypeComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ServiceTypeComponent
  @exports  ServiceTypeComponent as ServiceTypeComponent
   */

  ServiceTypeComponent = (function(superClass) {
    extend(ServiceTypeComponent, superClass);

    function ServiceTypeComponent(json) {
      this.json = json;
      ServiceTypeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The specific type of service being delivered or performed.
    @returns {CodeableConcept}
     */

    ServiceTypeComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Collection of Specialties handled by the Service Site. This is more of a Medical Term.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ServiceTypeComponent.prototype.specialty = function() {
      var i, item, len, ref, results;
      if (this.json['specialty']) {
        ref = this.json['specialty'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };

    return ServiceTypeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class HealthcareServiceAvailableTimeComponent
  @exports  HealthcareServiceAvailableTimeComponent as HealthcareServiceAvailableTimeComponent
   */

  HealthcareServiceAvailableTimeComponent = (function(superClass) {
    extend(HealthcareServiceAvailableTimeComponent, superClass);

    function HealthcareServiceAvailableTimeComponent(json) {
      this.json = json;
      HealthcareServiceAvailableTimeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates which Days of the week are available between the Start and End Times.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareServiceAvailableTimeComponent.prototype.daysOfWeek = function() {
      var i, item, len, ref, results;
      if (this.json['daysOfWeek']) {
        ref = this.json['daysOfWeek'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    @returns {Array} an array of {@link boolean} objects
     */

    HealthcareServiceAvailableTimeComponent.prototype.allDay = function() {
      return this.json['allDay'];
    };


    /**
    The opening time of day (the date is not included). Note: If the AllDay flag is set, then this time is ignored.
    @returns {Array} an array of {@link Date} objects
     */

    HealthcareServiceAvailableTimeComponent.prototype.availableStartTime = function() {
      if (this.json['availableStartTime']) {
        return DT.DateTime.parse(this.json['availableStartTime']);
      }
    };


    /**
    The closing time of day (the date is not included). Note: If the AllDay flag is set, then this time is ignored.
    @returns {Array} an array of {@link Date} objects
     */

    HealthcareServiceAvailableTimeComponent.prototype.availableEndTime = function() {
      if (this.json['availableEndTime']) {
        return DT.DateTime.parse(this.json['availableEndTime']);
      }
    };

    return HealthcareServiceAvailableTimeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class HealthcareServiceNotAvailableTimeComponent
  @exports  HealthcareServiceNotAvailableTimeComponent as HealthcareServiceNotAvailableTimeComponent
   */

  HealthcareServiceNotAvailableTimeComponent = (function(superClass) {
    extend(HealthcareServiceNotAvailableTimeComponent, superClass);

    function HealthcareServiceNotAvailableTimeComponent(json) {
      this.json = json;
      HealthcareServiceNotAvailableTimeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The reason that can be presented to the user as to why this time is not available.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareServiceNotAvailableTimeComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Service is not available (seasonally or for a public holiday) from this date.
    @returns {Array} an array of {@link Date} objects
     */

    HealthcareServiceNotAvailableTimeComponent.prototype.startDate = function() {
      if (this.json['startDate']) {
        return DT.DateTime.parse(this.json['startDate']);
      }
    };


    /**
    Service is not available (seasonally or for a public holiday) until this date.
    @returns {Array} an array of {@link Date} objects
     */

    HealthcareServiceNotAvailableTimeComponent.prototype.endDate = function() {
      if (this.json['endDate']) {
        return DT.DateTime.parse(this.json['endDate']);
      }
    };

    return HealthcareServiceNotAvailableTimeComponent;

  })(BackboneElement);


  /**
  (informative) The details of a Healthcare Service available at a location.
  @class HealthcareService
  @exports HealthcareService as HealthcareService
   */

  HealthcareService = (function(superClass) {
    extend(HealthcareService, superClass);

    function HealthcareService(json) {
      this.json = json;
      HealthcareService.__super__.constructor.call(this, this.json);
    }


    /**
    External Ids for this item.
    @returns {Array} an array of {@link Identifier} objects
     */

    HealthcareService.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The location where this healthcare service may be provided.
    @returns {Reference}
     */

    HealthcareService.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Identifies the broad category of service being performed or delivered. Selecting a Service Category then determines the list of relevant service types that can be selected in the Primary Service Type.
    @returns {CodeableConcept}
     */

    HealthcareService.prototype.serviceCategory = function() {
      if (this.json['serviceCategory']) {
        return new CodeableConcept(this.json['serviceCategory']);
      }
    };


    /**
    A specific type of service that may be delivered or performed.
    @returns {Array} an array of {@link ServiceTypeComponent} objects
     */

    HealthcareService.prototype.serviceType = function() {
      var i, item, len, ref, results;
      if (this.json['serviceType']) {
        ref = this.json['serviceType'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ServiceTypeComponent(item));
        }
        return results;
      }
    };


    /**
    Further description of the service as it would be presented to a consumer while searching.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.serviceName = function() {
      return this.json['serviceName'];
    };


    /**
    Additional description of the  or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    Extra details about the service that can't be placed in the other fields.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.extraDetails = function() {
      return this.json['extraDetails'];
    };


    /**
    The free provision code provides a link to the Free Provision reference entity to enable the selection of one free provision type.
    @returns {CodeableConcept}
     */

    HealthcareService.prototype.freeProvisionCode = function() {
      if (this.json['freeProvisionCode']) {
        return new CodeableConcept(this.json['freeProvisionCode']);
      }
    };


    /**
    Does this service have specific eligibility requirements that need to be met in order to use the service.
    @returns {CodeableConcept}
     */

    HealthcareService.prototype.eligibility = function() {
      if (this.json['eligibility']) {
        return new CodeableConcept(this.json['eligibility']);
      }
    };


    /**
    The description of service eligibility should, in general, not exceed one or two paragraphs. It should be sufficient for a prospective consumer to determine if they are likely to be eligible or not. Where eligibility requirements and conditions are complex, it may simply be noted that an eligibility assessment is required. Where eligibility is determined by an outside source, such as an Act of Parliament, this should be noted, preferably with a reference to a commonly available copy of the source document such as a web page.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.eligibilityNote = function() {
      return this.json['eligibilityNote'];
    };


    /**
    Indicates whether or not a prospective consumer will require an appointment for a particular service at a Site to be provided by the Organization. Indicates if an appointment is required for access to this service. If this flag is 'NotDefined', then this flag is overridden by the Site's availability flag. (ConditionalIndicator Enum).
    @returns {CodeableConcept}
     */

    HealthcareService.prototype.appointmentRequired = function() {
      if (this.json['appointmentRequired']) {
        return new CodeableConcept(this.json['appointmentRequired']);
      }
    };


    /**
    If there is an image associated with this Service Site, its URI can be included here.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.imageURI = function() {
      return this.json['imageURI'];
    };


    /**
    A Collection of times that the Service Site is available.
    @returns {Array} an array of {@link HealthcareServiceAvailableTimeComponent} objects
     */

    HealthcareService.prototype.availableTime = function() {
      var i, item, len, ref, results;
      if (this.json['availableTime']) {
        ref = this.json['availableTime'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new HealthcareServiceAvailableTimeComponent(item));
        }
        return results;
      }
    };


    /**
    Not avail times - need better description.
    @returns {Array} an array of {@link HealthcareServiceNotAvailableTimeComponent} objects
     */

    HealthcareService.prototype.notAvailableTime = function() {
      var i, item, len, ref, results;
      if (this.json['notAvailableTime']) {
        ref = this.json['notAvailableTime'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new HealthcareServiceNotAvailableTimeComponent(item));
        }
        return results;
      }
    };


    /**
    A description of Site availability exceptions, e.g., public holiday availability. Succinctly describing all possible exceptions to normal Site availability as details in the Available Times and Not Available Times.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.availabilityExceptions = function() {
      return this.json['availabilityExceptions'];
    };


    /**
    The public part of the 'keys' allocated to an Organization by an accredited body to support secure exchange of data over the internet. To be provided by the Organization, where available.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.publicKey = function() {
      return this.json['publicKey'];
    };


    /**
    Program Names that can be used to categorize the service.
    @returns {Array} an array of {@link String} objects
     */

    HealthcareService.prototype.programName = function() {
      return this.json['programName'];
    };


    /**
    List of contacts related to this specific healthcare service. If this is empty, then refer to the location's contacts.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    HealthcareService.prototype.contactPoint = function() {
      var i, item, len, ref, results;
      if (this.json['contactPoint']) {
        ref = this.json['contactPoint'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Collection of Characteristics (attributes).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.characteristic = function() {
      var i, item, len, ref, results;
      if (this.json['characteristic']) {
        ref = this.json['characteristic'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Ways that the service accepts referrals.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.referralMethod = function() {
      var i, item, len, ref, results;
      if (this.json['referralMethod']) {
        ref = this.json['referralMethod'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The setting where this service can be provided, such is in home, or at location in organisation.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.setting = function() {
      var i, item, len, ref, results;
      if (this.json['setting']) {
        ref = this.json['setting'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Collection of Target Groups for the Service Site (The target audience that this service is for).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.targetGroup = function() {
      var i, item, len, ref, results;
      if (this.json['targetGroup']) {
        ref = this.json['targetGroup'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Need better description.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.coverageArea = function() {
      var i, item, len, ref, results;
      if (this.json['coverageArea']) {
        ref = this.json['coverageArea'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Need better description.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.catchmentArea = function() {
      var i, item, len, ref, results;
      if (this.json['catchmentArea']) {
        ref = this.json['catchmentArea'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    List of the specific.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    HealthcareService.prototype.serviceCode = function() {
      var i, item, len, ref, results;
      if (this.json['serviceCode']) {
        ref = this.json['serviceCode'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };

    return HealthcareService;

  })(DomainResource);

  module.exports.HealthcareService = HealthcareService;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],77:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, ImagingObjectSelection, InstanceComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SeriesComponent, StudyComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class InstanceComponent
  @exports  InstanceComponent as InstanceComponent
   */

  InstanceComponent = (function(superClass) {
    extend(InstanceComponent, superClass);

    function InstanceComponent(json) {
      this.json = json;
      InstanceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    SOP class uid of the selected instance.
    @returns {oid}
     */

    InstanceComponent.prototype.sopClass = function() {
      if (this.json['sopClass']) {
        return new oid(this.json['sopClass']);
      }
    };


    /**
    SOP Instance uid of the selected instance.
    @returns {oid}
     */

    InstanceComponent.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    The DICOM Application Entity Title where the DICOM SOP instance can be retrieved.
    @returns {Array} an array of {@link String} objects
     */

    InstanceComponent.prototype.retrieveAETitle = function() {
      return this.json['retrieveAETitle'];
    };


    /**
    WADO-RS URL to retrieve the DICOM SOP Instance.
    @returns {Array} an array of {@link String} objects
     */

    InstanceComponent.prototype.retrieveUrl = function() {
      return this.json['retrieveUrl'];
    };

    return InstanceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SeriesComponent
  @exports  SeriesComponent as SeriesComponent
   */

  SeriesComponent = (function(superClass) {
    extend(SeriesComponent, superClass);

    function SeriesComponent(json) {
      this.json = json;
      SeriesComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Series instance uid of the SOP instances in the selection.
    @returns {oid}
     */

    SeriesComponent.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    The DICOM Application Entity Title where the series can be retrieved.
    Note that this AE Title is provided to retrieve all SOP instances of the series not only those in the selection.
    @returns {Array} an array of {@link String} objects
     */

    SeriesComponent.prototype.retrieveAETitle = function() {
      return this.json['retrieveAETitle'];
    };


    /**
    WADO-RS URL to retrieve the series Note that this URL retrieves all SOP instances of the series not only those in the selection.
    @returns {Array} an array of {@link String} objects
     */

    SeriesComponent.prototype.retrieveUrl = function() {
      return this.json['retrieveUrl'];
    };


    /**
    Identity and locating information of the selected DICOM SOP instances.
    @returns {Array} an array of {@link InstanceComponent} objects
     */

    SeriesComponent.prototype.instance = function() {
      var i, item, len, ref, results;
      if (this.json['instance']) {
        ref = this.json['instance'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new InstanceComponent(item));
        }
        return results;
      }
    };

    return SeriesComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class StudyComponent
  @exports  StudyComponent as StudyComponent
   */

  StudyComponent = (function(superClass) {
    extend(StudyComponent, superClass);

    function StudyComponent(json) {
      this.json = json;
      StudyComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Study instance uid of the SOP instances in the selection.
    @returns {oid}
     */

    StudyComponent.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    The DICOM Application Entity Title where the study can be retrieved.
    Note that this AE Title is provided to retrieve all SOP instances of the study, not only those in the selection.
    @returns {Array} an array of {@link String} objects
     */

    StudyComponent.prototype.retrieveAETitle = function() {
      return this.json['retrieveAETitle'];
    };


    /**
    WADO-RS URL to retrieve the study. Note that this URL retrieves all SOP instances of the study, not only those in the selection.
    @returns {Array} an array of {@link String} objects
     */

    StudyComponent.prototype.retrieveUrl = function() {
      return this.json['retrieveUrl'];
    };


    /**
    Series indetity and locating information of the DICOM SOP instances in the selection.
    @returns {Array} an array of {@link SeriesComponent} objects
     */

    StudyComponent.prototype.series = function() {
      var i, item, len, ref, results;
      if (this.json['series']) {
        ref = this.json['series'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SeriesComponent(item));
        }
        return results;
      }
    };

    return StudyComponent;

  })(BackboneElement);


  /**
  A set of DICOM SOP Instances of a patient, selected for some application purpose, e.g., quality assurance, teaching, conference, consulting, etc.  Objects selected can be from different studies, but must be of the same patient.
  @class ImagingObjectSelection
  @exports ImagingObjectSelection as ImagingObjectSelection
   */

  ImagingObjectSelection = (function(superClass) {
    extend(ImagingObjectSelection, superClass);

    function ImagingObjectSelection(json) {
      this.json = json;
      ImagingObjectSelection.__super__.constructor.call(this, this.json);
    }


    /**
    Instance UID of the DICOM KOS SOP Instances represenetd in this resource.
    @returns {oid}
     */

    ImagingObjectSelection.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    A patient resource reference which is the patient subject of all DICOM SOP Instances in this key object selection.
    @returns {Reference}
     */

    ImagingObjectSelection.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The reason for, or significance of, the selection of objects referenced in the resource.
    @returns {CodeableConcept}
     */

    ImagingObjectSelection.prototype.title = function() {
      if (this.json['title']) {
        return new CodeableConcept(this.json['title']);
      }
    };


    /**
    Text description of the DICOM SOP instances selected in the key object selection. This should be aligned with the content of the title element, and can provide further explanation of the SOP instances in the selection.
    @returns {Array} an array of {@link String} objects
     */

    ImagingObjectSelection.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Author of key object selection. It can be a human authtor or a device which made the decision of the SOP instances selected. For example, a radiologist selected a set of imaging SOP instances to attached in a diagnostic report, and a CAD application may author a selection to describe SOP instances it used to generate a detection conclusion.
    @returns {Reference}
     */

    ImagingObjectSelection.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    Date and time when the key object selection was authored. Note that this is the date and time the DICOM SOP instances in the selection were selected (selection decision making). It is different from the creation date and time of the selection resource.
    @returns {Array} an array of {@link Date} objects
     */

    ImagingObjectSelection.prototype.authoringTime = function() {
      if (this.json['authoringTime']) {
        return DT.DateTime.parse(this.json['authoringTime']);
      }
    };


    /**
    Study identity and locating information of the DICOM SOP instances in the selection.
    @returns {Array} an array of {@link StudyComponent} objects
     */

    ImagingObjectSelection.prototype.study = function() {
      var i, item, len, ref, results;
      if (this.json['study']) {
        ref = this.json['study'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new StudyComponent(item));
        }
        return results;
      }
    };

    return ImagingObjectSelection;

  })(DomainResource);

  module.exports.ImagingObjectSelection = ImagingObjectSelection;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],78:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, ImagingStudy, ImagingStudySeriesComponent, ImagingStudySeriesInstanceComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ImagingStudySeriesInstanceComponent
  @exports  ImagingStudySeriesInstanceComponent as ImagingStudySeriesInstanceComponent
   */

  ImagingStudySeriesInstanceComponent = (function(superClass) {
    extend(ImagingStudySeriesInstanceComponent, superClass);

    function ImagingStudySeriesInstanceComponent(json) {
      this.json = json;
      ImagingStudySeriesInstanceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The number of this image in the series.
    @returns {Array} an array of {@link Number} objects
     */

    ImagingStudySeriesInstanceComponent.prototype.number = function() {
      return this.json['number'];
    };


    /**
    Formal identifier for this image.
    @returns {oid}
     */

    ImagingStudySeriesInstanceComponent.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    DICOM Image type.
    @returns {oid}
     */

    ImagingStudySeriesInstanceComponent.prototype.sopclass = function() {
      if (this.json['sopclass']) {
        return new oid(this.json['sopclass']);
      }
    };


    /**
    The type of the instance.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesInstanceComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The description of the instance.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesInstanceComponent.prototype.title = function() {
      return this.json['title'];
    };


    /**
    WADO-RS url where image is available.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesInstanceComponent.prototype.url = function() {
      return this.json['url'];
    };


    /**
    A FHIR resource with content for this instance.
    @returns {Reference}
     */

    ImagingStudySeriesInstanceComponent.prototype.attachment = function() {
      if (this.json['attachment']) {
        return new Reference(this.json['attachment']);
      }
    };

    return ImagingStudySeriesInstanceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ImagingStudySeriesComponent
  @exports  ImagingStudySeriesComponent as ImagingStudySeriesComponent
   */

  ImagingStudySeriesComponent = (function(superClass) {
    extend(ImagingStudySeriesComponent, superClass);

    function ImagingStudySeriesComponent(json) {
      this.json = json;
      ImagingStudySeriesComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The Numeric identifier of this series in the study.
    @returns {Array} an array of {@link Number} objects
     */

    ImagingStudySeriesComponent.prototype.number = function() {
      return this.json['number'];
    };


    /**
    The modality of this series sequence.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesComponent.prototype.modality = function() {
      return this.json['modality'];
    };


    /**
    Formal identifier for this series.
    @returns {oid}
     */

    ImagingStudySeriesComponent.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    A description of the series.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Sequence that contains attributes from the.
    @returns {Array} an array of {@link Number} objects
     */

    ImagingStudySeriesComponent.prototype.numberOfInstances = function() {
      return this.json['numberOfInstances'];
    };


    /**
    Availability of series (online, offline or nearline).
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesComponent.prototype.availability = function() {
      return this.json['availability'];
    };


    /**
    WADO-RS URI where Series is available.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudySeriesComponent.prototype.url = function() {
      return this.json['url'];
    };


    /**
    Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed.
    @returns {Coding}
     */

    ImagingStudySeriesComponent.prototype.bodySite = function() {
      if (this.json['bodySite']) {
        return new Coding(this.json['bodySite']);
      }
    };


    /**
    The date when the series was started.
    @returns {Array} an array of {@link Date} objects
     */

    ImagingStudySeriesComponent.prototype.dateTime = function() {
      if (this.json['dateTime']) {
        return DT.DateTime.parse(this.json['dateTime']);
      }
    };


    /**
    A single image taken from a patient.
    @returns {Array} an array of {@link ImagingStudySeriesInstanceComponent} objects
     */

    ImagingStudySeriesComponent.prototype.instance = function() {
      var i, item, len, ref, results;
      if (this.json['instance']) {
        ref = this.json['instance'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImagingStudySeriesInstanceComponent(item));
        }
        return results;
      }
    };

    return ImagingStudySeriesComponent;

  })(BackboneElement);


  /**
  Representation of the content produced in a DICOM imaging study. A study comprises a set of Series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A Series is of only one modality (e.g., X-ray, CT, MR, ultrasound), but a Study may have multiple Series of different modalities.
  @class ImagingStudy
  @exports ImagingStudy as ImagingStudy
   */

  ImagingStudy = (function(superClass) {
    extend(ImagingStudy, superClass);

    function ImagingStudy(json) {
      this.json = json;
      ImagingStudy.__super__.constructor.call(this, this.json);
    }


    /**
    Date and Time the study started.
    @returns {Array} an array of {@link Date} objects
     */

    ImagingStudy.prototype.started = function() {
      if (this.json['started']) {
        return DT.DateTime.parse(this.json['started']);
      }
    };


    /**
    The patient for whom the images are of.
    @returns {Reference}
     */

    ImagingStudy.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Formal identifier for the study.
    @returns {oid}
     */

    ImagingStudy.prototype.uid = function() {
      if (this.json['uid']) {
        return new oid(this.json['uid']);
      }
    };


    /**
    Accession Number.
    @returns {Identifier}
     */

    ImagingStudy.prototype.accession = function() {
      if (this.json['accession']) {
        return new Identifier(this.json['accession']);
      }
    };


    /**
    Other identifiers for the study.
    @returns {Array} an array of {@link Identifier} objects
     */

    ImagingStudy.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A list of the diagnostic orders that resulted in this imaging study being performed.
    @returns {Array} an array of {@link Reference} objects
     */

    ImagingStudy.prototype.order = function() {
      var i, item, len, ref, results;
      if (this.json['order']) {
        ref = this.json['order'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    A list of all the Series.ImageModality values that are actual acquisition modalities, i.e. those in the DICOM Context Group 29 (value set OID 1.2.840.10008.6.1.19).
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudy.prototype.modalityList = function() {
      return this.json['modalityList'];
    };


    /**
    The requesting/referring physician.
    @returns {Reference}
     */

    ImagingStudy.prototype.referrer = function() {
      if (this.json['referrer']) {
        return new Reference(this.json['referrer']);
      }
    };


    /**
    Availability of study (online, offline or nearline).
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudy.prototype.availability = function() {
      return this.json['availability'];
    };


    /**
    WADO-RS URI where Study is available.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudy.prototype.url = function() {
      return this.json['url'];
    };


    /**
    Number of Series in Study.
    @returns {Array} an array of {@link Number} objects
     */

    ImagingStudy.prototype.numberOfSeries = function() {
      return this.json['numberOfSeries'];
    };


    /**
    Number of SOP Instances in Study.
    @returns {Array} an array of {@link Number} objects
     */

    ImagingStudy.prototype.numberOfInstances = function() {
      return this.json['numberOfInstances'];
    };


    /**
    Diagnoses etc provided with request.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudy.prototype.clinicalInformation = function() {
      return this.json['clinicalInformation'];
    };


    /**
    Type of procedure performed.
    @returns {Array} an array of {@link Coding} objects
     */

    ImagingStudy.prototype.procedure = function() {
      var i, item, len, ref, results;
      if (this.json['procedure']) {
        ref = this.json['procedure'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Who read study and interpreted the images.
    @returns {Reference}
     */

    ImagingStudy.prototype.interpreter = function() {
      if (this.json['interpreter']) {
        return new Reference(this.json['interpreter']);
      }
    };


    /**
    Institution-generated description or classification of the Study (component) performed.
    @returns {Array} an array of {@link String} objects
     */

    ImagingStudy.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Each study has one or more series of image instances.
    @returns {Array} an array of {@link ImagingStudySeriesComponent} objects
     */

    ImagingStudy.prototype.series = function() {
      var i, item, len, ref, results;
      if (this.json['series']) {
        ref = this.json['series'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImagingStudySeriesComponent(item));
        }
        return results;
      }
    };

    return ImagingStudy;

  })(DomainResource);

  module.exports.ImagingStudy = ImagingStudy;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],79:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Immunization, ImmunizationExplanationComponent, ImmunizationReactionComponent, ImmunizationVaccinationProtocolComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ImmunizationExplanationComponent
  @exports  ImmunizationExplanationComponent as ImmunizationExplanationComponent
   */

  ImmunizationExplanationComponent = (function(superClass) {
    extend(ImmunizationExplanationComponent, superClass);

    function ImmunizationExplanationComponent(json) {
      this.json = json;
      ImmunizationExplanationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Reasons why a vaccine was administered.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ImmunizationExplanationComponent.prototype.reason = function() {
      var i, item, len, ref, results;
      if (this.json['reason']) {
        ref = this.json['reason'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Refusal or exemption reasons.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ImmunizationExplanationComponent.prototype.refusalReason = function() {
      var i, item, len, ref, results;
      if (this.json['refusalReason']) {
        ref = this.json['refusalReason'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };

    return ImmunizationExplanationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ImmunizationReactionComponent
  @exports  ImmunizationReactionComponent as ImmunizationReactionComponent
   */

  ImmunizationReactionComponent = (function(superClass) {
    extend(ImmunizationReactionComponent, superClass);

    function ImmunizationReactionComponent(json) {
      this.json = json;
      ImmunizationReactionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Date of reaction to the immunization.
    @returns {Array} an array of {@link Date} objects
     */

    ImmunizationReactionComponent.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Details of the reaction.
    @returns {Reference}
     */

    ImmunizationReactionComponent.prototype.detail = function() {
      if (this.json['detail']) {
        return new Reference(this.json['detail']);
      }
    };


    /**
    Self-reported indicator.
    @returns {Array} an array of {@link boolean} objects
     */

    ImmunizationReactionComponent.prototype.reported = function() {
      return this.json['reported'];
    };

    return ImmunizationReactionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ImmunizationVaccinationProtocolComponent
  @exports  ImmunizationVaccinationProtocolComponent as ImmunizationVaccinationProtocolComponent
   */

  ImmunizationVaccinationProtocolComponent = (function(superClass) {
    extend(ImmunizationVaccinationProtocolComponent, superClass);

    function ImmunizationVaccinationProtocolComponent(json) {
      this.json = json;
      ImmunizationVaccinationProtocolComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Nominal position in a series.
    @returns {Array} an array of {@link Number} objects
     */

    ImmunizationVaccinationProtocolComponent.prototype.doseSequence = function() {
      return this.json['doseSequence'];
    };


    /**
    Contains the description about the protocol under which the vaccine was administered.
    @returns {Array} an array of {@link String} objects
     */

    ImmunizationVaccinationProtocolComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Indicates the authority who published the protocol?  E.g. ACIP.
    @returns {Reference}
     */

    ImmunizationVaccinationProtocolComponent.prototype.authority = function() {
      if (this.json['authority']) {
        return new Reference(this.json['authority']);
      }
    };


    /**
    One possible path to achieve presumed immunity against a disease - within the context of an authority.
    @returns {Array} an array of {@link String} objects
     */

    ImmunizationVaccinationProtocolComponent.prototype.series = function() {
      return this.json['series'];
    };


    /**
    The recommended number of doses to achieve immunity.
    @returns {Array} an array of {@link Number} objects
     */

    ImmunizationVaccinationProtocolComponent.prototype.seriesDoses = function() {
      return this.json['seriesDoses'];
    };


    /**
    The targeted disease.
    @returns {CodeableConcept}
     */

    ImmunizationVaccinationProtocolComponent.prototype.doseTarget = function() {
      if (this.json['doseTarget']) {
        return new CodeableConcept(this.json['doseTarget']);
      }
    };


    /**
    Indicates if the immunization event should "count" against  the protocol.
    @returns {CodeableConcept}
     */

    ImmunizationVaccinationProtocolComponent.prototype.doseStatus = function() {
      if (this.json['doseStatus']) {
        return new CodeableConcept(this.json['doseStatus']);
      }
    };


    /**
    Provides an explanation as to why a immunization event should or should not count against the protocol.
    @returns {CodeableConcept}
     */

    ImmunizationVaccinationProtocolComponent.prototype.doseStatusReason = function() {
      if (this.json['doseStatusReason']) {
        return new CodeableConcept(this.json['doseStatusReason']);
      }
    };

    return ImmunizationVaccinationProtocolComponent;

  })(BackboneElement);


  /**
  Immunization event information.
  @class Immunization
  @exports Immunization as Immunization
   */

  Immunization = (function(superClass) {
    extend(Immunization, superClass);

    function Immunization(json) {
      this.json = json;
      Immunization.__super__.constructor.call(this, this.json);
    }


    /**
    A unique identifier assigned to this adverse reaction record.
    @returns {Array} an array of {@link Identifier} objects
     */

    Immunization.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Date vaccine administered or was to be administered.
    @returns {Array} an array of {@link Date} objects
     */

    Immunization.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Vaccine that was administered or was to be administered.
    @returns {CodeableConcept}
     */

    Immunization.prototype.vaccineType = function() {
      if (this.json['vaccineType']) {
        return new CodeableConcept(this.json['vaccineType']);
      }
    };


    /**
    The patient to whom the vaccine was to be administered.
    @returns {Reference}
     */

    Immunization.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Indicates if the vaccination was refused.
    @returns {Array} an array of {@link boolean} objects
     */

    Immunization.prototype.refusedIndicator = function() {
      return this.json['refusedIndicator'];
    };


    /**
    True if this administration was reported rather than directly administered.
    @returns {Array} an array of {@link boolean} objects
     */

    Immunization.prototype.reported = function() {
      return this.json['reported'];
    };


    /**
    Clinician who administered the vaccine.
    @returns {Reference}
     */

    Immunization.prototype.performer = function() {
      if (this.json['performer']) {
        return new Reference(this.json['performer']);
      }
    };


    /**
    Clinician who ordered the vaccination.
    @returns {Reference}
     */

    Immunization.prototype.requester = function() {
      if (this.json['requester']) {
        return new Reference(this.json['requester']);
      }
    };


    /**
    Name of vaccine manufacturer.
    @returns {Reference}
     */

    Immunization.prototype.manufacturer = function() {
      if (this.json['manufacturer']) {
        return new Reference(this.json['manufacturer']);
      }
    };


    /**
    The service delivery location where the vaccine administration occurred.
    @returns {Reference}
     */

    Immunization.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Lot number of the  vaccine product.
    @returns {Array} an array of {@link String} objects
     */

    Immunization.prototype.lotNumber = function() {
      return this.json['lotNumber'];
    };


    /**
    Date vaccine batch expires.
    @returns {Array} an array of {@link Date} objects
     */

    Immunization.prototype.expirationDate = function() {
      if (this.json['expirationDate']) {
        return DT.DateTime.parse(this.json['expirationDate']);
      }
    };


    /**
    Body site where vaccine was administered.
    @returns {CodeableConcept}
     */

    Immunization.prototype.site = function() {
      if (this.json['site']) {
        return new CodeableConcept(this.json['site']);
      }
    };


    /**
    The path by which the vaccine product is taken into the body.
    @returns {CodeableConcept}
     */

    Immunization.prototype.route = function() {
      if (this.json['route']) {
        return new CodeableConcept(this.json['route']);
      }
    };


    /**
    The quantity of vaccine product that was administered.
    @returns {Quantity}
     */

    Immunization.prototype.doseQuantity = function() {
      if (this.json['doseQuantity']) {
        return new Quantity(this.json['doseQuantity']);
      }
    };


    /**
    Reasons why a vaccine was administered or refused.
    @returns {ImmunizationExplanationComponent}
     */

    Immunization.prototype.explanation = function() {
      if (this.json['explanation']) {
        return new ImmunizationExplanationComponent(this.json['explanation']);
      }
    };


    /**
    Categorical data indicating that an adverse event is associated in time to an immunization.
    @returns {Array} an array of {@link ImmunizationReactionComponent} objects
     */

    Immunization.prototype.reaction = function() {
      var i, item, len, ref, results;
      if (this.json['reaction']) {
        ref = this.json['reaction'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImmunizationReactionComponent(item));
        }
        return results;
      }
    };


    /**
    Contains information about the protocol(s) under which the vaccine was administered.
    @returns {Array} an array of {@link ImmunizationVaccinationProtocolComponent} objects
     */

    Immunization.prototype.vaccinationProtocol = function() {
      var i, item, len, ref, results;
      if (this.json['vaccinationProtocol']) {
        ref = this.json['vaccinationProtocol'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImmunizationVaccinationProtocolComponent(item));
        }
        return results;
      }
    };

    return Immunization;

  })(DomainResource);

  module.exports.Immunization = Immunization;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],80:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, ImmunizationRecommendation, ImmunizationRecommendationRecommendationComponent, ImmunizationRecommendationRecommendationDateCriterionComponent, ImmunizationRecommendationRecommendationProtocolComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ImmunizationRecommendationRecommendationDateCriterionComponent
  @exports  ImmunizationRecommendationRecommendationDateCriterionComponent as ImmunizationRecommendationRecommendationDateCriterionComponent
   */

  ImmunizationRecommendationRecommendationDateCriterionComponent = (function(superClass) {
    extend(ImmunizationRecommendationRecommendationDateCriterionComponent, superClass);

    function ImmunizationRecommendationRecommendationDateCriterionComponent(json) {
      this.json = json;
      ImmunizationRecommendationRecommendationDateCriterionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Date classification of recommendation - e.g. earliest date to give, latest date to give, etc.
    @returns {CodeableConcept}
     */

    ImmunizationRecommendationRecommendationDateCriterionComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Date recommendation.
    @returns {Array} an array of {@link Date} objects
     */

    ImmunizationRecommendationRecommendationDateCriterionComponent.prototype.value = function() {
      if (this.json['value']) {
        return DT.DateTime.parse(this.json['value']);
      }
    };

    return ImmunizationRecommendationRecommendationDateCriterionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ImmunizationRecommendationRecommendationProtocolComponent
  @exports  ImmunizationRecommendationRecommendationProtocolComponent as ImmunizationRecommendationRecommendationProtocolComponent
   */

  ImmunizationRecommendationRecommendationProtocolComponent = (function(superClass) {
    extend(ImmunizationRecommendationRecommendationProtocolComponent, superClass);

    function ImmunizationRecommendationRecommendationProtocolComponent(json) {
      this.json = json;
      ImmunizationRecommendationRecommendationProtocolComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    @returns {Array} an array of {@link Number} objects
     */

    ImmunizationRecommendationRecommendationProtocolComponent.prototype.doseSequence = function() {
      return this.json['doseSequence'];
    };


    /**
    Contains the description about the protocol under which the vaccine was administered.
    @returns {Array} an array of {@link String} objects
     */

    ImmunizationRecommendationRecommendationProtocolComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Indicates the authority who published the protocol?  E.g. ACIP.
    @returns {Reference}
     */

    ImmunizationRecommendationRecommendationProtocolComponent.prototype.authority = function() {
      if (this.json['authority']) {
        return new Reference(this.json['authority']);
      }
    };


    /**
    One possible path to achieve presumed immunity against a disease - within the context of an authority.
    @returns {Array} an array of {@link String} objects
     */

    ImmunizationRecommendationRecommendationProtocolComponent.prototype.series = function() {
      return this.json['series'];
    };

    return ImmunizationRecommendationRecommendationProtocolComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ImmunizationRecommendationRecommendationComponent
  @exports  ImmunizationRecommendationRecommendationComponent as ImmunizationRecommendationRecommendationComponent
   */

  ImmunizationRecommendationRecommendationComponent = (function(superClass) {
    extend(ImmunizationRecommendationRecommendationComponent, superClass);

    function ImmunizationRecommendationRecommendationComponent(json) {
      this.json = json;
      ImmunizationRecommendationRecommendationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The date the immunization recommendation was created.
    @returns {Array} an array of {@link Date} objects
     */

    ImmunizationRecommendationRecommendationComponent.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Vaccine that pertains to the recommendation.
    @returns {CodeableConcept}
     */

    ImmunizationRecommendationRecommendationComponent.prototype.vaccineType = function() {
      if (this.json['vaccineType']) {
        return new CodeableConcept(this.json['vaccineType']);
      }
    };


    /**
    This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    @returns {Array} an array of {@link Number} objects
     */

    ImmunizationRecommendationRecommendationComponent.prototype.doseNumber = function() {
      return this.json['doseNumber'];
    };


    /**
    Vaccine administration status.
    @returns {CodeableConcept}
     */

    ImmunizationRecommendationRecommendationComponent.prototype.forecastStatus = function() {
      if (this.json['forecastStatus']) {
        return new CodeableConcept(this.json['forecastStatus']);
      }
    };


    /**
    Vaccine date recommendations - e.g. earliest date to administer, latest date to administer, etc.
    @returns {Array} an array of {@link ImmunizationRecommendationRecommendationDateCriterionComponent} objects
     */

    ImmunizationRecommendationRecommendationComponent.prototype.dateCriterion = function() {
      var i, item, len, ref, results;
      if (this.json['dateCriterion']) {
        ref = this.json['dateCriterion'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImmunizationRecommendationRecommendationDateCriterionComponent(item));
        }
        return results;
      }
    };


    /**
    Contains information about the protocol under which the vaccine was administered.
    @returns {ImmunizationRecommendationRecommendationProtocolComponent}
     */

    ImmunizationRecommendationRecommendationComponent.prototype.protocol = function() {
      if (this.json['protocol']) {
        return new ImmunizationRecommendationRecommendationProtocolComponent(this.json['protocol']);
      }
    };


    /**
    Immunization event history that supports the status and recommendation.
    @returns {Array} an array of {@link Reference} objects
     */

    ImmunizationRecommendationRecommendationComponent.prototype.supportingImmunization = function() {
      var i, item, len, ref, results;
      if (this.json['supportingImmunization']) {
        ref = this.json['supportingImmunization'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    @returns {Array} an array of {@link Reference} objects
     */

    ImmunizationRecommendationRecommendationComponent.prototype.supportingPatientInformation = function() {
      var i, item, len, ref, results;
      if (this.json['supportingPatientInformation']) {
        ref = this.json['supportingPatientInformation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return ImmunizationRecommendationRecommendationComponent;

  })(BackboneElement);


  /**
  A patient's point-of-time immunization status and recommendation with optional supporting justification.
  @class ImmunizationRecommendation
  @exports ImmunizationRecommendation as ImmunizationRecommendation
   */

  ImmunizationRecommendation = (function(superClass) {
    extend(ImmunizationRecommendation, superClass);

    function ImmunizationRecommendation(json) {
      this.json = json;
      ImmunizationRecommendation.__super__.constructor.call(this, this.json);
    }


    /**
    A unique identifier assigned to this particular recommendation record.
    @returns {Array} an array of {@link Identifier} objects
     */

    ImmunizationRecommendation.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The patient who is the subject of the profile.
    @returns {Reference}
     */

    ImmunizationRecommendation.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Vaccine administration recommendations.
    @returns {Array} an array of {@link ImmunizationRecommendationRecommendationComponent} objects
     */

    ImmunizationRecommendation.prototype.recommendation = function() {
      var i, item, len, ref, results;
      if (this.json['recommendation']) {
        ref = this.json['recommendation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ImmunizationRecommendationRecommendationComponent(item));
        }
        return results;
      }
    };

    return ImmunizationRecommendation;

  })(DomainResource);

  module.exports.ImmunizationRecommendation = ImmunizationRecommendation;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],81:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, List, ListEntryComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ListEntryComponent
  @exports  ListEntryComponent as ListEntryComponent
   */

  ListEntryComponent = (function(superClass) {
    extend(ListEntryComponent, superClass);

    function ListEntryComponent(json) {
      this.json = json;
      ListEntryComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The flag allows the system constructing the list to make one or more statements about the role and significance of the item in the list.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ListEntryComponent.prototype.flag = function() {
      var i, item, len, ref, results;
      if (this.json['flag']) {
        ref = this.json['flag'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    True if this item is marked as deleted in the list.
    @returns {Array} an array of {@link boolean} objects
     */

    ListEntryComponent.prototype.deleted = function() {
      return this.json['deleted'];
    };


    /**
    When this item was added to the list.
    @returns {Array} an array of {@link Date} objects
     */

    ListEntryComponent.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    A reference to the actual resource from which data was derived.
    @returns {Reference}
     */

    ListEntryComponent.prototype.item = function() {
      if (this.json['item']) {
        return new Reference(this.json['item']);
      }
    };

    return ListEntryComponent;

  })(BackboneElement);


  /**
  A set of information summarized from a list of other resources.
  @class List
  @exports List as List
   */

  List = (function(superClass) {
    extend(List, superClass);

    function List(json) {
      this.json = json;
      List.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier for the List assigned for business purposes outside the context of FHIR.
    @returns {Array} an array of {@link Identifier} objects
     */

    List.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    This code defines the purpose of the list - why it was created.
    @returns {CodeableConcept}
     */

    List.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    The common subject (or patient) of the resources that are in the list, if there is one.
    @returns {Reference}
     */

    List.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The entity responsible for deciding what the contents of the list were.
    @returns {Reference}
     */

    List.prototype.source = function() {
      if (this.json['source']) {
        return new Reference(this.json['source']);
      }
    };


    /**
    The date that the list was prepared.
    @returns {Array} an array of {@link Date} objects
     */

    List.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Whether items in the list have a meaningful order.
    @returns {Array} an array of {@link boolean} objects
     */

    List.prototype.ordered = function() {
      return this.json['ordered'];
    };


    /**
    How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    @returns {Array} an array of {@link String} objects
     */

    List.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    Entries in this list.
    @returns {Array} an array of {@link ListEntryComponent} objects
     */

    List.prototype.entry = function() {
      var i, item, len, ref, results;
      if (this.json['entry']) {
        ref = this.json['entry'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ListEntryComponent(item));
        }
        return results;
      }
    };


    /**
    If the list is empty, why the list is empty.
    @returns {CodeableConcept}
     */

    List.prototype.emptyReason = function() {
      if (this.json['emptyReason']) {
        return new CodeableConcept(this.json['emptyReason']);
      }
    };

    return List;

  })(DomainResource);

  module.exports.List = List;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],82:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Location, LocationPositionComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class LocationPositionComponent
  @exports  LocationPositionComponent as LocationPositionComponent
   */

  LocationPositionComponent = (function(superClass) {
    extend(LocationPositionComponent, superClass);

    function LocationPositionComponent(json) {
      this.json = json;
      LocationPositionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    @returns {Array} an array of {@link Number} objects
     */

    LocationPositionComponent.prototype.longitude = function() {
      return this.json['longitude'];
    };


    /**
    Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    @returns {Array} an array of {@link Number} objects
     */

    LocationPositionComponent.prototype.latitude = function() {
      return this.json['latitude'];
    };


    /**
    Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    @returns {Array} an array of {@link Number} objects
     */

    LocationPositionComponent.prototype.altitude = function() {
      return this.json['altitude'];
    };

    return LocationPositionComponent;

  })(BackboneElement);


  /**
  Details and position information for a physical place where services are provided  and resources and participants may be stored, found, contained or accommodated.
  @class Location
  @exports Location as Location
   */

  Location = (function(superClass) {
    extend(Location, superClass);

    function Location(json) {
      this.json = json;
      Location.__super__.constructor.call(this, this.json);
    }


    /**
    Unique code or number identifying the location to its users.
    @returns {Array} an array of {@link Identifier} objects
     */

    Location.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Name of the location as used by humans. Does not need to be unique.
    @returns {Array} an array of {@link String} objects
     */

    Location.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Description of the Location, which helps in finding or referencing the place.
    @returns {Array} an array of {@link String} objects
     */

    Location.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Indicates the type of function performed at the location.
    @returns {CodeableConcept}
     */

    Location.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Location.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Physical location.
    @returns {Address}
     */

    Location.prototype.address = function() {
      if (this.json['address']) {
        return new Address(this.json['address']);
      }
    };


    /**
    Physical form of the location, e.g. building, room, vehicle, road.
    @returns {CodeableConcept}
     */

    Location.prototype.physicalType = function() {
      if (this.json['physicalType']) {
        return new CodeableConcept(this.json['physicalType']);
      }
    };


    /**
    The absolute geographic location of the Location, expressed in a KML compatible manner (see notes below for KML).
    @returns {LocationPositionComponent}
     */

    Location.prototype.position = function() {
      if (this.json['position']) {
        return new LocationPositionComponent(this.json['position']);
      }
    };


    /**
    The organization that is responsible for the provisioning and upkeep of the location.
    @returns {Reference}
     */

    Location.prototype.managingOrganization = function() {
      if (this.json['managingOrganization']) {
        return new Reference(this.json['managingOrganization']);
      }
    };


    /**
    active | suspended | inactive.
    @returns {Array} an array of {@link String} objects
     */

    Location.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Another Location which this Location is physically part of.
    @returns {Reference}
     */

    Location.prototype.partOf = function() {
      if (this.json['partOf']) {
        return new Reference(this.json['partOf']);
      }
    };


    /**
    Indicates whether a resource instance represents a specific location or a class of locations.
    @returns {Array} an array of {@link String} objects
     */

    Location.prototype.mode = function() {
      return this.json['mode'];
    };

    return Location;

  })(DomainResource);

  module.exports.Location = Location;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],83:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Media, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
  @class Media
  @exports Media as Media
   */

  Media = (function(superClass) {
    extend(Media, superClass);

    function Media(json) {
      this.json = json;
      Media.__super__.constructor.call(this, this.json);
    }


    /**
    Whether the media is a photo (still image), an audio recording, or a video recording.
    @returns {Array} an array of {@link String} objects
     */

    Media.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
    @returns {CodeableConcept}
     */

    Media.prototype.subtype = function() {
      if (this.json['subtype']) {
        return new CodeableConcept(this.json['subtype']);
      }
    };


    /**
    Identifiers associated with the image - these may include identifiers for the image itself, identifiers for the context of its collection (e.g. series ids) and context ids such as accession numbers or other workflow identifiers.
    @returns {Array} an array of {@link Identifier} objects
     */

    Media.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The date/time when the media was originally recorded. For video and audio, if the length of the recording is not insignificant, this is the start of the recording.
    @returns {Array} an array of {@link Date} objects
     */

    Media.prototype.created = function() {
      if (this.json['created']) {
        return DT.DateTime.parse(this.json['created']);
      }
    };


    /**
    Who/What this Media is a record of.
    @returns {Reference}
     */

    Media.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The person who administered the collection of the image.
    @returns {Reference}
     */

    Media.prototype.operator = function() {
      if (this.json['operator']) {
        return new Reference(this.json['operator']);
      }
    };


    /**
    The name of the imaging view e.g Lateral or Antero-posterior (AP).
    @returns {CodeableConcept}
     */

    Media.prototype.view = function() {
      if (this.json['view']) {
        return new CodeableConcept(this.json['view']);
      }
    };


    /**
    The name of the device / manufacturer of the device  that was used to make the recording.
    @returns {Array} an array of {@link String} objects
     */

    Media.prototype.deviceName = function() {
      return this.json['deviceName'];
    };


    /**
    Height of the image in pixels(photo/video).
    @returns {Array} an array of {@link Number} objects
     */

    Media.prototype.height = function() {
      return this.json['height'];
    };


    /**
    Width of the image in pixels (photo/video).
    @returns {Array} an array of {@link Number} objects
     */

    Media.prototype.width = function() {
      return this.json['width'];
    };


    /**
    The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    @returns {Array} an array of {@link Number} objects
     */

    Media.prototype.frames = function() {
      return this.json['frames'];
    };


    /**
    The duration of the recording in seconds - for audio and video.
    @returns {Array} an array of {@link Number} objects
     */

    Media.prototype.duration = function() {
      return this.json['duration'];
    };


    /**
    The actual content of the media - inline or by direct reference to the media source file.
    @returns {Attachment}
     */

    Media.prototype.content = function() {
      if (this.json['content']) {
        return new Attachment(this.json['content']);
      }
    };

    return Media;

  })(DomainResource);

  module.exports.Media = Media;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],84:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Medication, MedicationPackageComponent, MedicationPackageContentComponent, MedicationProductComponent, MedicationProductIngredientComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MedicationProductIngredientComponent
  @exports  MedicationProductIngredientComponent as MedicationProductIngredientComponent
   */

  MedicationProductIngredientComponent = (function(superClass) {
    extend(MedicationProductIngredientComponent, superClass);

    function MedicationProductIngredientComponent(json) {
      this.json = json;
      MedicationProductIngredientComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The actual ingredient - either a substance (simple ingredient) or another medication.
    @returns {Reference}
     */

    MedicationProductIngredientComponent.prototype.item = function() {
      if (this.json['item']) {
        return new Reference(this.json['item']);
      }
    };


    /**
    Specifies how many (or how much) of the items there are in this Medication.  E.g. 250 mg per tablet.
    @returns {Ratio}
     */

    MedicationProductIngredientComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Ratio(this.json['amount']);
      }
    };

    return MedicationProductIngredientComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationProductComponent
  @exports  MedicationProductComponent as MedicationProductComponent
   */

  MedicationProductComponent = (function(superClass) {
    extend(MedicationProductComponent, superClass);

    function MedicationProductComponent(json) {
      this.json = json;
      MedicationProductComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Describes the form of the item.  Powder; tables; carton.
    @returns {CodeableConcept}
     */

    MedicationProductComponent.prototype.form = function() {
      if (this.json['form']) {
        return new CodeableConcept(this.json['form']);
      }
    };


    /**
    Identifies a particular constituent of interest in the product.
    @returns {Array} an array of {@link MedicationProductIngredientComponent} objects
     */

    MedicationProductComponent.prototype.ingredient = function() {
      var i, item, len, ref, results;
      if (this.json['ingredient']) {
        ref = this.json['ingredient'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationProductIngredientComponent(item));
        }
        return results;
      }
    };

    return MedicationProductComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationPackageContentComponent
  @exports  MedicationPackageContentComponent as MedicationPackageContentComponent
   */

  MedicationPackageContentComponent = (function(superClass) {
    extend(MedicationPackageContentComponent, superClass);

    function MedicationPackageContentComponent(json) {
      this.json = json;
      MedicationPackageContentComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies one of the items in the package.
    @returns {Reference}
     */

    MedicationPackageContentComponent.prototype.item = function() {
      if (this.json['item']) {
        return new Reference(this.json['item']);
      }
    };


    /**
    The amount of the product that is in the package.
    @returns {Quantity}
     */

    MedicationPackageContentComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Quantity(this.json['amount']);
      }
    };

    return MedicationPackageContentComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationPackageComponent
  @exports  MedicationPackageComponent as MedicationPackageComponent
   */

  MedicationPackageComponent = (function(superClass) {
    extend(MedicationPackageComponent, superClass);

    function MedicationPackageComponent(json) {
      this.json = json;
      MedicationPackageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The kind of container that this package comes as.
    @returns {CodeableConcept}
     */

    MedicationPackageComponent.prototype.container = function() {
      if (this.json['container']) {
        return new CodeableConcept(this.json['container']);
      }
    };


    /**
    A set of components that go to make up the described item.
    @returns {Array} an array of {@link MedicationPackageContentComponent} objects
     */

    MedicationPackageComponent.prototype.content = function() {
      var i, item, len, ref, results;
      if (this.json['content']) {
        ref = this.json['content'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationPackageContentComponent(item));
        }
        return results;
      }
    };

    return MedicationPackageComponent;

  })(BackboneElement);


  /**
  Primarily used for identification and definition of Medication, but also covers ingredients and packaging.
  @class Medication
  @exports Medication as Medication
   */

  Medication = (function(superClass) {
    extend(Medication, superClass);

    function Medication(json) {
      this.json = json;
      Medication.__super__.constructor.call(this, this.json);
    }


    /**
    The common/commercial name of the medication absent information such as strength, form, etc.  E.g. Acetaminophen, Tylenol 3, etc.  The fully coordinated name is communicated as the display of Medication.code.
    @returns {Array} an array of {@link String} objects
     */

    Medication.prototype.name = function() {
      return this.json['name'];
    };


    /**
    A code (or set of codes) that identify this medication.   Usage note: This could be a standard drug code such as a drug regulator code, RxNorm code, SNOMED CT code, etc. It could also be a local formulary code, optionally with translations to the standard drug codes.
    @returns {CodeableConcept}
     */

    Medication.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Set to true if the item is attributable to a specific manufacturer (even if we don't know who that is).
    @returns {Array} an array of {@link boolean} objects
     */

    Medication.prototype.isBrand = function() {
      return this.json['isBrand'];
    };


    /**
    Describes the details of the manufacturer.
    @returns {Reference}
     */

    Medication.prototype.manufacturer = function() {
      if (this.json['manufacturer']) {
        return new Reference(this.json['manufacturer']);
      }
    };


    /**
    Medications are either a single administrable product or a package that contains one or more products.
    @returns {Array} an array of {@link String} objects
     */

    Medication.prototype.kind = function() {
      return this.json['kind'];
    };


    /**
    Information that only applies to products (not packages).
    @returns {MedicationProductComponent}
     */

    Medication.prototype.product = function() {
      if (this.json['product']) {
        return new MedicationProductComponent(this.json['product']);
      }
    };


    /**
    Information that only applies to packages (not products).
    @returns {MedicationPackageComponent}
     */

    Medication.prototype["package"] = function() {
      if (this.json['package']) {
        return new MedicationPackageComponent(this.json['package']);
      }
    };

    return Medication;

  })(DomainResource);

  module.exports.Medication = Medication;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],85:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, MedicationAdministration, MedicationAdministrationDosageComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MedicationAdministrationDosageComponent
  @exports  MedicationAdministrationDosageComponent as MedicationAdministrationDosageComponent
   */

  MedicationAdministrationDosageComponent = (function(superClass) {
    extend(MedicationAdministrationDosageComponent, superClass);

    function MedicationAdministrationDosageComponent(json) {
      this.json = json;
      MedicationAdministrationDosageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The timing schedule for giving the medication to the patient.  This may be a single time point (using dateTime) or it may be a start and end dateTime (Period).
    @returns {Array} an array of {@link Date} objects
     */

    MedicationAdministrationDosageComponent.prototype.timingDateTime = function() {
      if (this.json['timingDateTime']) {
        return DT.DateTime.parse(this.json['timingDateTime']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  This may be a single time point (using dateTime) or it may be a start and end dateTime (Period).
    @returns {Period}
     */

    MedicationAdministrationDosageComponent.prototype.timingPeriod = function() {
      if (this.json['timingPeriod']) {
        return new Period(this.json['timingPeriod']);
      }
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationAdministrationDosageComponent.prototype.asNeededBoolean = function() {
      return this.json['asNeededBoolean'];
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {CodeableConcept}
     */

    MedicationAdministrationDosageComponent.prototype.asNeededCodeableConcept = function() {
      if (this.json['asNeededCodeableConcept']) {
        return new CodeableConcept(this.json['asNeededCodeableConcept']);
      }
    };


    /**
    A coded specification of the anatomic site where the medication first entered the body.  E.g. "left arm".
    @returns {CodeableConcept}
     */

    MedicationAdministrationDosageComponent.prototype.site = function() {
      if (this.json['site']) {
        return new CodeableConcept(this.json['site']);
      }
    };


    /**
    A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.   E.g. topical, intravenous, etc.
    @returns {CodeableConcept}
     */

    MedicationAdministrationDosageComponent.prototype.route = function() {
      if (this.json['route']) {
        return new CodeableConcept(this.json['route']);
      }
    };


    /**
    A coded value indicating the method by which the medication was introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.
    
    Terminologies used often pre-coordinate this term with the route and or form of administration.
    @returns {CodeableConcept}
     */

    MedicationAdministrationDosageComponent.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    @returns {Quantity}
     */

    MedicationAdministrationDosageComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the speed with which the medication was introduced into the patient. Typically the rate for an infusion e.g. 200ml in 2 hours.  May also expressed as a rate per unit of time such as 100ml per hour - the duration is then not specified, or is specified in the quantity.
    @returns {Ratio}
     */

    MedicationAdministrationDosageComponent.prototype.rate = function() {
      if (this.json['rate']) {
        return new Ratio(this.json['rate']);
      }
    };


    /**
    The maximum total quantity of a therapeutic substance that was administered to the patient over the specified period of time. E.g. 1000mg in 24 hours.
    @returns {Ratio}
     */

    MedicationAdministrationDosageComponent.prototype.maxDosePerPeriod = function() {
      if (this.json['maxDosePerPeriod']) {
        return new Ratio(this.json['maxDosePerPeriod']);
      }
    };

    return MedicationAdministrationDosageComponent;

  })(BackboneElement);


  /**
  Describes the event of a patient being given a dose of a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.
  
  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
  @class MedicationAdministration
  @exports MedicationAdministration as MedicationAdministration
   */

  MedicationAdministration = (function(superClass) {
    extend(MedicationAdministration, superClass);

    function MedicationAdministration(json) {
      this.json = json;
      MedicationAdministration.__super__.constructor.call(this, this.json);
    }


    /**
    External identifier - FHIR will generate its own internal IDs (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    @returns {Array} an array of {@link Identifier} objects
     */

    MedicationAdministration.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Will generally be set to show that the administration has been completed.  For some long running administrations such as infusions it is possible for an administration to be started but not completed or it may be paused while some other process is under way.
    @returns {Array} an array of {@link String} objects
     */

    MedicationAdministration.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The person or animal to whom the medication was given.
    @returns {Reference}
     */

    MedicationAdministration.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The individual who was responsible for giving the medication to the patient.
    @returns {Reference}
     */

    MedicationAdministration.prototype.practitioner = function() {
      if (this.json['practitioner']) {
        return new Reference(this.json['practitioner']);
      }
    };


    /**
    The visit or admission the or other contact between patient and health care provider the medication administration was performed as part of.
    @returns {Reference}
     */

    MedicationAdministration.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    The original request, instruction or authority to perform the administration.
    @returns {Reference}
     */

    MedicationAdministration.prototype.prescription = function() {
      if (this.json['prescription']) {
        return new Reference(this.json['prescription']);
      }
    };


    /**
    Set this to true if the record is saying that the medication was NOT administered.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationAdministration.prototype.wasNotGiven = function() {
      return this.json['wasNotGiven'];
    };


    /**
    A code indicating why the administration was not performed.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    MedicationAdministration.prototype.reasonNotGiven = function() {
      var i, item, len, ref, results;
      if (this.json['reasonNotGiven']) {
        ref = this.json['reasonNotGiven'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    An interval of time during which the administration took place.  For many administrations, such as swallowing a tablet the lower and upper values of the interval will be the same.
    @returns {Array} an array of {@link Date} objects
     */

    MedicationAdministration.prototype.effectiveTimeDateTime = function() {
      if (this.json['effectiveTimeDateTime']) {
        return DT.DateTime.parse(this.json['effectiveTimeDateTime']);
      }
    };


    /**
    An interval of time during which the administration took place.  For many administrations, such as swallowing a tablet the lower and upper values of the interval will be the same.
    @returns {Period}
     */

    MedicationAdministration.prototype.effectiveTimePeriod = function() {
      if (this.json['effectiveTimePeriod']) {
        return new Period(this.json['effectiveTimePeriod']);
      }
    };


    /**
    Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    @returns {Reference}
     */

    MedicationAdministration.prototype.medication = function() {
      if (this.json['medication']) {
        return new Reference(this.json['medication']);
      }
    };


    /**
    The device used in administering the medication to the patient.  E.g. a particular infusion pump.
    @returns {Array} an array of {@link Reference} objects
     */

    MedicationAdministration.prototype.device = function() {
      var i, item, len, ref, results;
      if (this.json['device']) {
        ref = this.json['device'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Provides details of how much of the medication was administered.
    @returns {Array} an array of {@link MedicationAdministrationDosageComponent} objects
     */

    MedicationAdministration.prototype.dosage = function() {
      var i, item, len, ref, results;
      if (this.json['dosage']) {
        ref = this.json['dosage'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationAdministrationDosageComponent(item));
        }
        return results;
      }
    };

    return MedicationAdministration;

  })(DomainResource);

  module.exports.MedicationAdministration = MedicationAdministration;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],86:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, MedicationDispense, MedicationDispenseDispenseComponent, MedicationDispenseDispenseDosageComponent, MedicationDispenseSubstitutionComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MedicationDispenseDispenseDosageComponent
  @exports  MedicationDispenseDispenseDosageComponent as MedicationDispenseDispenseDosageComponent
   */

  MedicationDispenseDispenseDosageComponent = (function(superClass) {
    extend(MedicationDispenseDispenseDosageComponent, superClass);

    function MedicationDispenseDispenseDosageComponent(json) {
      this.json = json;
      MedicationDispenseDispenseDosageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseDosageComponent.prototype.additionalInstructions = function() {
      if (this.json['additionalInstructions']) {
        return new CodeableConcept(this.json['additionalInstructions']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Array} an array of {@link Date} objects
     */

    MedicationDispenseDispenseDosageComponent.prototype.scheduleDateTime = function() {
      if (this.json['scheduleDateTime']) {
        return DT.DateTime.parse(this.json['scheduleDateTime']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Period}
     */

    MedicationDispenseDispenseDosageComponent.prototype.schedulePeriod = function() {
      if (this.json['schedulePeriod']) {
        return new Period(this.json['schedulePeriod']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Timing}
     */

    MedicationDispenseDispenseDosageComponent.prototype.scheduleTiming = function() {
      if (this.json['scheduleTiming']) {
        return new Timing(this.json['scheduleTiming']);
      }
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationDispenseDispenseDosageComponent.prototype.asNeededBoolean = function() {
      return this.json['asNeededBoolean'];
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseDosageComponent.prototype.asNeededCodeableConcept = function() {
      if (this.json['asNeededCodeableConcept']) {
        return new CodeableConcept(this.json['asNeededCodeableConcept']);
      }
    };


    /**
    A coded specification of the anatomic site where the medication first enters the body.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseDosageComponent.prototype.site = function() {
      if (this.json['site']) {
        return new CodeableConcept(this.json['site']);
      }
    };


    /**
    A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseDosageComponent.prototype.route = function() {
      if (this.json['route']) {
        return new CodeableConcept(this.json['route']);
      }
    };


    /**
    A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.
    
    Terminologies used often pre-coordinate this term with the route and or form of administration.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseDosageComponent.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    The amount of therapeutic or other substance given at one administration event.
    @returns {Quantity}
     */

    MedicationDispenseDispenseDosageComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    @returns {Ratio}
     */

    MedicationDispenseDispenseDosageComponent.prototype.rate = function() {
      if (this.json['rate']) {
        return new Ratio(this.json['rate']);
      }
    };


    /**
    The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time,  e.g. 1000mg in 24 hours.
    @returns {Ratio}
     */

    MedicationDispenseDispenseDosageComponent.prototype.maxDosePerPeriod = function() {
      if (this.json['maxDosePerPeriod']) {
        return new Ratio(this.json['maxDosePerPeriod']);
      }
    };

    return MedicationDispenseDispenseDosageComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationDispenseDispenseComponent
  @exports  MedicationDispenseDispenseComponent as MedicationDispenseDispenseComponent
   */

  MedicationDispenseDispenseComponent = (function(superClass) {
    extend(MedicationDispenseDispenseComponent, superClass);

    function MedicationDispenseDispenseComponent(json) {
      this.json = json;
      MedicationDispenseDispenseComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned by the dispensing facility.   This is an identifier assigned outside FHIR.
    @returns {Identifier}
     */

    MedicationDispenseDispenseComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    A code specifying the state of the dispense event.
    @returns {Array} an array of {@link String} objects
     */

    MedicationDispenseDispenseComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    @returns {CodeableConcept}
     */

    MedicationDispenseDispenseComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The amount of medication that has been dispensed. Includes unit of measure.
    @returns {Quantity}
     */

    MedicationDispenseDispenseComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    @returns {Reference}
     */

    MedicationDispenseDispenseComponent.prototype.medication = function() {
      if (this.json['medication']) {
        return new Reference(this.json['medication']);
      }
    };


    /**
    The time when the dispensed product was packaged and reviewed.
    @returns {Array} an array of {@link Date} objects
     */

    MedicationDispenseDispenseComponent.prototype.whenPrepared = function() {
      if (this.json['whenPrepared']) {
        return DT.DateTime.parse(this.json['whenPrepared']);
      }
    };


    /**
    The time the dispensed product was provided to the patient or their representative.
    @returns {Array} an array of {@link Date} objects
     */

    MedicationDispenseDispenseComponent.prototype.whenHandedOver = function() {
      if (this.json['whenHandedOver']) {
        return DT.DateTime.parse(this.json['whenHandedOver']);
      }
    };


    /**
    Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    @returns {Reference}
     */

    MedicationDispenseDispenseComponent.prototype.destination = function() {
      if (this.json['destination']) {
        return new Reference(this.json['destination']);
      }
    };


    /**
    Identifies the person who picked up the medication.  This will usually be a patient or their carer, but some cases exist where it can be a healthcare professional.
    @returns {Array} an array of {@link Reference} objects
     */

    MedicationDispenseDispenseComponent.prototype.receiver = function() {
      var i, item, len, ref, results;
      if (this.json['receiver']) {
        ref = this.json['receiver'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Indicates how the medication is to be used by the patient.
    @returns {Array} an array of {@link MedicationDispenseDispenseDosageComponent} objects
     */

    MedicationDispenseDispenseComponent.prototype.dosage = function() {
      var i, item, len, ref, results;
      if (this.json['dosage']) {
        ref = this.json['dosage'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationDispenseDispenseDosageComponent(item));
        }
        return results;
      }
    };

    return MedicationDispenseDispenseComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationDispenseSubstitutionComponent
  @exports  MedicationDispenseSubstitutionComponent as MedicationDispenseSubstitutionComponent
   */

  MedicationDispenseSubstitutionComponent = (function(superClass) {
    extend(MedicationDispenseSubstitutionComponent, superClass);

    function MedicationDispenseSubstitutionComponent(json) {
      this.json = json;
      MedicationDispenseSubstitutionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code signifying whether a different drug was dispensed from what was prescribed.
    @returns {CodeableConcept}
     */

    MedicationDispenseSubstitutionComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    MedicationDispenseSubstitutionComponent.prototype.reason = function() {
      var i, item, len, ref, results;
      if (this.json['reason']) {
        ref = this.json['reason'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The person or organization that has primary responsibility for the substitution.
    @returns {Array} an array of {@link Reference} objects
     */

    MedicationDispenseSubstitutionComponent.prototype.responsibleParty = function() {
      var i, item, len, ref, results;
      if (this.json['responsibleParty']) {
        ref = this.json['responsibleParty'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return MedicationDispenseSubstitutionComponent;

  })(BackboneElement);


  /**
  Dispensing a medication to a named patient.  This includes a description of the supply provided and the instructions for administering the medication.
  @class MedicationDispense
  @exports MedicationDispense as MedicationDispense
   */

  MedicationDispense = (function(superClass) {
    extend(MedicationDispense, superClass);

    function MedicationDispense(json) {
      this.json = json;
      MedicationDispense.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned by the dispensing facility - this is an identifier assigned outside FHIR.
    @returns {Identifier}
     */

    MedicationDispense.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    A code specifying the state of the set of dispense events.
    @returns {Array} an array of {@link String} objects
     */

    MedicationDispense.prototype.status = function() {
      return this.json['status'];
    };


    /**
    A link to a resource representing the person to whom the medication will be given.
    @returns {Reference}
     */

    MedicationDispense.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The individual responsible for dispensing the medication.
    @returns {Reference}
     */

    MedicationDispense.prototype.dispenser = function() {
      if (this.json['dispenser']) {
        return new Reference(this.json['dispenser']);
      }
    };


    /**
    Indicates the medication order that is being dispensed against.
    @returns {Array} an array of {@link Reference} objects
     */

    MedicationDispense.prototype.authorizingPrescription = function() {
      var i, item, len, ref, results;
      if (this.json['authorizingPrescription']) {
        ref = this.json['authorizingPrescription'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Indicates the details of the dispense event such as the days supply and quantity of medication dispensed.
    @returns {Array} an array of {@link MedicationDispenseDispenseComponent} objects
     */

    MedicationDispense.prototype.dispense = function() {
      var i, item, len, ref, results;
      if (this.json['dispense']) {
        ref = this.json['dispense'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationDispenseDispenseComponent(item));
        }
        return results;
      }
    };


    /**
    Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but doesn't happen, in other cases substitution is not expected but does happen.  This block explains what substitition did or did not happen and why.
    @returns {MedicationDispenseSubstitutionComponent}
     */

    MedicationDispense.prototype.substitution = function() {
      if (this.json['substitution']) {
        return new MedicationDispenseSubstitutionComponent(this.json['substitution']);
      }
    };

    return MedicationDispense;

  })(DomainResource);

  module.exports.MedicationDispense = MedicationDispense;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],87:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, MedicationPrescription, MedicationPrescriptionDispenseComponent, MedicationPrescriptionDosageInstructionComponent, MedicationPrescriptionSubstitutionComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MedicationPrescriptionDosageInstructionComponent
  @exports  MedicationPrescriptionDosageInstructionComponent as MedicationPrescriptionDosageInstructionComponent
   */

  MedicationPrescriptionDosageInstructionComponent = (function(superClass) {
    extend(MedicationPrescriptionDosageInstructionComponent, superClass);

    function MedicationPrescriptionDosageInstructionComponent(json) {
      this.json = json;
      MedicationPrescriptionDosageInstructionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Free text dosage instructions for cases where the instructions are too complex to code.
    @returns {Array} an array of {@link String} objects
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.text = function() {
      return this.json['text'];
    };


    /**
    Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.additionalInstructions = function() {
      if (this.json['additionalInstructions']) {
        return new CodeableConcept(this.json['additionalInstructions']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Array} an array of {@link Date} objects
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.scheduledDateTime = function() {
      if (this.json['scheduledDateTime']) {
        return DT.DateTime.parse(this.json['scheduledDateTime']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Period}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.scheduledPeriod = function() {
      if (this.json['scheduledPeriod']) {
        return new Period(this.json['scheduledPeriod']);
      }
    };


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Timing}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.scheduledTiming = function() {
      if (this.json['scheduledTiming']) {
        return new Timing(this.json['scheduledTiming']);
      }
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.asNeededBoolean = function() {
      return this.json['asNeededBoolean'];
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.asNeededCodeableConcept = function() {
      if (this.json['asNeededCodeableConcept']) {
        return new CodeableConcept(this.json['asNeededCodeableConcept']);
      }
    };


    /**
    A coded specification of the anatomic site where the medication first enters the body.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.site = function() {
      if (this.json['site']) {
        return new CodeableConcept(this.json['site']);
      }
    };


    /**
    A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.route = function() {
      if (this.json['route']) {
        return new CodeableConcept(this.json['route']);
      }
    };


    /**
    A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.
    
    Terminologies used often pre-coordinate this term with the route and or form of administration.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    The amount of therapeutic or other substance given at one administration event.
    @returns {Quantity}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.doseQuantity = function() {
      if (this.json['doseQuantity']) {
        return new Quantity(this.json['doseQuantity']);
      }
    };


    /**
    Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    @returns {Ratio}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.rate = function() {
      if (this.json['rate']) {
        return new Ratio(this.json['rate']);
      }
    };


    /**
    The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    @returns {Ratio}
     */

    MedicationPrescriptionDosageInstructionComponent.prototype.maxDosePerPeriod = function() {
      if (this.json['maxDosePerPeriod']) {
        return new Ratio(this.json['maxDosePerPeriod']);
      }
    };

    return MedicationPrescriptionDosageInstructionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationPrescriptionDispenseComponent
  @exports  MedicationPrescriptionDispenseComponent as MedicationPrescriptionDispenseComponent
   */

  MedicationPrescriptionDispenseComponent = (function(superClass) {
    extend(MedicationPrescriptionDispenseComponent, superClass);

    function MedicationPrescriptionDispenseComponent(json) {
      this.json = json;
      MedicationPrescriptionDispenseComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the medication that is to be dispensed.  This may be a more specifically defined than the medicationPrescription.medication . This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    @returns {Reference}
     */

    MedicationPrescriptionDispenseComponent.prototype.medication = function() {
      if (this.json['medication']) {
        return new Reference(this.json['medication']);
      }
    };


    /**
    Design Comments: This indicates the validity period of a prescription (stale dating the Prescription) 
    It reflects the prescriber perspective for the validity of the prescription. Dispenses must not be made against the prescription outside of this period. The lower-bound of the Dispensing Window signifies the earliest date that the prescription can be filled for the first time. If an upper-bound is not specified then the Prescription is open-ended or will default to a stale-date based on regulations. 
    Rationale: Indicates when the Prescription becomes valid, and when it ceases to be a dispensable Prescription.
    @returns {Period}
     */

    MedicationPrescriptionDispenseComponent.prototype.validityPeriod = function() {
      if (this.json['validityPeriod']) {
        return new Period(this.json['validityPeriod']);
      }
    };


    /**
    An integer indicating the number of repeats of the Dispense. 
    UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    @returns {Array} an array of {@link Number} objects
     */

    MedicationPrescriptionDispenseComponent.prototype.numberOfRepeatsAllowed = function() {
      return this.json['numberOfRepeatsAllowed'];
    };


    /**
    The amount that is to be dispensed.
    @returns {Quantity}
     */

    MedicationPrescriptionDispenseComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. 
    In some situations, this attribute may be used instead of quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued, e.g. 90 days supply of medication (based on an ordered dosage) When possible, it is always better to specify quantity, as this tends to be more precise. expectedSupplyDuration will always be an estimate that can be influenced by external factors.
    @returns {Duration}
     */

    MedicationPrescriptionDispenseComponent.prototype.expectedSupplyDuration = function() {
      if (this.json['expectedSupplyDuration']) {
        return new Duration(this.json['expectedSupplyDuration']);
      }
    };

    return MedicationPrescriptionDispenseComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MedicationPrescriptionSubstitutionComponent
  @exports  MedicationPrescriptionSubstitutionComponent as MedicationPrescriptionSubstitutionComponent
   */

  MedicationPrescriptionSubstitutionComponent = (function(superClass) {
    extend(MedicationPrescriptionSubstitutionComponent, superClass);

    function MedicationPrescriptionSubstitutionComponent(json) {
      this.json = json;
      MedicationPrescriptionSubstitutionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code signifying whether a different drug should be dispensed from what was prescribed.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionSubstitutionComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Indicates the reason for the substitution, or why substitution must or must not be performed.
    @returns {CodeableConcept}
     */

    MedicationPrescriptionSubstitutionComponent.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };

    return MedicationPrescriptionSubstitutionComponent;

  })(BackboneElement);


  /**
  An order for both supply of the medication and the instructions for administration of the medicine to a patient.
  @class MedicationPrescription
  @exports MedicationPrescription as MedicationPrescription
   */

  MedicationPrescription = (function(superClass) {
    extend(MedicationPrescription, superClass);

    function MedicationPrescription(json) {
      this.json = json;
      MedicationPrescription.__super__.constructor.call(this, this.json);
    }


    /**
    External identifier - one that would be used by another non-FHIR system - for example a re-imbursement system might issue its own id for each prescription that is created.  This is particularly important where FHIR only provides part of an erntire workflow process where records have to be tracked through an entire system.
    @returns {Array} an array of {@link Identifier} objects
     */

    MedicationPrescription.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The date (and perhaps time) when the prescription was written.
    @returns {Array} an array of {@link Date} objects
     */

    MedicationPrescription.prototype.dateWritten = function() {
      if (this.json['dateWritten']) {
        return DT.DateTime.parse(this.json['dateWritten']);
      }
    };


    /**
    A code specifying the state of the order.  Generally this will be active or completed state.
    @returns {Array} an array of {@link String} objects
     */

    MedicationPrescription.prototype.status = function() {
      return this.json['status'];
    };


    /**
    A link to a resource representing the person to whom the medication will be given.
    @returns {Reference}
     */

    MedicationPrescription.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The healthcare professional responsible for authorizing the prescription.
    @returns {Reference}
     */

    MedicationPrescription.prototype.prescriber = function() {
      if (this.json['prescriber']) {
        return new Reference(this.json['prescriber']);
      }
    };


    /**
    A link to a resource that identifies the particular occurrence of contact between patient and health care provider.
    @returns {Reference}
     */

    MedicationPrescription.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Can be the reason or the indication for writing the prescription.
    @returns {CodeableConcept}
     */

    MedicationPrescription.prototype.reasonCodeableConcept = function() {
      if (this.json['reasonCodeableConcept']) {
        return new CodeableConcept(this.json['reasonCodeableConcept']);
      }
    };


    /**
    Can be the reason or the indication for writing the prescription.
    @returns {Reference}
     */

    MedicationPrescription.prototype.reasonReference = function() {
      if (this.json['reasonReference']) {
        return new Reference(this.json['reasonReference']);
      }
    };


    /**
    Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    @returns {Reference}
     */

    MedicationPrescription.prototype.medication = function() {
      if (this.json['medication']) {
        return new Reference(this.json['medication']);
      }
    };


    /**
    Indicates how the medication is to be used by the patient.
    @returns {Array} an array of {@link MedicationPrescriptionDosageInstructionComponent} objects
     */

    MedicationPrescription.prototype.dosageInstruction = function() {
      var i, item, len, ref, results;
      if (this.json['dosageInstruction']) {
        ref = this.json['dosageInstruction'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationPrescriptionDosageInstructionComponent(item));
        }
        return results;
      }
    };


    /**
    Deals with details of the dispense part of the order.
    @returns {MedicationPrescriptionDispenseComponent}
     */

    MedicationPrescription.prototype.dispense = function() {
      if (this.json['dispense']) {
        return new MedicationPrescriptionDispenseComponent(this.json['dispense']);
      }
    };


    /**
    Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done.
    @returns {MedicationPrescriptionSubstitutionComponent}
     */

    MedicationPrescription.prototype.substitution = function() {
      if (this.json['substitution']) {
        return new MedicationPrescriptionSubstitutionComponent(this.json['substitution']);
      }
    };

    return MedicationPrescription;

  })(DomainResource);

  module.exports.MedicationPrescription = MedicationPrescription;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],88:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, MedicationStatement, MedicationStatementDosageComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MedicationStatementDosageComponent
  @exports  MedicationStatementDosageComponent as MedicationStatementDosageComponent
   */

  MedicationStatementDosageComponent = (function(superClass) {
    extend(MedicationStatementDosageComponent, superClass);

    function MedicationStatementDosageComponent(json) {
      this.json = json;
      MedicationStatementDosageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Timing}
     */

    MedicationStatementDosageComponent.prototype.schedule = function() {
      if (this.json['schedule']) {
        return new Timing(this.json['schedule']);
      }
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationStatementDosageComponent.prototype.asNeededBoolean = function() {
      return this.json['asNeededBoolean'];
    };


    /**
    If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    @returns {CodeableConcept}
     */

    MedicationStatementDosageComponent.prototype.asNeededCodeableConcept = function() {
      if (this.json['asNeededCodeableConcept']) {
        return new CodeableConcept(this.json['asNeededCodeableConcept']);
      }
    };


    /**
    A coded specification of the anatomic site where the medication first enters the body.
    @returns {CodeableConcept}
     */

    MedicationStatementDosageComponent.prototype.site = function() {
      if (this.json['site']) {
        return new CodeableConcept(this.json['site']);
      }
    };


    /**
    A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    @returns {CodeableConcept}
     */

    MedicationStatementDosageComponent.prototype.route = function() {
      if (this.json['route']) {
        return new CodeableConcept(this.json['route']);
      }
    };


    /**
    A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.
    
    Terminologies used often pre-coordinate this term with the route and or form of administration.
    @returns {CodeableConcept}
     */

    MedicationStatementDosageComponent.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    The amount of therapeutic or other substance given at one administration event.
    @returns {Quantity}
     */

    MedicationStatementDosageComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    @returns {Ratio}
     */

    MedicationStatementDosageComponent.prototype.rate = function() {
      if (this.json['rate']) {
        return new Ratio(this.json['rate']);
      }
    };


    /**
    The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    @returns {Ratio}
     */

    MedicationStatementDosageComponent.prototype.maxDosePerPeriod = function() {
      if (this.json['maxDosePerPeriod']) {
        return new Ratio(this.json['maxDosePerPeriod']);
      }
    };

    return MedicationStatementDosageComponent;

  })(BackboneElement);


  /**
  A record of medication being taken by a patient, or that the medication has been given to a patient where the record is the result of a report from the patient or another clinician.
  @class MedicationStatement
  @exports MedicationStatement as MedicationStatement
   */

  MedicationStatement = (function(superClass) {
    extend(MedicationStatement, superClass);

    function MedicationStatement(json) {
      this.json = json;
      MedicationStatement.__super__.constructor.call(this, this.json);
    }


    /**
    External identifier - FHIR will generate its own internal IDs (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    @returns {Array} an array of {@link Identifier} objects
     */

    MedicationStatement.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The person or animal who is /was taking the medication.
    @returns {Reference}
     */

    MedicationStatement.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Set this to true if the record is saying that the medication was NOT taken.
    @returns {Array} an array of {@link boolean} objects
     */

    MedicationStatement.prototype.wasNotGiven = function() {
      return this.json['wasNotGiven'];
    };


    /**
    A code indicating why the medication was not taken.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    MedicationStatement.prototype.reasonNotGiven = function() {
      var i, item, len, ref, results;
      if (this.json['reasonNotGiven']) {
        ref = this.json['reasonNotGiven'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The interval of time during which it is being asserted that the patient was taking the medication.
    @returns {Period}
     */

    MedicationStatement.prototype.whenGiven = function() {
      if (this.json['whenGiven']) {
        return new Period(this.json['whenGiven']);
      }
    };


    /**
    Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    @returns {Reference}
     */

    MedicationStatement.prototype.medication = function() {
      if (this.json['medication']) {
        return new Reference(this.json['medication']);
      }
    };


    /**
    An identifier or a link to a resource that identifies a device used in administering the medication to the patient.
    @returns {Array} an array of {@link Reference} objects
     */

    MedicationStatement.prototype.device = function() {
      var i, item, len, ref, results;
      if (this.json['device']) {
        ref = this.json['device'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Indicates how the medication is/was used by the patient.
    @returns {Array} an array of {@link MedicationStatementDosageComponent} objects
     */

    MedicationStatement.prototype.dosage = function() {
      var i, item, len, ref, results;
      if (this.json['dosage']) {
        ref = this.json['dosage'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MedicationStatementDosageComponent(item));
        }
        return results;
      }
    };

    return MedicationStatement;

  })(DomainResource);

  module.exports.MedicationStatement = MedicationStatement;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],89:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, MessageDestinationComponent, MessageHeader, MessageHeaderResponseComponent, MessageSourceComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class MessageHeaderResponseComponent
  @exports  MessageHeaderResponseComponent as MessageHeaderResponseComponent
   */

  MessageHeaderResponseComponent = (function(superClass) {
    extend(MessageHeaderResponseComponent, superClass);

    function MessageHeaderResponseComponent(json) {
      this.json = json;
      MessageHeaderResponseComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The id of the message that this message is a response to.
    @returns {Array} an array of {@link String} objects
     */

    MessageHeaderResponseComponent.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    @returns {Array} an array of {@link String} objects
     */

    MessageHeaderResponseComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    Full details of any issues found in the message.
    @returns {Reference}
     */

    MessageHeaderResponseComponent.prototype.details = function() {
      if (this.json['details']) {
        return new Reference(this.json['details']);
      }
    };

    return MessageHeaderResponseComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MessageSourceComponent
  @exports  MessageSourceComponent as MessageSourceComponent
   */

  MessageSourceComponent = (function(superClass) {
    extend(MessageSourceComponent, superClass);

    function MessageSourceComponent(json) {
      this.json = json;
      MessageSourceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Human-readable name for the source system.
    @returns {Array} an array of {@link String} objects
     */

    MessageSourceComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    May include configuration or other information useful in debugging.
    @returns {Array} an array of {@link String} objects
     */

    MessageSourceComponent.prototype.software = function() {
      return this.json['software'];
    };


    /**
    Can convey versions of multiple systems in situations where a message passes through multiple hands.
    @returns {Array} an array of {@link String} objects
     */

    MessageSourceComponent.prototype.version = function() {
      return this.json['version'];
    };


    /**
    An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    @returns {ContactPoint}
     */

    MessageSourceComponent.prototype.contact = function() {
      if (this.json['contact']) {
        return new ContactPoint(this.json['contact']);
      }
    };


    /**
    Identifies the routing target to send acknowledgements to.
    @returns {Array} an array of {@link String} objects
     */

    MessageSourceComponent.prototype.endpoint = function() {
      return this.json['endpoint'];
    };

    return MessageSourceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MessageDestinationComponent
  @exports  MessageDestinationComponent as MessageDestinationComponent
   */

  MessageDestinationComponent = (function(superClass) {
    extend(MessageDestinationComponent, superClass);

    function MessageDestinationComponent(json) {
      this.json = json;
      MessageDestinationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Human-readable name for the target system.
    @returns {Array} an array of {@link String} objects
     */

    MessageDestinationComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    @returns {Reference}
     */

    MessageDestinationComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    Indicates where the message should be routed to.
    @returns {Array} an array of {@link String} objects
     */

    MessageDestinationComponent.prototype.endpoint = function() {
      return this.json['endpoint'];
    };

    return MessageDestinationComponent;

  })(BackboneElement);


  /**
  The header for a message exchange that is either requesting or responding to an action.  The Reference(s) that are the subject of the action as well as other Information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  @class MessageHeader
  @exports MessageHeader as MessageHeader
   */

  MessageHeader = (function(superClass) {
    extend(MessageHeader, superClass);

    function MessageHeader(json) {
      this.json = json;
      MessageHeader.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier of this message.
    @returns {Array} an array of {@link String} objects
     */

    MessageHeader.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    The time that the message was sent.
    @returns {Array} an array of {@link Date} objects
     */

    MessageHeader.prototype.timestamp = function() {
      if (this.json['timestamp']) {
        return DT.DateTime.parse(this.json['timestamp']);
      }
    };


    /**
    Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://hl7.org/fhir/message-type".
    @returns {Coding}
     */

    MessageHeader.prototype.event = function() {
      if (this.json['event']) {
        return new Coding(this.json['event']);
      }
    };


    /**
    Information about the message that this message is a response to.  Only present if this message is a response.
    @returns {MessageHeaderResponseComponent}
     */

    MessageHeader.prototype.response = function() {
      if (this.json['response']) {
        return new MessageHeaderResponseComponent(this.json['response']);
      }
    };


    /**
    The source application from which this message originated.
    @returns {MessageSourceComponent}
     */

    MessageHeader.prototype.source = function() {
      if (this.json['source']) {
        return new MessageSourceComponent(this.json['source']);
      }
    };


    /**
    The destination application which the message is intended for.
    @returns {Array} an array of {@link MessageDestinationComponent} objects
     */

    MessageHeader.prototype.destination = function() {
      var i, item, len, ref, results;
      if (this.json['destination']) {
        ref = this.json['destination'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MessageDestinationComponent(item));
        }
        return results;
      }
    };


    /**
    The person or device that performed the data entry leading to this message. Where there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    @returns {Reference}
     */

    MessageHeader.prototype.enterer = function() {
      if (this.json['enterer']) {
        return new Reference(this.json['enterer']);
      }
    };


    /**
    The logical author of the message - the person or device that decided the described event should happen. Where there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    @returns {Reference}
     */

    MessageHeader.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    @returns {Reference}
     */

    MessageHeader.prototype.receiver = function() {
      if (this.json['receiver']) {
        return new Reference(this.json['receiver']);
      }
    };


    /**
    The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    @returns {Reference}
     */

    MessageHeader.prototype.responsible = function() {
      if (this.json['responsible']) {
        return new Reference(this.json['responsible']);
      }
    };


    /**
    Coded indication of the cause for the event - indicates  a reason for the occurance of the event that is a focus of this message.
    @returns {CodeableConcept}
     */

    MessageHeader.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };


    /**
    The actual data of the message - a reference to the root/focus class of the event.
    @returns {Array} an array of {@link Reference} objects
     */

    MessageHeader.prototype.data = function() {
      var i, item, len, ref, results;
      if (this.json['data']) {
        ref = this.json['data'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return MessageHeader;

  })(DomainResource);

  module.exports.MessageHeader = MessageHeader;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],90:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  module.exports = require('./core');

  module.exports.Condition = require('./condition').Condition;

  module.exports.Supply = require('./supply').Supply;

  module.exports.ProcedureRequest = require('./procedurerequest').ProcedureRequest;

  module.exports.DeviceComponent = require('./devicecomponent').DeviceComponent;

  module.exports.Organization = require('./organization').Organization;

  module.exports.Readjudicate = require('./readjudicate').Readjudicate;

  module.exports.Group = require('./group').Group;

  module.exports.OralHealthClaim = require('./oralhealthclaim').OralHealthClaim;

  module.exports.ValueSet = require('./valueset').ValueSet;

  module.exports.Coverage = require('./coverage').Coverage;

  module.exports.ImmunizationRecommendation = require('./immunizationrecommendation').ImmunizationRecommendation;

  module.exports.Appointment = require('./appointment').Appointment;

  module.exports.MedicationDispense = require('./medicationdispense').MedicationDispense;

  module.exports.MedicationPrescription = require('./medicationprescription').MedicationPrescription;

  module.exports.Slot = require('./slot').Slot;

  module.exports.PaymentNotice = require('./paymentnotice').PaymentNotice;

  module.exports.Contraindication = require('./contraindication').Contraindication;

  module.exports.AppointmentResponse = require('./appointmentresponse').AppointmentResponse;

  module.exports.MedicationStatement = require('./medicationstatement').MedicationStatement;

  module.exports.Questionnaire = require('./questionnaire').Questionnaire;

  module.exports.Composition = require('./composition').Composition;

  module.exports.OperationOutcome = require('./operationoutcome').OperationOutcome;

  module.exports.Conformance = require('./conformance').Conformance;

  module.exports.NamingSystem = require('./namingsystem').NamingSystem;

  module.exports.Media = require('./media').Media;

  module.exports.Binary = require('./binary').Binary;

  module.exports.Other = require('./other').Other;

  module.exports.HealthcareService = require('./healthcareservice').HealthcareService;

  module.exports.Profile = require('./profile').Profile;

  module.exports.DocumentReference = require('./documentreference').DocumentReference;

  module.exports.Eligibility = require('./eligibility').Eligibility;

  module.exports.Immunization = require('./immunization').Immunization;

  module.exports.Bundle = require('./bundle').Bundle;

  module.exports.ExtensionDefinition = require('./extensiondefinition').ExtensionDefinition;

  module.exports.Subscription = require('./subscription').Subscription;

  module.exports.OrderResponse = require('./orderresponse').OrderResponse;

  module.exports.StatusResponse = require('./statusresponse').StatusResponse;

  module.exports.ConceptMap = require('./conceptmap').ConceptMap;

  module.exports.Reversal = require('./reversal').Reversal;

  module.exports.ImagingStudy = require('./imagingstudy').ImagingStudy;

  module.exports.Practitioner = require('./practitioner').Practitioner;

  module.exports.CarePlan = require('./careplan').CarePlan;

  module.exports.Provenance = require('./provenance').Provenance;

  module.exports.Device = require('./device').Device;

  module.exports.Query = require('./query').Query;

  module.exports.Order = require('./order').Order;

  module.exports.Procedure = require('./procedure').Procedure;

  module.exports.Substance = require('./substance').Substance;

  module.exports.DeviceUseRequest = require('./deviceuserequest').DeviceUseRequest;

  module.exports.DiagnosticReport = require('./diagnosticreport').DiagnosticReport;

  module.exports.Medication = require('./medication').Medication;

  module.exports.MessageHeader = require('./messageheader').MessageHeader;

  module.exports.DocumentManifest = require('./documentmanifest').DocumentManifest;

  module.exports.DataElement = require('./dataelement').DataElement;

  module.exports.Availability = require('./availability').Availability;

  module.exports.QuestionnaireAnswers = require('./questionnaireanswers').QuestionnaireAnswers;

  module.exports.MedicationAdministration = require('./medicationadministration').MedicationAdministration;

  module.exports.Encounter = require('./encounter').Encounter;

  module.exports.Enrollment = require('./enrollment').Enrollment;

  module.exports.PaymentReconciliation = require('./paymentreconciliation').PaymentReconciliation;

  module.exports.SecurityEvent = require('./securityevent').SecurityEvent;

  module.exports.PendedRequest = require('./pendedrequest').PendedRequest;

  module.exports.List = require('./list').List;

  module.exports.DeviceUseStatement = require('./deviceusestatement').DeviceUseStatement;

  module.exports.OperationDefinition = require('./operationdefinition').OperationDefinition;

  module.exports.ImagingObjectSelection = require('./imagingobjectselection').ImagingObjectSelection;

  module.exports.SearchParameter = require('./searchparameter').SearchParameter;

  module.exports.NutritionOrder = require('./nutritionorder').NutritionOrder;

  module.exports.ClaimResponse = require('./claimresponse').ClaimResponse;

  module.exports.ReferralRequest = require('./referralrequest').ReferralRequest;

  module.exports.CommunicationRequest = require('./communicationrequest').CommunicationRequest;

  module.exports.RiskAssessment = require('./riskassessment').RiskAssessment;

  module.exports.FamilyHistory = require('./familyhistory').FamilyHistory;

  module.exports.Location = require('./location').Location;

  module.exports.ExplanationOfBenefit = require('./explanationofbenefit').ExplanationOfBenefit;

  module.exports.AllergyIntolerance = require('./allergyintolerance').AllergyIntolerance;

  module.exports.Observation = require('./observation').Observation;

  module.exports.Contract = require('./contract').Contract;

  module.exports.SupportingDocumentation = require('./supportingdocumentation').SupportingDocumentation;

  module.exports.RelatedPerson = require('./relatedperson').RelatedPerson;

  module.exports.Basic = require('./basic').Basic;

  module.exports.Specimen = require('./specimen').Specimen;

  module.exports.Alert = require('./alert').Alert;

  module.exports.EnrollmentResponse = require('./enrollmentresponse').EnrollmentResponse;

  module.exports.Patient = require('./patient').Patient;

  module.exports.EligibilityResponse = require('./eligibilityresponse').EligibilityResponse;

  module.exports.StatusRequest = require('./statusrequest').StatusRequest;

  module.exports.DiagnosticOrder = require('./diagnosticorder').DiagnosticOrder;

}).call(this);



},{"./alert":39,"./allergyintolerance":40,"./appointment":41,"./appointmentresponse":42,"./availability":43,"./basic":44,"./binary":45,"./bundle":46,"./careplan":47,"./claimresponse":48,"./communicationrequest":49,"./composition":50,"./conceptmap":51,"./condition":52,"./conformance":53,"./contract":54,"./contraindication":55,"./core":56,"./coverage":57,"./dataelement":58,"./device":59,"./devicecomponent":60,"./deviceuserequest":61,"./deviceusestatement":62,"./diagnosticorder":63,"./diagnosticreport":64,"./documentmanifest":65,"./documentreference":66,"./eligibility":67,"./eligibilityresponse":68,"./encounter":69,"./enrollment":70,"./enrollmentresponse":71,"./explanationofbenefit":72,"./extensiondefinition":73,"./familyhistory":74,"./group":75,"./healthcareservice":76,"./imagingobjectselection":77,"./imagingstudy":78,"./immunization":79,"./immunizationrecommendation":80,"./list":81,"./location":82,"./media":83,"./medication":84,"./medicationadministration":85,"./medicationdispense":86,"./medicationprescription":87,"./medicationstatement":88,"./messageheader":89,"./namingsystem":91,"./nutritionorder":92,"./observation":93,"./operationdefinition":94,"./operationoutcome":95,"./oralhealthclaim":96,"./order":97,"./orderresponse":98,"./organization":99,"./other":100,"./patient":101,"./paymentnotice":102,"./paymentreconciliation":103,"./pendedrequest":104,"./practitioner":105,"./procedure":106,"./procedurerequest":107,"./profile":108,"./provenance":109,"./query":110,"./questionnaire":111,"./questionnaireanswers":112,"./readjudicate":113,"./referralrequest":114,"./relatedperson":115,"./reversal":116,"./riskassessment":117,"./searchparameter":118,"./securityevent":119,"./slot":120,"./specimen":121,"./statusrequest":122,"./statusresponse":123,"./subscription":124,"./substance":125,"./supply":126,"./supportingdocumentation":127,"./valueset":128}],91:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, NamingSystem, NamingSystemContactComponent, NamingSystemUniqueIdComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class NamingSystemUniqueIdComponent
  @exports  NamingSystemUniqueIdComponent as NamingSystemUniqueIdComponent
   */

  NamingSystemUniqueIdComponent = (function(superClass) {
    extend(NamingSystemUniqueIdComponent, superClass);

    function NamingSystemUniqueIdComponent(json) {
      this.json = json;
      NamingSystemUniqueIdComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the unique identifier scheme used for this particular identifier.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystemUniqueIdComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The string that should be sent over the wire to identify the code system or identifier system.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystemUniqueIdComponent.prototype.value = function() {
      return this.json['value'];
    };


    /**
    Indicates whether this identifier is the "preferred" identifier of this type.
    @returns {Array} an array of {@link boolean} objects
     */

    NamingSystemUniqueIdComponent.prototype.preferred = function() {
      return this.json['preferred'];
    };


    /**
    Identifies the period of time over which this identifier is considered appropriate to refer to the namingsystem.  Outside of this window, the identifier might be non-deterministic.
    @returns {Period}
     */

    NamingSystemUniqueIdComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return NamingSystemUniqueIdComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NamingSystemContactComponent
  @exports  NamingSystemContactComponent as NamingSystemContactComponent
   */

  NamingSystemContactComponent = (function(superClass) {
    extend(NamingSystemContactComponent, superClass);

    function NamingSystemContactComponent(json) {
      this.json = json;
      NamingSystemContactComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Names of the person who can be contacted.
    @returns {HumanName}
     */

    NamingSystemContactComponent.prototype.name = function() {
      if (this.json['name']) {
        return new HumanName(this.json['name']);
      }
    };


    /**
    Identifies the mechanism(s) by which they can be contacted.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    NamingSystemContactComponent.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };

    return NamingSystemContactComponent;

  })(BackboneElement);


  /**
  A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
  @class NamingSystem
  @exports NamingSystem as NamingSystem
   */

  NamingSystem = (function(superClass) {
    extend(NamingSystem, superClass);

    function NamingSystem(json) {
      this.json = json;
      NamingSystem.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the purpose for the namingsystem - what kinds of things does it make unique?.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The descriptive name of this particular identifier type or code system.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Indicates whether the namingsystem is "ready for use" or not.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.status = function() {
      return this.json['status'];
    };


    /**
    If present, indicates that the identifier or code system is principally intended for use or applies to entities within the specified country.  For example, the country associated with a national code system.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.country = function() {
      return this.json['country'];
    };


    /**
    Categorizes a namingsystem for easier search by grouping related namingsystems.
    @returns {CodeableConcept}
     */

    NamingSystem.prototype.category = function() {
      if (this.json['category']) {
        return new CodeableConcept(this.json['category']);
      }
    };


    /**
    The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.responsible = function() {
      return this.json['responsible'];
    };


    /**
    Details about what the namespace identifies including scope, granularity, version labeling, etc.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    @returns {Array} an array of {@link String} objects
     */

    NamingSystem.prototype.usage = function() {
      return this.json['usage'];
    };


    /**
    Indicates how the system may be identified when referenced in electronic exchange.
    @returns {Array} an array of {@link NamingSystemUniqueIdComponent} objects
     */

    NamingSystem.prototype.uniqueId = function() {
      var i, item, len, ref, results;
      if (this.json['uniqueId']) {
        ref = this.json['uniqueId'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NamingSystemUniqueIdComponent(item));
        }
        return results;
      }
    };


    /**
    The person who can be contacted about this system registration entry.
    @returns {NamingSystemContactComponent}
     */

    NamingSystem.prototype.contact = function() {
      if (this.json['contact']) {
        return new NamingSystemContactComponent(this.json['contact']);
      }
    };


    /**
    For namingsystems that are retired, indicates the namingsystem that should be used in their place (if any).
    @returns {Reference}
     */

    NamingSystem.prototype.replacedBy = function() {
      if (this.json['replacedBy']) {
        return new Reference(this.json['replacedBy']);
      }
    };

    return NamingSystem;

  })(DomainResource);

  module.exports.NamingSystem = NamingSystem;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],92:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, NutritionOrder, NutritionOrderItemComponent, NutritionOrderItemEnteralFormulaComponent, NutritionOrderItemOralDietComponent, NutritionOrderItemOralDietNutrientsComponent, NutritionOrderItemOralDietTextureComponent, NutritionOrderItemSupplementComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class NutritionOrderItemOralDietNutrientsComponent
  @exports  NutritionOrderItemOralDietNutrientsComponent as NutritionOrderItemOralDietNutrientsComponent
   */

  NutritionOrderItemOralDietNutrientsComponent = (function(superClass) {
    extend(NutritionOrderItemOralDietNutrientsComponent, superClass);

    function NutritionOrderItemOralDietNutrientsComponent(json) {
      this.json = json;
      NutritionOrderItemOralDietNutrientsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the type of nutrient that is being modified such as cabohydrate or sodium.
    @returns {CodeableConcept}
     */

    NutritionOrderItemOralDietNutrientsComponent.prototype.modifier = function() {
      if (this.json['modifier']) {
        return new CodeableConcept(this.json['modifier']);
      }
    };


    /**
    The quantity or range of the specified nutrient to supply.
    @returns {Quantity}
     */

    NutritionOrderItemOralDietNutrientsComponent.prototype.amountQuantity = function() {
      if (this.json['amountQuantity']) {
        return new Quantity(this.json['amountQuantity']);
      }
    };


    /**
    The quantity or range of the specified nutrient to supply.
    @returns {Range}
     */

    NutritionOrderItemOralDietNutrientsComponent.prototype.amountRange = function() {
      if (this.json['amountRange']) {
        return new Range(this.json['amountRange']);
      }
    };

    return NutritionOrderItemOralDietNutrientsComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NutritionOrderItemOralDietTextureComponent
  @exports  NutritionOrderItemOralDietTextureComponent as NutritionOrderItemOralDietTextureComponent
   */

  NutritionOrderItemOralDietTextureComponent = (function(superClass) {
    extend(NutritionOrderItemOralDietTextureComponent, superClass);

    function NutritionOrderItemOralDietTextureComponent(json) {
      this.json = json;
      NutritionOrderItemOralDietTextureComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, pureed.
    @returns {CodeableConcept}
     */

    NutritionOrderItemOralDietTextureComponent.prototype.modifier = function() {
      if (this.json['modifier']) {
        return new CodeableConcept(this.json['modifier']);
      }
    };


    /**
    Indicates what specific type of food (e.g., meats) the texture modification applies to or may apply to all foods in the diet.
    @returns {CodeableConcept}
     */

    NutritionOrderItemOralDietTextureComponent.prototype.foodType = function() {
      if (this.json['foodType']) {
        return new CodeableConcept(this.json['foodType']);
      }
    };

    return NutritionOrderItemOralDietTextureComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NutritionOrderItemOralDietComponent
  @exports  NutritionOrderItemOralDietComponent as NutritionOrderItemOralDietComponent
   */

  NutritionOrderItemOralDietComponent = (function(superClass) {
    extend(NutritionOrderItemOralDietComponent, superClass);

    function NutritionOrderItemOralDietComponent(json) {
      this.json = json;
      NutritionOrderItemOralDietComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A set of one or more codes representing diets that describe what can be consumed orally (i.e., take via the mouth).
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrderItemOralDietComponent.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Class that defines the details of any nutrient modifications required for the oral diet.
    @returns {Array} an array of {@link NutritionOrderItemOralDietNutrientsComponent} objects
     */

    NutritionOrderItemOralDietComponent.prototype.nutrients = function() {
      var i, item, len, ref, results;
      if (this.json['nutrients']) {
        ref = this.json['nutrients'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NutritionOrderItemOralDietNutrientsComponent(item));
        }
        return results;
      }
    };


    /**
    Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
    @returns {Array} an array of {@link NutritionOrderItemOralDietTextureComponent} objects
     */

    NutritionOrderItemOralDietComponent.prototype.texture = function() {
      var i, item, len, ref, results;
      if (this.json['texture']) {
        ref = this.json['texture'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NutritionOrderItemOralDietTextureComponent(item));
        }
        return results;
      }
    };


    /**
    Identifies the required consistency (e.g., honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrderItemOralDietComponent.prototype.fluidConsistencyType = function() {
      var i, item, len, ref, results;
      if (this.json['fluidConsistencyType']) {
        ref = this.json['fluidConsistencyType'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A descriptive name of the required diets that describe what can be consumed orally (i.e., take via the mouth).
    @returns {Array} an array of {@link String} objects
     */

    NutritionOrderItemOralDietComponent.prototype.description = function() {
      return this.json['description'];
    };

    return NutritionOrderItemOralDietComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NutritionOrderItemSupplementComponent
  @exports  NutritionOrderItemSupplementComponent as NutritionOrderItemSupplementComponent
   */

  NutritionOrderItemSupplementComponent = (function(superClass) {
    extend(NutritionOrderItemSupplementComponent, superClass);

    function NutritionOrderItemSupplementComponent(json) {
      this.json = json;
      NutritionOrderItemSupplementComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the type of nutritional supplement product required such as high protein or pediatric clear liquid supplement.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrderItemSupplementComponent.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The amount of the nutritional supplement product to provide to the patient.
    @returns {Quantity}
     */

    NutritionOrderItemSupplementComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    The name of the nutritional supplement product to be provided to the patient.
    @returns {Array} an array of {@link String} objects
     */

    NutritionOrderItemSupplementComponent.prototype.name = function() {
      return this.json['name'];
    };

    return NutritionOrderItemSupplementComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NutritionOrderItemEnteralFormulaComponent
  @exports  NutritionOrderItemEnteralFormulaComponent as NutritionOrderItemEnteralFormulaComponent
   */

  NutritionOrderItemEnteralFormulaComponent = (function(superClass) {
    extend(NutritionOrderItemEnteralFormulaComponent, superClass);

    function NutritionOrderItemEnteralFormulaComponent(json) {
      this.json = json;
      NutritionOrderItemEnteralFormulaComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates the type of enteral or infant formula requested such as pediatric elemental formula or.
    @returns {CodeableConcept}
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.baseFormulaType = function() {
      if (this.json['baseFormulaType']) {
        return new CodeableConcept(this.json['baseFormulaType']);
      }
    };


    /**
    Indicates the type of modular component such as protein, carbohydrate or fiber to be provided in addition to or mixed with the base formula.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.additiveType = function() {
      var i, item, len, ref, results;
      if (this.json['additiveType']) {
        ref = this.json['additiveType'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    TODO ***CARD AND TYPE ARE PLACEHOLDERS TO COMPLETE BUILD.  Need to discuss***.
    @returns {Array} an array of {@link Quantity} objects
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.caloricDensity = function() {
      var i, item, len, ref, results;
      if (this.json['caloricDensity']) {
        ref = this.json['caloricDensity'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Quantity(item));
        }
        return results;
      }
    };


    /**
    ***CARD AND TYPE ARE PLACEHOLDERS TO COMPLETE BUILD.  Need to discuss***administration details including rate (ml per hour), route of adminstration, total volume.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.routeofAdministration = function() {
      var i, item, len, ref, results;
      if (this.json['routeofAdministration']) {
        ref = this.json['routeofAdministration'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    TODO ***CARD AND TYPE ARE PLACEHOLDERS TO COMPLETE BUILD.  Need to discuss***.
    @returns {Array} an array of {@link Quantity} objects
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.rate = function() {
      var i, item, len, ref, results;
      if (this.json['rate']) {
        ref = this.json['rate'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Quantity(item));
        }
        return results;
      }
    };


    /**
    TODO.
    @returns {Array} an array of {@link String} objects
     */

    NutritionOrderItemEnteralFormulaComponent.prototype.baseFormulaName = function() {
      return this.json['baseFormulaName'];
    };

    return NutritionOrderItemEnteralFormulaComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NutritionOrderItemComponent
  @exports  NutritionOrderItemComponent as NutritionOrderItemComponent
   */

  NutritionOrderItemComponent = (function(superClass) {
    extend(NutritionOrderItemComponent, superClass);

    function NutritionOrderItemComponent(json) {
      this.json = json;
      NutritionOrderItemComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The frequency at which the diet, oral supplement or enteral formula should be given.
    @returns {Timing}
     */

    NutritionOrderItemComponent.prototype.scheduledTiming = function() {
      if (this.json['scheduledTiming']) {
        return new Timing(this.json['scheduledTiming']);
      }
    };


    /**
    The frequency at which the diet, oral supplement or enteral formula should be given.
    @returns {Period}
     */

    NutritionOrderItemComponent.prototype.scheduledPeriod = function() {
      if (this.json['scheduledPeriod']) {
        return new Period(this.json['scheduledPeriod']);
      }
    };


    /**
    Indicates whether the nutrition item is  currently in effect for the patient.
    @returns {Array} an array of {@link boolean} objects
     */

    NutritionOrderItemComponent.prototype.isInEffect = function() {
      return this.json['isInEffect'];
    };


    /**
    Class that defines the components of an oral diet order for the patient.
    @returns {NutritionOrderItemOralDietComponent}
     */

    NutritionOrderItemComponent.prototype.oralDiet = function() {
      if (this.json['oralDiet']) {
        return new NutritionOrderItemOralDietComponent(this.json['oralDiet']);
      }
    };


    /**
    Class that defines the components of a supplement order for the patient.
    @returns {NutritionOrderItemSupplementComponent}
     */

    NutritionOrderItemComponent.prototype.supplement = function() {
      if (this.json['supplement']) {
        return new NutritionOrderItemSupplementComponent(this.json['supplement']);
      }
    };


    /**
    Class that defines the components of an enteral formula order for the patient.
    @returns {NutritionOrderItemEnteralFormulaComponent}
     */

    NutritionOrderItemComponent.prototype.enteralFormula = function() {
      if (this.json['enteralFormula']) {
        return new NutritionOrderItemEnteralFormulaComponent(this.json['enteralFormula']);
      }
    };

    return NutritionOrderItemComponent;

  })(BackboneElement);


  /**
  A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
  @class NutritionOrder
  @exports NutritionOrder as NutritionOrder
   */

  NutritionOrder = (function(superClass) {
    extend(NutritionOrder, superClass);

    function NutritionOrder(json) {
      this.json = json;
      NutritionOrder.__super__.constructor.call(this, this.json);
    }


    /**
    The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
    @returns {Reference}
     */

    NutritionOrder.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
    @returns {Reference}
     */

    NutritionOrder.prototype.orderer = function() {
      if (this.json['orderer']) {
        return new Reference(this.json['orderer']);
      }
    };


    /**
    Identifiers assigned to this order by the order sender or by the order receiver.
    @returns {Array} an array of {@link Identifier} objects
     */

    NutritionOrder.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    An encounter that provides additional informaton about the healthcare context in which this request is made.
    @returns {Reference}
     */

    NutritionOrder.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    The date and time that this nutrition order was requested.
    @returns {Array} an array of {@link Date} objects
     */

    NutritionOrder.prototype.dateTime = function() {
      if (this.json['dateTime']) {
        return DT.DateTime.parse(this.json['dateTime']);
      }
    };


    /**
    The ability to list substances that may cause allergies or intolerances which should be included in the nutrition order.
    @returns {Array} an array of {@link Reference} objects
     */

    NutritionOrder.prototype.allergyIntolerance = function() {
      var i, item, len, ref, results;
      if (this.json['allergyIntolerance']) {
        ref = this.json['allergyIntolerance'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrder.prototype.foodPreferenceModifier = function() {
      var i, item, len, ref, results;
      if (this.json['foodPreferenceModifier']) {
        ref = this.json['foodPreferenceModifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    NutritionOrder.prototype.excludeFoodModifier = function() {
      var i, item, len, ref, results;
      if (this.json['excludeFoodModifier']) {
        ref = this.json['excludeFoodModifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Different items that combine to make a complete description of the nutrition to be provided via oral diet, nutritional supplement and/or formula order.
    @returns {Array} an array of {@link NutritionOrderItemComponent} objects
     */

    NutritionOrder.prototype.item = function() {
      var i, item, len, ref, results;
      if (this.json['item']) {
        ref = this.json['item'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NutritionOrderItemComponent(item));
        }
        return results;
      }
    };


    /**
    The workflow status of the nutrition order request, e.g., Active, Inactive, Pending, Held, Canceled, Suspended.
    @returns {Array} an array of {@link String} objects
     */

    NutritionOrder.prototype.status = function() {
      return this.json['status'];
    };

    return NutritionOrder;

  })(DomainResource);

  module.exports.NutritionOrder = NutritionOrder;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],93:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Observation, ObservationReferenceRangeComponent, ObservationRelatedComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ObservationReferenceRangeComponent
  @exports  ObservationReferenceRangeComponent as ObservationReferenceRangeComponent
   */

  ObservationReferenceRangeComponent = (function(superClass) {
    extend(ObservationReferenceRangeComponent, superClass);

    function ObservationReferenceRangeComponent(json) {
      this.json = json;
      ObservationReferenceRangeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The value of the low bound of the reference range. If this is omitted, the low bound of the reference range is assumed to be meaningless. E.g. <2.3.
    @returns {Quantity}
     */

    ObservationReferenceRangeComponent.prototype.low = function() {
      if (this.json['low']) {
        return new Quantity(this.json['low']);
      }
    };


    /**
    The value of the high bound of the reference range. If this is omitted, the high bound of the reference range is assumed to be meaningless. E.g. >5.
    @returns {Quantity}
     */

    ObservationReferenceRangeComponent.prototype.high = function() {
      if (this.json['high']) {
        return new Quantity(this.json['high']);
      }
    };


    /**
    Code for the meaning of the reference range.
    @returns {CodeableConcept}
     */

    ObservationReferenceRangeComponent.prototype.meaning = function() {
      if (this.json['meaning']) {
        return new CodeableConcept(this.json['meaning']);
      }
    };


    /**
    The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    @returns {Range}
     */

    ObservationReferenceRangeComponent.prototype.age = function() {
      if (this.json['age']) {
        return new Range(this.json['age']);
      }
    };


    /**
    Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    @returns {Array} an array of {@link String} objects
     */

    ObservationReferenceRangeComponent.prototype.text = function() {
      return this.json['text'];
    };

    return ObservationReferenceRangeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ObservationRelatedComponent
  @exports  ObservationRelatedComponent as ObservationRelatedComponent
   */

  ObservationRelatedComponent = (function(superClass) {
    extend(ObservationRelatedComponent, superClass);

    function ObservationRelatedComponent(json) {
      this.json = json;
      ObservationRelatedComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code specifying the kind of relationship that exists with the target observation.
    @returns {Array} an array of {@link String} objects
     */

    ObservationRelatedComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    A reference to the observation that is related to this observation.
    @returns {Reference}
     */

    ObservationRelatedComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return ObservationRelatedComponent;

  })(BackboneElement);


  /**
  Measurements and simple assertions made about a patient, device or other subject.
  @class Observation
  @exports Observation as Observation
   */

  Observation = (function(superClass) {
    extend(Observation, superClass);

    function Observation(json) {
      this.json = json;
      Observation.__super__.constructor.call(this, this.json);
    }


    /**
    Describes what was observed. Sometimes this is called the observation "code".
    @returns {CodeableConcept}
     */

    Observation.prototype.name = function() {
      if (this.json['name']) {
        return new CodeableConcept(this.json['name']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Quantity}
     */

    Observation.prototype.valueQuantity = function() {
      if (this.json['valueQuantity']) {
        return new Quantity(this.json['valueQuantity']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {CodeableConcept}
     */

    Observation.prototype.valueCodeableConcept = function() {
      if (this.json['valueCodeableConcept']) {
        return new CodeableConcept(this.json['valueCodeableConcept']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Attachment}
     */

    Observation.prototype.valueAttachment = function() {
      if (this.json['valueAttachment']) {
        return new Attachment(this.json['valueAttachment']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Ratio}
     */

    Observation.prototype.valueRatio = function() {
      if (this.json['valueRatio']) {
        return new Ratio(this.json['valueRatio']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.valueDateTime = function() {
      if (this.json['valueDateTime']) {
        return DT.DateTime.parse(this.json['valueDateTime']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Period}
     */

    Observation.prototype.valuePeriod = function() {
      if (this.json['valuePeriod']) {
        return new Period(this.json['valuePeriod']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {SampledData}
     */

    Observation.prototype.valueSampledData = function() {
      if (this.json['valueSampledData']) {
        return new SampledData(this.json['valueSampledData']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.valueString = function() {
      return this.json['valueString'];
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {time}
     */

    Observation.prototype.valueTime = function() {
      if (this.json['valueTime']) {
        return new time(this.json['valueTime']);
      }
    };


    /**
    Provides a reason why the expected value in the element Observation.value[x] is missing.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.dataAbsentReason = function() {
      return this.json['dataAbsentReason'];
    };


    /**
    The assessment made based on the result of the observation.
    @returns {CodeableConcept}
     */

    Observation.prototype.interpretation = function() {
      if (this.json['interpretation']) {
        return new CodeableConcept(this.json['interpretation']);
      }
    };


    /**
    May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.appliesDateTime = function() {
      if (this.json['appliesDateTime']) {
        return DT.DateTime.parse(this.json['appliesDateTime']);
      }
    };


    /**
    The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    @returns {Period}
     */

    Observation.prototype.appliesPeriod = function() {
      if (this.json['appliesPeriod']) {
        return new Period(this.json['appliesPeriod']);
      }
    };


    /**
    The date and time this observation was made available.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.issued = function() {
      if (this.json['issued']) {
        return DT.DateTime.parse(this.json['issued']);
      }
    };


    /**
    The status of the result value.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.status = function() {
      return this.json['status'];
    };


    /**
    An estimate of the degree to which quality issues have impacted on the value reported.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.reliability = function() {
      return this.json['reliability'];
    };


    /**
    Indicates the site on the subject's body where the observation was made ( i.e. the target site).
    @returns {CodeableConcept}
     */

    Observation.prototype.bodySite = function() {
      if (this.json['bodySite']) {
        return new CodeableConcept(this.json['bodySite']);
      }
    };


    /**
    Indicates the mechanism used to perform the observation.
    @returns {CodeableConcept}
     */

    Observation.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    A unique identifier for the simple observation.
    @returns {Identifier}
     */

    Observation.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The thing the observation is being made about.
    @returns {Reference}
     */

    Observation.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The specimen that was used when this observation was made.
    @returns {Reference}
     */

    Observation.prototype.specimen = function() {
      if (this.json['specimen']) {
        return new Reference(this.json['specimen']);
      }
    };


    /**
    Who was responsible for asserting the observed value as "true".
    @returns {Array} an array of {@link Reference} objects
     */

    Observation.prototype.performer = function() {
      var i, item, len, ref, results;
      if (this.json['performer']) {
        ref = this.json['performer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The healthcare event  ( e.g. a patient and healthcare provider interaction ) that relates to this observation.
    @returns {Reference}
     */

    Observation.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Guidance on how to interpret the value by comparison to a normal or recommended range.
    @returns {Array} an array of {@link ObservationReferenceRangeComponent} objects
     */

    Observation.prototype.referenceRange = function() {
      var i, item, len, ref, results;
      if (this.json['referenceRange']) {
        ref = this.json['referenceRange'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ObservationReferenceRangeComponent(item));
        }
        return results;
      }
    };


    /**
    Related observations - either components, or previous observations, or statements of derivation.
    @returns {Array} an array of {@link ObservationRelatedComponent} objects
     */

    Observation.prototype.related = function() {
      var i, item, len, ref, results;
      if (this.json['related']) {
        ref = this.json['related'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ObservationRelatedComponent(item));
        }
        return results;
      }
    };

    return Observation;

  })(DomainResource);

  module.exports.Observation = Observation;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],94:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, OperationDefinition, OperationDefinitionParameterComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class OperationDefinitionParameterComponent
  @exports  OperationDefinitionParameterComponent as OperationDefinitionParameterComponent
   */

  OperationDefinitionParameterComponent = (function(superClass) {
    extend(OperationDefinitionParameterComponent, superClass);

    function OperationDefinitionParameterComponent(json) {
      this.json = json;
      OperationDefinitionParameterComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The name of used to identify the parameter.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinitionParameterComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Whether this is an input or an output parameter.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinitionParameterComponent.prototype.use = function() {
      return this.json['use'];
    };


    /**
    The minimum number of times this parameter SHALL appear in the request or response.
    @returns {Array} an array of {@link Number} objects
     */

    OperationDefinitionParameterComponent.prototype.min = function() {
      return this.json['min'];
    };


    /**
    The maximum number of times this element is permitted to appear in the request or response.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinitionParameterComponent.prototype.max = function() {
      return this.json['max'];
    };


    /**
    Describes the meaning or use of this parameter.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinitionParameterComponent.prototype.documentation = function() {
      return this.json['documentation'];
    };


    /**
    The type for this parameter.
    @returns {Coding}
     */

    OperationDefinitionParameterComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    A profile the specifies the rules that this parameter must conform to.
    @returns {Reference}
     */

    OperationDefinitionParameterComponent.prototype.profile = function() {
      if (this.json['profile']) {
        return new Reference(this.json['profile']);
      }
    };

    return OperationDefinitionParameterComponent;

  })(BackboneElement);


  /**
  A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
  @class OperationDefinition
  @exports OperationDefinition as OperationDefinition
   */

  OperationDefinition = (function(superClass) {
    extend(OperationDefinition, superClass);

    function OperationDefinition(json) {
      this.json = json;
      OperationDefinition.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this operation definition when it is referenced in a specification, model, design or an instance (should be globally unique OID, UUID, or URI).
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    The identifier that is used to identify this version of the profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A free text natural language name identifying the Profile.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.title = function() {
      return this.json['title'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the profile.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    OperationDefinition.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the profile and its use.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A set of terms from external terminologies that may be used to assist with indexing and searching of templates.
    @returns {Array} an array of {@link Coding} objects
     */

    OperationDefinition.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    The status of the profile.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.status = function() {
      return this.json['status'];
    };


    /**
    This profile was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    OperationDefinition.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    The date that this version of the profile was published.
    @returns {Array} an array of {@link Date} objects
     */

    OperationDefinition.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Whether this is operation or named query.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.kind = function() {
      return this.json['kind'];
    };


    /**
    The name used to invoke the operation.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Additional information about how to use this operation or named query.
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    Indicates that this operation definition is a constraining profile on the base.
    @returns {Reference}
     */

    OperationDefinition.prototype.base = function() {
      if (this.json['base']) {
        return new Reference(this.json['base']);
      }
    };


    /**
    Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    @returns {Array} an array of {@link boolean} objects
     */

    OperationDefinition.prototype.system = function() {
      return this.json['system'];
    };


    /**
    Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a resource type for the context).
    @returns {Array} an array of {@link String} objects
     */

    OperationDefinition.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Indicates whether this operation can be invoked on a particular instance of one of the given types.
    @returns {Array} an array of {@link boolean} objects
     */

    OperationDefinition.prototype.instance = function() {
      return this.json['instance'];
    };


    /**
    Parameters for the operation/query.
    @returns {Array} an array of {@link OperationDefinitionParameterComponent} objects
     */

    OperationDefinition.prototype.parameter = function() {
      var i, item, len, ref, results;
      if (this.json['parameter']) {
        ref = this.json['parameter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new OperationDefinitionParameterComponent(item));
        }
        return results;
      }
    };

    return OperationDefinition;

  })(DomainResource);

  module.exports.OperationDefinition = OperationDefinition;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],95:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, OperationOutcome, OperationOutcomeIssueComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class OperationOutcomeIssueComponent
  @exports  OperationOutcomeIssueComponent as OperationOutcomeIssueComponent
   */

  OperationOutcomeIssueComponent = (function(superClass) {
    extend(OperationOutcomeIssueComponent, superClass);

    function OperationOutcomeIssueComponent(json) {
      this.json = json;
      OperationOutcomeIssueComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates whether the issue indicates a variation from successful processing.
    @returns {Array} an array of {@link String} objects
     */

    OperationOutcomeIssueComponent.prototype.severity = function() {
      return this.json['severity'];
    };


    /**
    A code indicating the type of error, warning or information message.
    @returns {Coding}
     */

    OperationOutcomeIssueComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    Additional description of the issue.
    @returns {Array} an array of {@link String} objects
     */

    OperationOutcomeIssueComponent.prototype.details = function() {
      return this.json['details'];
    };


    /**
    A simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    @returns {Array} an array of {@link String} objects
     */

    OperationOutcomeIssueComponent.prototype.location = function() {
      return this.json['location'];
    };

    return OperationOutcomeIssueComponent;

  })(BackboneElement);


  /**
  A collection of error, warning or information messages that result from a system action.
  @class OperationOutcome
  @exports OperationOutcome as OperationOutcome
   */

  OperationOutcome = (function(superClass) {
    extend(OperationOutcome, superClass);

    function OperationOutcome(json) {
      this.json = json;
      OperationOutcome.__super__.constructor.call(this, this.json);
    }


    /**
    An error, warning or information message that results from a system action.
    @returns {Array} an array of {@link OperationOutcomeIssueComponent} objects
     */

    OperationOutcome.prototype.issue = function() {
      var i, item, len, ref, results;
      if (this.json['issue']) {
        ref = this.json['issue'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new OperationOutcomeIssueComponent(item));
        }
        return results;
      }
    };

    return OperationOutcome;

  })(DomainResource);

  module.exports.OperationOutcome = OperationOutcome;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],96:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, CoverageComponent, DT, DetailComponent, DiagnosisComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, ItemsComponent, MissingTeethComponent, Narrative, OralHealthClaim, OrthodonticPlanComponent, Parameters, PayeeComponent, Period, ProsthesisComponent, Quantity, Range, Ratio, Reference, Resource, SampledData, SubDetailComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class PayeeComponent
  @exports  PayeeComponent as PayeeComponent
   */

  PayeeComponent = (function(superClass) {
    extend(PayeeComponent, superClass);

    function PayeeComponent(json) {
      this.json = json;
      PayeeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Party to be reimbursed: Subscriber, provider, other.
    @returns {Coding}
     */

    PayeeComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The provider who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The person other than the subscriber who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.person = function() {
      if (this.json['person']) {
        return new Reference(this.json['person']);
      }
    };

    return PayeeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DiagnosisComponent
  @exports  DiagnosisComponent as DiagnosisComponent
   */

  DiagnosisComponent = (function(superClass) {
    extend(DiagnosisComponent, superClass);

    function DiagnosisComponent(json) {
      this.json = json;
      DiagnosisComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Sequence of diagnosis.
    @returns {Array} an array of {@link Number} objects
     */

    DiagnosisComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The diagnosis.
    @returns {Coding}
     */

    DiagnosisComponent.prototype.diagnosis = function() {
      if (this.json['diagnosis']) {
        return new Coding(this.json['diagnosis']);
      }
    };

    return DiagnosisComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class CoverageComponent
  @exports  CoverageComponent as CoverageComponent
   */

  CoverageComponent = (function(superClass) {
    extend(CoverageComponent, superClass);

    function CoverageComponent(json) {
      this.json = json;
      CoverageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line item.
    @returns {Array} an array of {@link Number} objects
     */

    CoverageComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The instance number of the Coverage which is the focus for adjudication, that is the Coverage to which the claim is to be adjudicated against.
    @returns {Array} an array of {@link boolean} objects
     */

    CoverageComponent.prototype.focal = function() {
      return this.json['focal'];
    };


    /**
    Reference to the program or plan identification, underwriter or payor.
    @returns {Reference}
     */

    CoverageComponent.prototype.coverage = function() {
      if (this.json['coverage']) {
        return new Reference(this.json['coverage']);
      }
    };


    /**
    The contract number of a business agrement which describes the terms and conditions.
    @returns {Array} an array of {@link String} objects
     */

    CoverageComponent.prototype.businessArrangement = function() {
      return this.json['businessArrangement'];
    };


    /**
    The relationship of the patient to the subscriber.
    @returns {Coding}
     */

    CoverageComponent.prototype.relationship = function() {
      if (this.json['relationship']) {
        return new Coding(this.json['relationship']);
      }
    };


    /**
    A list of references from the Insurer to which these services pertain.
    @returns {Array} an array of {@link String} objects
     */

    CoverageComponent.prototype.preauthref = function() {
      return this.json['preauthref'];
    };


    /**
    The Coverages adjudication details.
    @returns {Reference}
     */

    CoverageComponent.prototype.claimResponse = function() {
      if (this.json['claimResponse']) {
        return new Reference(this.json['claimResponse']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    CoverageComponent.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };

    return CoverageComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class MissingTeethComponent
  @exports  MissingTeethComponent as MissingTeethComponent
   */

  MissingTeethComponent = (function(superClass) {
    extend(MissingTeethComponent, superClass);

    function MissingTeethComponent(json) {
      this.json = json;
      MissingTeethComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The code identifying which tooth is missing.
    @returns {Coding}
     */

    MissingTeethComponent.prototype.tooth = function() {
      if (this.json['tooth']) {
        return new Coding(this.json['tooth']);
      }
    };


    /**
    Missing reason may be: E-extraction, O-other.
    @returns {Coding}
     */

    MissingTeethComponent.prototype.reason = function() {
      if (this.json['reason']) {
        return new Coding(this.json['reason']);
      }
    };


    /**
    The date of the extraction either known from records or patient reported estimate.
    @returns {Array} an array of {@link Date} objects
     */

    MissingTeethComponent.prototype.extractiondate = function() {
      if (this.json['extractiondate']) {
        return DT.DateTime.parse(this.json['extractiondate']);
      }
    };

    return MissingTeethComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class OrthodonticPlanComponent
  @exports  OrthodonticPlanComponent as OrthodonticPlanComponent
   */

  OrthodonticPlanComponent = (function(superClass) {
    extend(OrthodonticPlanComponent, superClass);

    function OrthodonticPlanComponent(json) {
      this.json = json;
      OrthodonticPlanComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The intended start date for service.
    @returns {Array} an array of {@link Date} objects
     */

    OrthodonticPlanComponent.prototype.start = function() {
      if (this.json['start']) {
        return DT.DateTime.parse(this.json['start']);
      }
    };


    /**
    The estimated first examination fee.
    @returns {Money}
     */

    OrthodonticPlanComponent.prototype.examFee = function() {
      if (this.json['examFee']) {
        return new Money(this.json['examFee']);
      }
    };


    /**
    The estimated diagnostic fee.
    @returns {Money}
     */

    OrthodonticPlanComponent.prototype.diagnosticFee = function() {
      if (this.json['diagnosticFee']) {
        return new Money(this.json['diagnosticFee']);
      }
    };


    /**
    The estimated initial payment.
    @returns {Money}
     */

    OrthodonticPlanComponent.prototype.initialPayment = function() {
      if (this.json['initialPayment']) {
        return new Money(this.json['initialPayment']);
      }
    };


    /**
    The estimated treatment duration in months.
    @returns {Array} an array of {@link Number} objects
     */

    OrthodonticPlanComponent.prototype.durationMonths = function() {
      return this.json['durationMonths'];
    };


    /**
    The anticipated number of payments.
    @returns {Array} an array of {@link Number} objects
     */

    OrthodonticPlanComponent.prototype.paymentCount = function() {
      return this.json['paymentCount'];
    };


    /**
    The anticipated payment amount.
    @returns {Money}
     */

    OrthodonticPlanComponent.prototype.periodicPayment = function() {
      if (this.json['periodicPayment']) {
        return new Money(this.json['periodicPayment']);
      }
    };

    return OrthodonticPlanComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SubDetailComponent
  @exports  SubDetailComponent as SubDetailComponent
   */

  SubDetailComponent = (function(superClass) {
    extend(SubDetailComponent, superClass);

    function SubDetailComponent(json) {
      this.json = json;
      SubDetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    SubDetailComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The type of product or service.
    @returns {Coding}
     */

    SubDetailComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The fee for an addtional service or product or charge.
    @returns {Coding}
     */

    SubDetailComponent.prototype.service = function() {
      if (this.json['service']) {
        return new Coding(this.json['service']);
      }
    };


    /**
    The number of repetitions of a service or product.
    @returns {Quantity}
     */

    SubDetailComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    The fee for an addtional service or product or charge.
    @returns {Money}
     */

    SubDetailComponent.prototype.unitPrice = function() {
      if (this.json['unitPrice']) {
        return new Money(this.json['unitPrice']);
      }
    };


    /**
    A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    @returns {Array} an array of {@link Number} objects
     */

    SubDetailComponent.prototype.factor = function() {
      return this.json['factor'];
    };


    /**
    An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    @returns {Array} an array of {@link Number} objects
     */

    SubDetailComponent.prototype.points = function() {
      return this.json['points'];
    };


    /**
    The quantity times the unit price for an addtional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    @returns {Money}
     */

    SubDetailComponent.prototype.net = function() {
      if (this.json['net']) {
        return new Money(this.json['net']);
      }
    };


    /**
    List of Unique Device Identifiers associated with this line item.
    @returns {Coding}
     */

    SubDetailComponent.prototype.udi = function() {
      if (this.json['udi']) {
        return new Coding(this.json['udi']);
      }
    };

    return SubDetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DetailComponent
  @exports  DetailComponent as DetailComponent
   */

  DetailComponent = (function(superClass) {
    extend(DetailComponent, superClass);

    function DetailComponent(json) {
      this.json = json;
      DetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    DetailComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The type of product or service.
    @returns {Coding}
     */

    DetailComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied.
    @returns {Coding}
     */

    DetailComponent.prototype.service = function() {
      if (this.json['service']) {
        return new Coding(this.json['service']);
      }
    };


    /**
    The number of repetitions of a service or product.
    @returns {Quantity}
     */

    DetailComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    @returns {Money}
     */

    DetailComponent.prototype.unitPrice = function() {
      if (this.json['unitPrice']) {
        return new Money(this.json['unitPrice']);
      }
    };


    /**
    A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    @returns {Array} an array of {@link Number} objects
     */

    DetailComponent.prototype.factor = function() {
      return this.json['factor'];
    };


    /**
    An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    @returns {Array} an array of {@link Number} objects
     */

    DetailComponent.prototype.points = function() {
      return this.json['points'];
    };


    /**
    The quantity times the unit price for an addtional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    @returns {Money}
     */

    DetailComponent.prototype.net = function() {
      if (this.json['net']) {
        return new Money(this.json['net']);
      }
    };


    /**
    List of Unique Device Identifiers associated with this line item.
    @returns {Coding}
     */

    DetailComponent.prototype.udi = function() {
      if (this.json['udi']) {
        return new Coding(this.json['udi']);
      }
    };


    /**
    Third tier of goods and services.
    @returns {Array} an array of {@link SubDetailComponent} objects
     */

    DetailComponent.prototype.subDetail = function() {
      var i, item, len, ref, results;
      if (this.json['subDetail']) {
        ref = this.json['subDetail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SubDetailComponent(item));
        }
        return results;
      }
    };

    return DetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ProsthesisComponent
  @exports  ProsthesisComponent as ProsthesisComponent
   */

  ProsthesisComponent = (function(superClass) {
    extend(ProsthesisComponent, superClass);

    function ProsthesisComponent(json) {
      this.json = json;
      ProsthesisComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Is this the initial placement of a fixed prosthesis?.
    @returns {Array} an array of {@link boolean} objects
     */

    ProsthesisComponent.prototype.initial = function() {
      return this.json['initial'];
    };


    /**
    Date of the initial placement.
    @returns {Array} an array of {@link Date} objects
     */

    ProsthesisComponent.prototype.priorDate = function() {
      if (this.json['priorDate']) {
        return DT.DateTime.parse(this.json['priorDate']);
      }
    };


    /**
    Material of the prior denture or bridge prosthesis. (Oral).
    @returns {Coding}
     */

    ProsthesisComponent.prototype.priorMaterial = function() {
      if (this.json['priorMaterial']) {
        return new Coding(this.json['priorMaterial']);
      }
    };

    return ProsthesisComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ItemsComponent
  @exports  ItemsComponent as ItemsComponent
   */

  ItemsComponent = (function(superClass) {
    extend(ItemsComponent, superClass);

    function ItemsComponent(json) {
      this.json = json;
      ItemsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The type of product or service.
    @returns {Coding}
     */

    ItemsComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    ItemsComponent.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied.
    @returns {Coding}
     */

    ItemsComponent.prototype.service = function() {
      if (this.json['service']) {
        return new Coding(this.json['service']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    ItemsComponent.prototype.serviceDate = function() {
      if (this.json['serviceDate']) {
        return DT.DateTime.parse(this.json['serviceDate']);
      }
    };


    /**
    The number of repetitions of a service or product.
    @returns {Quantity}
     */

    ItemsComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    @returns {Money}
     */

    ItemsComponent.prototype.unitPrice = function() {
      if (this.json['unitPrice']) {
        return new Money(this.json['unitPrice']);
      }
    };


    /**
    A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.factor = function() {
      return this.json['factor'];
    };


    /**
    An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.points = function() {
      return this.json['points'];
    };


    /**
    The quantity times the unit price for an addtional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    @returns {Money}
     */

    ItemsComponent.prototype.net = function() {
      if (this.json['net']) {
        return new Money(this.json['net']);
      }
    };


    /**
    List of Unique Device Identifiers associated with this line item.
    @returns {Coding}
     */

    ItemsComponent.prototype.udi = function() {
      if (this.json['udi']) {
        return new Coding(this.json['udi']);
      }
    };


    /**
    Physical service site on the patient (limb, tooth, etc).
    @returns {Coding}
     */

    ItemsComponent.prototype.bodySite = function() {
      if (this.json['bodySite']) {
        return new Coding(this.json['bodySite']);
      }
    };


    /**
    A region or surface of the site, eg. limb region or tooth surface(s).
    @returns {Array} an array of {@link Coding} objects
     */

    ItemsComponent.prototype.subsite = function() {
      var i, item, len, ref, results;
      if (this.json['subsite']) {
        ref = this.json['subsite'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or an appliance was lost or stolen.
    @returns {Array} an array of {@link Coding} objects
     */

    ItemsComponent.prototype.modifier = function() {
      var i, item, len, ref, results;
      if (this.json['modifier']) {
        ref = this.json['modifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Second tier of goods and services.
    @returns {Array} an array of {@link DetailComponent} objects
     */

    ItemsComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DetailComponent(item));
        }
        return results;
      }
    };


    /**
    The materials and placement date of prior fixed prosthesis.
    @returns {ProsthesisComponent}
     */

    ItemsComponent.prototype.prosthesis = function() {
      if (this.json['prosthesis']) {
        return new ProsthesisComponent(this.json['prosthesis']);
      }
    };

    return ItemsComponent;

  })(BackboneElement);


  /**
  A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
  @class OralHealthClaim
  @exports OralHealthClaim as OralHealthClaim
   */

  OralHealthClaim = (function(superClass) {
    extend(OralHealthClaim, superClass);

    function OralHealthClaim(json) {
      this.json = json;
      OralHealthClaim.__super__.constructor.call(this, this.json);
    }


    /**
    The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number.
    @returns {Array} an array of {@link Identifier} objects
     */

    OralHealthClaim.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the specification on which this instance relies.
    @returns {Coding}
     */

    OralHealthClaim.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The version of the specification from which the original instance was created.
    @returns {Coding}
     */

    OralHealthClaim.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    OralHealthClaim.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Insurer Identifier, typical BIN number (6 digit).
    @returns {Reference}
     */

    OralHealthClaim.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The provider which is responsible for the bill, claim pre-determination, pre-authorization.
    @returns {Reference}
     */

    OralHealthClaim.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the bill, claim pre-determination, pre-authorization.
    @returns {Reference}
     */

    OralHealthClaim.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Complete (Bill or Claim), Proposed (Pre-Authorization), Exploratory (Pre-determination).
    @returns {Array} an array of {@link String} objects
     */

    OralHealthClaim.prototype.use = function() {
      return this.json['use'];
    };


    /**
    Immediate (STAT), best effort (NORMAL), deferred (DEFER).
    @returns {Coding}
     */

    OralHealthClaim.prototype.priority = function() {
      if (this.json['priority']) {
        return new Coding(this.json['priority']);
      }
    };


    /**
    In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested.
    @returns {Coding}
     */

    OralHealthClaim.prototype.fundsReserve = function() {
      if (this.json['fundsReserve']) {
        return new Coding(this.json['fundsReserve']);
      }
    };


    /**
    Person who created the invoice/claim/pre-determination or pre-authorization.
    @returns {Reference}
     */

    OralHealthClaim.prototype.enterer = function() {
      if (this.json['enterer']) {
        return new Reference(this.json['enterer']);
      }
    };


    /**
    Facility where the services were provided.
    @returns {Reference}
     */

    OralHealthClaim.prototype.facility = function() {
      if (this.json['facility']) {
        return new Reference(this.json['facility']);
      }
    };


    /**
    Theparty to be reimbused for the services.
    @returns {PayeeComponent}
     */

    OralHealthClaim.prototype.payee = function() {
      if (this.json['payee']) {
        return new PayeeComponent(this.json['payee']);
      }
    };


    /**
    The referral resource which lists the date, practitioner, reason and other supporting information.
    @returns {Reference}
     */

    OralHealthClaim.prototype.referral = function() {
      if (this.json['referral']) {
        return new Reference(this.json['referral']);
      }
    };


    /**
    Ordered list of patient diagnosis for which care is sought.
    @returns {Array} an array of {@link DiagnosisComponent} objects
     */

    OralHealthClaim.prototype.diagnosis = function() {
      var i, item, len, ref, results;
      if (this.json['diagnosis']) {
        ref = this.json['diagnosis'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DiagnosisComponent(item));
        }
        return results;
      }
    };


    /**
    List of patient conditions for which care is sought.
    @returns {Array} an array of {@link Coding} objects
     */

    OralHealthClaim.prototype.condition = function() {
      var i, item, len, ref, results;
      if (this.json['condition']) {
        ref = this.json['condition'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Patient Resource.
    @returns {Reference}
     */

    OralHealthClaim.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Financial instrument by which payment information for health care.
    @returns {Array} an array of {@link CoverageComponent} objects
     */

    OralHealthClaim.prototype.coverage = function() {
      var i, item, len, ref, results;
      if (this.json['coverage']) {
        ref = this.json['coverage'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CoverageComponent(item));
        }
        return results;
      }
    };


    /**
    Factors which may influence the applicability of coverage.
    @returns {Array} an array of {@link Coding} objects
     */

    OralHealthClaim.prototype.exception = function() {
      var i, item, len, ref, results;
      if (this.json['exception']) {
        ref = this.json['exception'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Name of school for over-aged dependants.
    @returns {Array} an array of {@link String} objects
     */

    OralHealthClaim.prototype.school = function() {
      return this.json['school'];
    };


    /**
    Date of an accident which these services are addessing.
    @returns {Array} an array of {@link Date} objects
     */

    OralHealthClaim.prototype.accident = function() {
      if (this.json['accident']) {
        return DT.DateTime.parse(this.json['accident']);
      }
    };


    /**
    Type of accident: work, auto, etc.
    @returns {Coding}
     */

    OralHealthClaim.prototype.accidentType = function() {
      if (this.json['accidentType']) {
        return new Coding(this.json['accidentType']);
      }
    };


    /**
    A list of intervention and exception codes which may influence the adjudication of the claim.
    @returns {Array} an array of {@link Coding} objects
     */

    OralHealthClaim.prototype.interventionException = function() {
      var i, item, len, ref, results;
      if (this.json['interventionException']) {
        ref = this.json['interventionException'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    A list of teeth which would be expected but are not found due to having been previously  extracted or for other reasons.
    @returns {Array} an array of {@link MissingTeethComponent} objects
     */

    OralHealthClaim.prototype.missingteeth = function() {
      var i, item, len, ref, results;
      if (this.json['missingteeth']) {
        ref = this.json['missingteeth'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new MissingTeethComponent(item));
        }
        return results;
      }
    };


    /**
    The highlevel detail sof an Orthodonic Treatment Plan.
    @returns {OrthodonticPlanComponent}
     */

    OralHealthClaim.prototype.orthoPlan = function() {
      if (this.json['orthoPlan']) {
        return new OrthodonticPlanComponent(this.json['orthoPlan']);
      }
    };


    /**
    First tier of goods and services.
    @returns {Array} an array of {@link ItemsComponent} objects
     */

    OralHealthClaim.prototype.item = function() {
      var i, item, len, ref, results;
      if (this.json['item']) {
        ref = this.json['item'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemsComponent(item));
        }
        return results;
      }
    };


    /**
    Code to indicate that Xrays, images, emails, documents, models or attachments are being sent in support of this submission.
    @returns {Array} an array of {@link Coding} objects
     */

    OralHealthClaim.prototype.additionalMaterials = function() {
      var i, item, len, ref, results;
      if (this.json['additionalMaterials']) {
        ref = this.json['additionalMaterials'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };

    return OralHealthClaim;

  })(DomainResource);

  module.exports.OralHealthClaim = OralHealthClaim;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],97:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Order, OrderWhenComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class OrderWhenComponent
  @exports  OrderWhenComponent as OrderWhenComponent
   */

  OrderWhenComponent = (function(superClass) {
    extend(OrderWhenComponent, superClass);

    function OrderWhenComponent(json) {
      this.json = json;
      OrderWhenComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code specifies when request should be done. The code may simply be a priority code.
    @returns {CodeableConcept}
     */

    OrderWhenComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    A formal schedule.
    @returns {Timing}
     */

    OrderWhenComponent.prototype.schedule = function() {
      if (this.json['schedule']) {
        return new Timing(this.json['schedule']);
      }
    };

    return OrderWhenComponent;

  })(BackboneElement);


  /**
  A request to perform an action.
  @class Order
  @exports Order as Order
   */

  Order = (function(superClass) {
    extend(Order, superClass);

    function Order(json) {
      this.json = json;
      Order.__super__.constructor.call(this, this.json);
    }


    /**
    Identifiers assigned to this order by the orderer or by the receiver.
    @returns {Array} an array of {@link Identifier} objects
     */

    Order.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    When the order was made.
    @returns {Array} an array of {@link Date} objects
     */

    Order.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Patient this order is about.
    @returns {Reference}
     */

    Order.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Who initiated the order.
    @returns {Reference}
     */

    Order.prototype.source = function() {
      if (this.json['source']) {
        return new Reference(this.json['source']);
      }
    };


    /**
    Who is intended to fulfill the order.
    @returns {Reference}
     */

    Order.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    Text - why the order was made.
    @returns {CodeableConcept}
     */

    Order.prototype.reasonCodeableConcept = function() {
      if (this.json['reasonCodeableConcept']) {
        return new CodeableConcept(this.json['reasonCodeableConcept']);
      }
    };


    /**
    Text - why the order was made.
    @returns {Reference}
     */

    Order.prototype.reasonReference = function() {
      if (this.json['reasonReference']) {
        return new Reference(this.json['reasonReference']);
      }
    };


    /**
    If required by policy.
    @returns {Reference}
     */

    Order.prototype.authority = function() {
      if (this.json['authority']) {
        return new Reference(this.json['authority']);
      }
    };


    /**
    When order should be fulfilled.
    @returns {OrderWhenComponent}
     */

    Order.prototype.when = function() {
      if (this.json['when']) {
        return new OrderWhenComponent(this.json['when']);
      }
    };


    /**
    What action is being ordered.
    @returns {Array} an array of {@link Reference} objects
     */

    Order.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return Order;

  })(DomainResource);

  module.exports.Order = Order;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],98:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, OrderResponse, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A response to an order.
  @class OrderResponse
  @exports OrderResponse as OrderResponse
   */

  OrderResponse = (function(superClass) {
    extend(OrderResponse, superClass);

    function OrderResponse(json) {
      this.json = json;
      OrderResponse.__super__.constructor.call(this, this.json);
    }


    /**
    Identifiers assigned to this order. The identifiers are usually assigned by the system responding to the order, but they may be provided or added to by other systems.
    @returns {Array} an array of {@link Identifier} objects
     */

    OrderResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A reference to the order that this is in response to.
    @returns {Reference}
     */

    OrderResponse.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    The date and time at which this order response was made (created/posted).
    @returns {Array} an array of {@link Date} objects
     */

    OrderResponse.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The person, organization, or device credited with making the response.
    @returns {Reference}
     */

    OrderResponse.prototype.who = function() {
      if (this.json['who']) {
        return new Reference(this.json['who']);
      }
    };


    /**
    A reference to an authority policy that is the reason for the response. Usually this is used when the order is rejected, to provide a reason for rejection.
    @returns {CodeableConcept}
     */

    OrderResponse.prototype.authorityCodeableConcept = function() {
      if (this.json['authorityCodeableConcept']) {
        return new CodeableConcept(this.json['authorityCodeableConcept']);
      }
    };


    /**
    A reference to an authority policy that is the reason for the response. Usually this is used when the order is rejected, to provide a reason for rejection.
    @returns {Reference}
     */

    OrderResponse.prototype.authorityReference = function() {
      if (this.json['authorityReference']) {
        return new Reference(this.json['authorityReference']);
      }
    };


    /**
    What this response says about the status of the original order.
    @returns {Array} an array of {@link String} objects
     */

    OrderResponse.prototype.code = function() {
      return this.json['code'];
    };


    /**
    Additional description about the response - e.g. a text description provided by a human user when making decisions about the order.
    @returns {Array} an array of {@link String} objects
     */

    OrderResponse.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Links to resources that provide details of the outcome of performing the order. E.g. Diagnostic Reports in a response that is made to an order that referenced a diagnostic order.
    @returns {Array} an array of {@link Reference} objects
     */

    OrderResponse.prototype.fulfillment = function() {
      var i, item, len, ref, results;
      if (this.json['fulfillment']) {
        ref = this.json['fulfillment'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return OrderResponse;

  })(DomainResource);

  module.exports.OrderResponse = OrderResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],99:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Organization, OrganizationContactComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class OrganizationContactComponent
  @exports  OrganizationContactComponent as OrganizationContactComponent
   */

  OrganizationContactComponent = (function(superClass) {
    extend(OrganizationContactComponent, superClass);

    function OrganizationContactComponent(json) {
      this.json = json;
      OrganizationContactComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Indicates a purpose for which the contact can be reached.
    @returns {CodeableConcept}
     */

    OrganizationContactComponent.prototype.purpose = function() {
      if (this.json['purpose']) {
        return new CodeableConcept(this.json['purpose']);
      }
    };


    /**
    A name associated with the contact.
    @returns {HumanName}
     */

    OrganizationContactComponent.prototype.name = function() {
      if (this.json['name']) {
        return new HumanName(this.json['name']);
      }
    };


    /**
    A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    OrganizationContactComponent.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Visiting or postal addresses for the contact.
    @returns {Address}
     */

    OrganizationContactComponent.prototype.address = function() {
      if (this.json['address']) {
        return new Address(this.json['address']);
      }
    };


    /**
    Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    @returns {Array} an array of {@link String} objects
     */

    OrganizationContactComponent.prototype.gender = function() {
      return this.json['gender'];
    };

    return OrganizationContactComponent;

  })(BackboneElement);


  /**
  A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, etc.
  @class Organization
  @exports Organization as Organization
   */

  Organization = (function(superClass) {
    extend(Organization, superClass);

    function Organization(json) {
      this.json = json;
      Organization.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier for the organization that is used to identify the organization across multiple disparate systems.
    @returns {Array} an array of {@link Identifier} objects
     */

    Organization.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A name associated with the organization.
    @returns {Array} an array of {@link String} objects
     */

    Organization.prototype.name = function() {
      return this.json['name'];
    };


    /**
    The kind of organization that this is.
    @returns {CodeableConcept}
     */

    Organization.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    A contact detail for the organization.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Organization.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    An address for the organization.
    @returns {Array} an array of {@link Address} objects
     */

    Organization.prototype.address = function() {
      var i, item, len, ref, results;
      if (this.json['address']) {
        ref = this.json['address'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Address(item));
        }
        return results;
      }
    };


    /**
    The organization of which this organization forms a part.
    @returns {Reference}
     */

    Organization.prototype.partOf = function() {
      if (this.json['partOf']) {
        return new Reference(this.json['partOf']);
      }
    };


    /**
    Contact for the organization for a certain purpose.
    @returns {Array} an array of {@link OrganizationContactComponent} objects
     */

    Organization.prototype.contact = function() {
      var i, item, len, ref, results;
      if (this.json['contact']) {
        ref = this.json['contact'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new OrganizationContactComponent(item));
        }
        return results;
      }
    };


    /**
    Location(s) the organization uses to provide services.
    @returns {Array} an array of {@link Reference} objects
     */

    Organization.prototype.location = function() {
      var i, item, len, ref, results;
      if (this.json['location']) {
        ref = this.json['location'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Whether the organization's record is still in active use.
    @returns {Array} an array of {@link boolean} objects
     */

    Organization.prototype.active = function() {
      return this.json['active'];
    };

    return Organization;

  })(DomainResource);

  module.exports.Organization = Organization;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],100:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Other, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Other is a conformant for handling resource concepts not yet defined for FHIR or outside HL7's scope of interest.
  @class Other
  @exports Other as Other
   */

  Other = (function(superClass) {
    extend(Other, superClass);

    function Other(json) {
      this.json = json;
      Other.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned to the resource for business purposes, outside the context of FHIR.
    @returns {Array} an array of {@link Identifier} objects
     */

    Other.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Identifies the 'type' of resource - equivalent to the resource name for other resources.
    @returns {CodeableConcept}
     */

    Other.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Identifies the patient, practitioner, device or any other resource that is the "focus" of this resoruce.
    @returns {Reference}
     */

    Other.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Indicates who was responsible for creating the resource instance.
    @returns {Reference}
     */

    Other.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    Identifies when the resource was first created.
    @returns {Array} an array of {@link Date} objects
     */

    Other.prototype.created = function() {
      if (this.json['created']) {
        return DT.DateTime.parse(this.json['created']);
      }
    };

    return Other;

  })(DomainResource);

  module.exports.Other = Other;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],101:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, AnimalComponent, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Patient, PatientLinkComponent, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ContactComponent
  @exports  ContactComponent as ContactComponent
   */

  ContactComponent = (function(superClass) {
    extend(ContactComponent, superClass);

    function ContactComponent(json) {
      this.json = json;
      ContactComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The nature of the relationship between the patient and the contact person.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ContactComponent.prototype.relationship = function() {
      var i, item, len, ref, results;
      if (this.json['relationship']) {
        ref = this.json['relationship'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A name associated with the person.
    @returns {HumanName}
     */

    ContactComponent.prototype.name = function() {
      if (this.json['name']) {
        return new HumanName(this.json['name']);
      }
    };


    /**
    A contact detail for the person, e.g. a telephone number or an email address.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    ContactComponent.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Address for the contact person.
    @returns {Address}
     */

    ContactComponent.prototype.address = function() {
      if (this.json['address']) {
        return new Address(this.json['address']);
      }
    };


    /**
    Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    @returns {Array} an array of {@link String} objects
     */

    ContactComponent.prototype.gender = function() {
      return this.json['gender'];
    };


    /**
    Organization on behalf of which the contact is acting or for which the contact is working.
    @returns {Reference}
     */

    ContactComponent.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The period during which this person or organisation is valid to be contacted relating to this patient.
    @returns {Period}
     */

    ContactComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return ContactComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class AnimalComponent
  @exports  AnimalComponent as AnimalComponent
   */

  AnimalComponent = (function(superClass) {
    extend(AnimalComponent, superClass);

    function AnimalComponent(json) {
      this.json = json;
      AnimalComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the high level categorization of the kind of animal.
    @returns {CodeableConcept}
     */

    AnimalComponent.prototype.species = function() {
      if (this.json['species']) {
        return new CodeableConcept(this.json['species']);
      }
    };


    /**
    Identifies the detailed categorization of the kind of animal.
    @returns {CodeableConcept}
     */

    AnimalComponent.prototype.breed = function() {
      if (this.json['breed']) {
        return new CodeableConcept(this.json['breed']);
      }
    };


    /**
    Indicates the current state of the animal's reproductive organs.
    @returns {CodeableConcept}
     */

    AnimalComponent.prototype.genderStatus = function() {
      if (this.json['genderStatus']) {
        return new CodeableConcept(this.json['genderStatus']);
      }
    };

    return AnimalComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class PatientLinkComponent
  @exports  PatientLinkComponent as PatientLinkComponent
   */

  PatientLinkComponent = (function(superClass) {
    extend(PatientLinkComponent, superClass);

    function PatientLinkComponent(json) {
      this.json = json;
      PatientLinkComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The other patient resource that the link refers to.
    @returns {Reference}
     */

    PatientLinkComponent.prototype.other = function() {
      if (this.json['other']) {
        return new Reference(this.json['other']);
      }
    };


    /**
    The type of link between this patient resource and another patient resource.
    @returns {Array} an array of {@link String} objects
     */

    PatientLinkComponent.prototype.type = function() {
      return this.json['type'];
    };

    return PatientLinkComponent;

  })(BackboneElement);


  /**
  Demographics and other administrative information about a person or animal receiving care or other health-related services.
  @class Patient
  @exports Patient as Patient
   */

  Patient = (function(superClass) {
    extend(Patient, superClass);

    function Patient(json) {
      this.json = json;
      Patient.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier that applies to this person as a patient.
    @returns {Array} an array of {@link Identifier} objects
     */

    Patient.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A name associated with the individual.
    @returns {Array} an array of {@link HumanName} objects
     */

    Patient.prototype.name = function() {
      var i, item, len, ref, results;
      if (this.json['name']) {
        ref = this.json['name'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new HumanName(item));
        }
        return results;
      }
    };


    /**
    A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Patient.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
    @returns {Array} an array of {@link String} objects
     */

    Patient.prototype.gender = function() {
      return this.json['gender'];
    };


    /**
    The date and time of birth for the individual.
    @returns {Array} an array of {@link Date} objects
     */

    Patient.prototype.birthDate = function() {
      if (this.json['birthDate']) {
        return DT.DateTime.parse(this.json['birthDate']);
      }
    };


    /**
    Indicates if the individual is deceased or not.
    @returns {Array} an array of {@link boolean} objects
     */

    Patient.prototype.deceasedBoolean = function() {
      return this.json['deceasedBoolean'];
    };


    /**
    Indicates if the individual is deceased or not.
    @returns {Array} an array of {@link Date} objects
     */

    Patient.prototype.deceasedDateTime = function() {
      if (this.json['deceasedDateTime']) {
        return DT.DateTime.parse(this.json['deceasedDateTime']);
      }
    };


    /**
    Addresses for the individual.
    @returns {Array} an array of {@link Address} objects
     */

    Patient.prototype.address = function() {
      var i, item, len, ref, results;
      if (this.json['address']) {
        ref = this.json['address'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Address(item));
        }
        return results;
      }
    };


    /**
    This field contains a patient's most recent marital (civil) status.
    @returns {CodeableConcept}
     */

    Patient.prototype.maritalStatus = function() {
      if (this.json['maritalStatus']) {
        return new CodeableConcept(this.json['maritalStatus']);
      }
    };


    /**
    Indicates whether the patient is part of a multiple or indicates the actual birth order.
    @returns {Array} an array of {@link boolean} objects
     */

    Patient.prototype.multipleBirthBoolean = function() {
      return this.json['multipleBirthBoolean'];
    };


    /**
    Indicates whether the patient is part of a multiple or indicates the actual birth order.
    @returns {Array} an array of {@link Number} objects
     */

    Patient.prototype.multipleBirthInteger = function() {
      return this.json['multipleBirthInteger'];
    };


    /**
    Image of the person.
    @returns {Array} an array of {@link Attachment} objects
     */

    Patient.prototype.photo = function() {
      var i, item, len, ref, results;
      if (this.json['photo']) {
        ref = this.json['photo'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Attachment(item));
        }
        return results;
      }
    };


    /**
    A contact party (e.g. guardian, partner, friend) for the patient.
    @returns {Array} an array of {@link ContactComponent} objects
     */

    Patient.prototype.contact = function() {
      var i, item, len, ref, results;
      if (this.json['contact']) {
        ref = this.json['contact'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactComponent(item));
        }
        return results;
      }
    };


    /**
    This element has a value if the patient is an animal.
    @returns {AnimalComponent}
     */

    Patient.prototype.animal = function() {
      if (this.json['animal']) {
        return new AnimalComponent(this.json['animal']);
      }
    };


    /**
    Languages which may be used to communicate with the patient about his or her health.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Patient.prototype.communication = function() {
      var i, item, len, ref, results;
      if (this.json['communication']) {
        ref = this.json['communication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Patient's nominated care provider.
    @returns {Array} an array of {@link Reference} objects
     */

    Patient.prototype.careProvider = function() {
      var i, item, len, ref, results;
      if (this.json['careProvider']) {
        ref = this.json['careProvider'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Organization that is the custodian of the patient record.
    @returns {Reference}
     */

    Patient.prototype.managingOrganization = function() {
      if (this.json['managingOrganization']) {
        return new Reference(this.json['managingOrganization']);
      }
    };


    /**
    Link to another patient resource that concerns the same actual person.
    @returns {Array} an array of {@link PatientLinkComponent} objects
     */

    Patient.prototype.link = function() {
      var i, item, len, ref, results;
      if (this.json['link']) {
        ref = this.json['link'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new PatientLinkComponent(item));
        }
        return results;
      }
    };


    /**
    Whether this patient record is in active use.
    @returns {Array} an array of {@link boolean} objects
     */

    Patient.prototype.active = function() {
      return this.json['active'];
    };

    return Patient;

  })(DomainResource);

  module.exports.Patient = Patient;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],102:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, PaymentNotice, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides the request and response details for the request for which the payment status is being reported.
  @class PaymentNotice
  @exports PaymentNotice as PaymentNotice
   */

  PaymentNotice = (function(superClass) {
    extend(PaymentNotice, superClass);

    function PaymentNotice(json) {
      this.json = json;
      PaymentNotice.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    PaymentNotice.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    PaymentNotice.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    PaymentNotice.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    PaymentNotice.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    PaymentNotice.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PaymentNotice.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PaymentNotice.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Reference of resource to reverse.
    @returns {Reference}
     */

    PaymentNotice.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Reference of response to resource to reverse.
    @returns {Reference}
     */

    PaymentNotice.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };


    /**
    The payment status, typically paid: payment sent, cleared: payment received.
    @returns {Coding}
     */

    PaymentNotice.prototype.paymentStatus = function() {
      if (this.json['paymentStatus']) {
        return new Coding(this.json['paymentStatus']);
      }
    };

    return PaymentNotice;

  })(DomainResource);

  module.exports.PaymentNotice = PaymentNotice;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],103:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DetailsComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, NotesComponent, Parameters, PaymentReconciliation, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DetailsComponent
  @exports  DetailsComponent as DetailsComponent
   */

  DetailsComponent = (function(superClass) {
    extend(DetailsComponent, superClass);

    function DetailsComponent(json) {
      this.json = json;
      DetailsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code to indicate the nature of the payment, adjustment, funds advance, etc.
    @returns {Coding}
     */

    DetailsComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The claim or financial resource.
    @returns {Reference}
     */

    DetailsComponent.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    The claim response resource.
    @returns {Reference}
     */

    DetailsComponent.prototype.responce = function() {
      if (this.json['responce']) {
        return new Reference(this.json['responce']);
      }
    };


    /**
    The Organization which submitted the invoice or financial transaction.
    @returns {Reference}
     */

    DetailsComponent.prototype.submitter = function() {
      if (this.json['submitter']) {
        return new Reference(this.json['submitter']);
      }
    };


    /**
    The organization which is receiving the payment.
    @returns {Reference}
     */

    DetailsComponent.prototype.payee = function() {
      if (this.json['payee']) {
        return new Reference(this.json['payee']);
      }
    };


    /**
    The date of the invoice or financial resource.
    @returns {Array} an array of {@link Date} objects
     */

    DetailsComponent.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Amount paid for this detail.
    @returns {Money}
     */

    DetailsComponent.prototype.amount = function() {
      if (this.json['amount']) {
        return new Money(this.json['amount']);
      }
    };

    return DetailsComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class NotesComponent
  @exports  NotesComponent as NotesComponent
   */

  NotesComponent = (function(superClass) {
    extend(NotesComponent, superClass);

    function NotesComponent(json) {
      this.json = json;
      NotesComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The note purpose: Print/Display.
    @returns {Coding}
     */

    NotesComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The note text.
    @returns {Array} an array of {@link String} objects
     */

    NotesComponent.prototype.text = function() {
      return this.json['text'];
    };

    return NotesComponent;

  })(BackboneElement);


  /**
  This resource provides payment details supporting a bulk payment, or the errors in,  processing a ReconciliationRequest resource.
  @class PaymentReconciliation
  @exports PaymentReconciliation as PaymentReconciliation
   */

  PaymentReconciliation = (function(superClass) {
    extend(PaymentReconciliation, superClass);

    function PaymentReconciliation(json) {
      this.json = json;
      PaymentReconciliation.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    PaymentReconciliation.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    PaymentReconciliation.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Transaction status: error, complete.
    @returns {Array} an array of {@link String} objects
     */

    PaymentReconciliation.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A description of the status of the adjudication.
    @returns {Array} an array of {@link String} objects
     */

    PaymentReconciliation.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    PaymentReconciliation.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    PaymentReconciliation.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    PaymentReconciliation.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    PaymentReconciliation.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PaymentReconciliation.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PaymentReconciliation.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };


    /**
    List of individual settlement amounts and the corresponding transaction.
    @returns {Array} an array of {@link DetailsComponent} objects
     */

    PaymentReconciliation.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DetailsComponent(item));
        }
        return results;
      }
    };


    /**
    The form to be used for printing the content.
    @returns {Coding}
     */

    PaymentReconciliation.prototype.form = function() {
      if (this.json['form']) {
        return new Coding(this.json['form']);
      }
    };


    /**
    Total payment amount.
    @returns {Money}
     */

    PaymentReconciliation.prototype.total = function() {
      if (this.json['total']) {
        return new Money(this.json['total']);
      }
    };


    /**
    List of errors detected in the request.
    @returns {Array} an array of {@link Coding} objects
     */

    PaymentReconciliation.prototype.error = function() {
      var i, item, len, ref, results;
      if (this.json['error']) {
        ref = this.json['error'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Suite of notes.
    @returns {Array} an array of {@link NotesComponent} objects
     */

    PaymentReconciliation.prototype.note = function() {
      var i, item, len, ref, results;
      if (this.json['note']) {
        ref = this.json['note'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new NotesComponent(item));
        }
        return results;
      }
    };

    return PaymentReconciliation;

  })(DomainResource);

  module.exports.PaymentReconciliation = PaymentReconciliation;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],104:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, PendedRequest, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides the request and response details for the resource for which the stsatus is to be checked.
  @class PendedRequest
  @exports PendedRequest as PendedRequest
   */

  PendedRequest = (function(superClass) {
    extend(PendedRequest, superClass);

    function PendedRequest(json) {
      this.json = json;
      PendedRequest.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    PendedRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    PendedRequest.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    PendedRequest.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    PendedRequest.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    PendedRequest.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PendedRequest.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    PendedRequest.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Reference of resource to reverse.
    @returns {Reference}
     */

    PendedRequest.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Names of resource types to include.
    @returns {Array} an array of {@link String} objects
     */

    PendedRequest.prototype.include = function() {
      return this.json['include'];
    };


    /**
    Names of resource types to exclude.
    @returns {Array} an array of {@link String} objects
     */

    PendedRequest.prototype.exclude = function() {
      return this.json['exclude'];
    };


    /**
    A period of time during which the fulfilling resources would have been created.
    @returns {Period}
     */

    PendedRequest.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };

    return PendedRequest;

  })(DomainResource);

  module.exports.PendedRequest = PendedRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],105:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Practitioner, PractitionerQualificationComponent, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class PractitionerQualificationComponent
  @exports  PractitionerQualificationComponent as PractitionerQualificationComponent
   */

  PractitionerQualificationComponent = (function(superClass) {
    extend(PractitionerQualificationComponent, superClass);

    function PractitionerQualificationComponent(json) {
      this.json = json;
      PractitionerQualificationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier that applies to this person's qualification in this role.
    @returns {Array} an array of {@link Identifier} objects
     */

    PractitionerQualificationComponent.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Coded representation of the qualification.
    @returns {CodeableConcept}
     */

    PractitionerQualificationComponent.prototype.code = function() {
      if (this.json['code']) {
        return new CodeableConcept(this.json['code']);
      }
    };


    /**
    Period during which the qualification is valid.
    @returns {Period}
     */

    PractitionerQualificationComponent.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    Organization that regulates and issues the qualification.
    @returns {Reference}
     */

    PractitionerQualificationComponent.prototype.issuer = function() {
      if (this.json['issuer']) {
        return new Reference(this.json['issuer']);
      }
    };

    return PractitionerQualificationComponent;

  })(BackboneElement);


  /**
  A person who is directly or indirectly involved in the provisioning of healthcare.
  @class Practitioner
  @exports Practitioner as Practitioner
   */

  Practitioner = (function(superClass) {
    extend(Practitioner, superClass);

    function Practitioner(json) {
      this.json = json;
      Practitioner.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier that applies to this person in this role.
    @returns {Array} an array of {@link Identifier} objects
     */

    Practitioner.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    A name associated with the person.
    @returns {HumanName}
     */

    Practitioner.prototype.name = function() {
      if (this.json['name']) {
        return new HumanName(this.json['name']);
      }
    };


    /**
    A contact detail for the practitioner, e.g. a telephone number or an email address.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Practitioner.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    The postal address where the practitioner can be found or visited or to which mail can be delivered.
    @returns {Array} an array of {@link Address} objects
     */

    Practitioner.prototype.address = function() {
      var i, item, len, ref, results;
      if (this.json['address']) {
        ref = this.json['address'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Address(item));
        }
        return results;
      }
    };


    /**
    Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    @returns {Array} an array of {@link String} objects
     */

    Practitioner.prototype.gender = function() {
      return this.json['gender'];
    };


    /**
    The date and time of birth for the practitioner.
    @returns {Array} an array of {@link Date} objects
     */

    Practitioner.prototype.birthDate = function() {
      if (this.json['birthDate']) {
        return DT.DateTime.parse(this.json['birthDate']);
      }
    };


    /**
    Image of the person.
    @returns {Array} an array of {@link Attachment} objects
     */

    Practitioner.prototype.photo = function() {
      var i, item, len, ref, results;
      if (this.json['photo']) {
        ref = this.json['photo'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Attachment(item));
        }
        return results;
      }
    };


    /**
    The organization that the practitioner represents.
    @returns {Reference}
     */

    Practitioner.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Roles which this practitioner is authorized to perform for the organization.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Practitioner.prototype.role = function() {
      var i, item, len, ref, results;
      if (this.json['role']) {
        ref = this.json['role'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Specific specialty of the practitioner.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Practitioner.prototype.specialty = function() {
      var i, item, len, ref, results;
      if (this.json['specialty']) {
        ref = this.json['specialty'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
    @returns {Period}
     */

    Practitioner.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    The location(s) at which this practitioner provides care.
    @returns {Array} an array of {@link Reference} objects
     */

    Practitioner.prototype.location = function() {
      var i, item, len, ref, results;
      if (this.json['location']) {
        ref = this.json['location'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Qualifications obtained by training and certification.
    @returns {Array} an array of {@link PractitionerQualificationComponent} objects
     */

    Practitioner.prototype.qualification = function() {
      var i, item, len, ref, results;
      if (this.json['qualification']) {
        ref = this.json['qualification'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new PractitionerQualificationComponent(item));
        }
        return results;
      }
    };


    /**
    A language the practitioner is able to use in patient communication.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Practitioner.prototype.communication = function() {
      var i, item, len, ref, results;
      if (this.json['communication']) {
        ref = this.json['communication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };

    return Practitioner;

  })(DomainResource);

  module.exports.Practitioner = Practitioner;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],106:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Procedure, ProcedurePerformerComponent, ProcedureRelatedItemComponent, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ProcedurePerformerComponent
  @exports  ProcedurePerformerComponent as ProcedurePerformerComponent
   */

  ProcedurePerformerComponent = (function(superClass) {
    extend(ProcedurePerformerComponent, superClass);

    function ProcedurePerformerComponent(json) {
      this.json = json;
      ProcedurePerformerComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The practitioner who was involved in the procedure.
    @returns {Reference}
     */

    ProcedurePerformerComponent.prototype.person = function() {
      if (this.json['person']) {
        return new Reference(this.json['person']);
      }
    };


    /**
    E.g. surgeon, anaethetist, endoscopist.
    @returns {CodeableConcept}
     */

    ProcedurePerformerComponent.prototype.role = function() {
      if (this.json['role']) {
        return new CodeableConcept(this.json['role']);
      }
    };

    return ProcedurePerformerComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ProcedureRelatedItemComponent
  @exports  ProcedureRelatedItemComponent as ProcedureRelatedItemComponent
   */

  ProcedureRelatedItemComponent = (function(superClass) {
    extend(ProcedureRelatedItemComponent, superClass);

    function ProcedureRelatedItemComponent(json) {
      this.json = json;
      ProcedureRelatedItemComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The nature of the relationship.
    @returns {Array} an array of {@link String} objects
     */

    ProcedureRelatedItemComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The related item - e.g. a procedure.
    @returns {Reference}
     */

    ProcedureRelatedItemComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return ProcedureRelatedItemComponent;

  })(BackboneElement);


  /**
  An action that is performed on a patient. This can be a physical 'thing' like an operation, or less invasive like counseling or hypnotherapy.
  @class Procedure
  @exports Procedure as Procedure
   */

  Procedure = (function(superClass) {
    extend(Procedure, superClass);

    function Procedure(json) {
      this.json = json;
      Procedure.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this procedure that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    Procedure.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The person on whom the procedure was performed.
    @returns {Reference}
     */

    Procedure.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The specific procedure that is performed. Use text if the exact nature of the procedure can't be coded.
    @returns {CodeableConcept}
     */

    Procedure.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Procedure.prototype.bodySite = function() {
      var i, item, len, ref, results;
      if (this.json['bodySite']) {
        ref = this.json['bodySite'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The reason why the procedure was performed. This may be due to a Condition, may be coded entity of some type, or may simply be present as text.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Procedure.prototype.indication = function() {
      var i, item, len, ref, results;
      if (this.json['indication']) {
        ref = this.json['indication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Limited to 'real' people rather than equipment.
    @returns {Array} an array of {@link ProcedurePerformerComponent} objects
     */

    Procedure.prototype.performer = function() {
      var i, item, len, ref, results;
      if (this.json['performer']) {
        ref = this.json['performer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ProcedurePerformerComponent(item));
        }
        return results;
      }
    };


    /**
    The dates over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    @returns {Period}
     */

    Procedure.prototype.date = function() {
      if (this.json['date']) {
        return new Period(this.json['date']);
      }
    };


    /**
    The encounter during which the procedure was performed.
    @returns {Reference}
     */

    Procedure.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    What was the outcome of the procedure - did it resolve reasons why the procedure was performed?.
    @returns {Array} an array of {@link String} objects
     */

    Procedure.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    This could be a histology result. There could potentially be multiple reports - e.g. if this was a procedure that made multiple biopsies.
    @returns {Array} an array of {@link Reference} objects
     */

    Procedure.prototype.report = function() {
      var i, item, len, ref, results;
      if (this.json['report']) {
        ref = this.json['report'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Any complications that occurred during the procedure, or in the immediate post-operative period. These are generally tracked separately from the notes, which typically will describe the procedure itself rather than any 'post procedure' issues.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    Procedure.prototype.complication = function() {
      var i, item, len, ref, results;
      if (this.json['complication']) {
        ref = this.json['complication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or potentially could be more complex in which case the CarePlan resource can be used.
    @returns {Array} an array of {@link String} objects
     */

    Procedure.prototype.followUp = function() {
      return this.json['followUp'];
    };


    /**
    Procedures may be related to other items such as procedures or medications. For example treating wound dehiscence following a previous procedure.
    @returns {Array} an array of {@link ProcedureRelatedItemComponent} objects
     */

    Procedure.prototype.relatedItem = function() {
      var i, item, len, ref, results;
      if (this.json['relatedItem']) {
        ref = this.json['relatedItem'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ProcedureRelatedItemComponent(item));
        }
        return results;
      }
    };


    /**
    Any other notes about the procedure - e.g. the operative notes.
    @returns {Array} an array of {@link String} objects
     */

    Procedure.prototype.notes = function() {
      return this.json['notes'];
    };

    return Procedure;

  })(DomainResource);

  module.exports.Procedure = Procedure;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],107:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, ProcedureRequest, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A request for a procedure to be performed. May be a proposal or an order.
  @class ProcedureRequest
  @exports ProcedureRequest as ProcedureRequest
   */

  ProcedureRequest = (function(superClass) {
    extend(ProcedureRequest, superClass);

    function ProcedureRequest(json) {
      this.json = json;
      ProcedureRequest.__super__.constructor.call(this, this.json);
    }


    /**
    Identifiers assigned to this order by the order or by the receiver.
    @returns {Array} an array of {@link Identifier} objects
     */

    ProcedureRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The patient who will receive the procedure.
    @returns {Reference}
     */

    ProcedureRequest.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The specific procedure that is ordered. Use text if the exact nature of the procedure can't be coded.
    @returns {CodeableConcept}
     */

    ProcedureRequest.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The site where the procedure is to be performed.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ProcedureRequest.prototype.bodySite = function() {
      var i, item, len, ref, results;
      if (this.json['bodySite']) {
        ref = this.json['bodySite'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The reason why the procedure is proposed or ordered. This procedure request may be motivated by a Condition for instance.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ProcedureRequest.prototype.indication = function() {
      var i, item, len, ref, results;
      if (this.json['indication']) {
        ref = this.json['indication'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    The timing schedule for the proposed or ordered procedure. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Array} an array of {@link Date} objects
     */

    ProcedureRequest.prototype.timingDateTime = function() {
      if (this.json['timingDateTime']) {
        return DT.DateTime.parse(this.json['timingDateTime']);
      }
    };


    /**
    The timing schedule for the proposed or ordered procedure. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Period}
     */

    ProcedureRequest.prototype.timingPeriod = function() {
      if (this.json['timingPeriod']) {
        return new Period(this.json['timingPeriod']);
      }
    };


    /**
    The timing schedule for the proposed or ordered procedure. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    @returns {Timing}
     */

    ProcedureRequest.prototype.timingTiming = function() {
      if (this.json['timingTiming']) {
        return new Timing(this.json['timingTiming']);
      }
    };


    /**
    The encounter within which the procedure proposal or request was created.
    @returns {Reference}
     */

    ProcedureRequest.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    E.g. surgeon, anaethetist, endoscopist.
    @returns {Reference}
     */

    ProcedureRequest.prototype.performer = function() {
      if (this.json['performer']) {
        return new Reference(this.json['performer']);
      }
    };


    /**
    The status of the order.
    @returns {Array} an array of {@link String} objects
     */

    ProcedureRequest.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The status of the order.
    @returns {Array} an array of {@link String} objects
     */

    ProcedureRequest.prototype.mode = function() {
      return this.json['mode'];
    };


    /**
    Any other notes associated with this proposal or order - e.g., provider instructions.
    @returns {Array} an array of {@link String} objects
     */

    ProcedureRequest.prototype.notes = function() {
      return this.json['notes'];
    };


    /**
    If a CodeableConcept is present, it indicates the pre-condition for performing the procedure.
    @returns {Array} an array of {@link boolean} objects
     */

    ProcedureRequest.prototype.asNeededBoolean = function() {
      return this.json['asNeededBoolean'];
    };


    /**
    If a CodeableConcept is present, it indicates the pre-condition for performing the procedure.
    @returns {CodeableConcept}
     */

    ProcedureRequest.prototype.asNeededCodeableConcept = function() {
      if (this.json['asNeededCodeableConcept']) {
        return new CodeableConcept(this.json['asNeededCodeableConcept']);
      }
    };


    /**
    The time when the request was made.
    @returns {Array} an array of {@link Date} objects
     */

    ProcedureRequest.prototype.orderedOn = function() {
      if (this.json['orderedOn']) {
        return DT.DateTime.parse(this.json['orderedOn']);
      }
    };


    /**
    The healthcare professional responsible for proposing or ordering the procedure.
    @returns {Reference}
     */

    ProcedureRequest.prototype.orderer = function() {
      if (this.json['orderer']) {
        return new Reference(this.json['orderer']);
      }
    };


    /**
    The clinical priority associated with this order.
    @returns {Array} an array of {@link String} objects
     */

    ProcedureRequest.prototype.priority = function() {
      return this.json['priority'];
    };

    return ProcedureRequest;

  })(DomainResource);

  module.exports.ProcedureRequest = ProcedureRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],108:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ConstraintComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Profile, ProfileMappingComponent, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ProfileMappingComponent
  @exports  ProfileMappingComponent as ProfileMappingComponent
   */

  ProfileMappingComponent = (function(superClass) {
    extend(ProfileMappingComponent, superClass);

    function ProfileMappingComponent(json) {
      this.json = json;
      ProfileMappingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An Internal id that is used to identify this mapping set when specific mappings are made.
    @returns {Array} an array of {@link String} objects
     */

    ProfileMappingComponent.prototype.identity = function() {
      return this.json['identity'];
    };


    /**
    A URI that identifies the specification that this mapping is expressed to.
    @returns {Array} an array of {@link String} objects
     */

    ProfileMappingComponent.prototype.uri = function() {
      return this.json['uri'];
    };


    /**
    A name for the specification that is being mapped to.
    @returns {Array} an array of {@link String} objects
     */

    ProfileMappingComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    @returns {Array} an array of {@link String} objects
     */

    ProfileMappingComponent.prototype.comments = function() {
      return this.json['comments'];
    };

    return ProfileMappingComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConstraintComponent
  @exports  ConstraintComponent as ConstraintComponent
   */

  ConstraintComponent = (function(superClass) {
    extend(ConstraintComponent, superClass);

    function ConstraintComponent(json) {
      this.json = json;
      ConstraintComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Captures constraints on each element within the resource.
    @returns {Array} an array of {@link ElementDefinition} objects
     */

    ConstraintComponent.prototype.element = function() {
      var i, item, len, ref, results;
      if (this.json['element']) {
        ref = this.json['element'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ElementDefinition(item));
        }
        return results;
      }
    };

    return ConstraintComponent;

  })(BackboneElement);


  /**
  A Resource Profile - a statement of use of one or more FHIR Resources.  It may include constraints on Resources and Data Types, Terminology Binding Statements and Extension Definitions.
  @class Profile
  @exports Profile as Profile
   */

  Profile = (function(superClass) {
    extend(Profile, superClass);

    function Profile(json) {
      this.json = json;
      Profile.__super__.constructor.call(this, this.json);
    }


    /**
    The URL at which this profile is (or will be) published, and which is used to reference this profile in extension urls and tag values in operational FHIR systems.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.url = function() {
      return this.json['url'];
    };


    /**
    Formal identifier that is used to identify this profile when it is represented in other formats, or referenced in a specification, model, design or an instance  (should be globally unique OID, UUID, or URI), (if it's not possible to use the literal URI).
    @returns {Array} an array of {@link Identifier} objects
     */

    Profile.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The identifier that is used to identify this version of the profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A free text natural language name identifying the Profile.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the profile.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Profile.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the profile and its use.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A set of terms from external terminologies that may be used to assist with indexing and searching of templates.
    @returns {Array} an array of {@link Coding} objects
     */

    Profile.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    The status of the profile.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.status = function() {
      return this.json['status'];
    };


    /**
    This profile was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    Profile.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    The date that this version of the profile was published.
    @returns {Array} an array of {@link Date} objects
     */

    Profile.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Scope and Usage that this profile was created to meet.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    The version of the FHIR specification on which this profile is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 0.3.0 for this version.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.fhirVersion = function() {
      return this.json['fhirVersion'];
    };


    /**
    An external specification that the content is mapped to.
    @returns {Array} an array of {@link ProfileMappingComponent} objects
     */

    Profile.prototype.mapping = function() {
      var i, item, len, ref, results;
      if (this.json['mapping']) {
        ref = this.json['mapping'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ProfileMappingComponent(item));
        }
        return results;
      }
    };


    /**
    The Resource or Data type being described.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.type = function() {
      return this.json['type'];
    };


    /**
    The structure that is the base on which this set of constraints is derived from.
    @returns {Array} an array of {@link String} objects
     */

    Profile.prototype.base = function() {
      return this.json['base'];
    };


    /**
    A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base profile.
    @returns {ConstraintComponent}
     */

    Profile.prototype.snapshot = function() {
      if (this.json['snapshot']) {
        return new ConstraintComponent(this.json['snapshot']);
      }
    };


    /**
    A differential view is expressed relative to the base profile - a statement of differences that it applies.
    @returns {ConstraintComponent}
     */

    Profile.prototype.differential = function() {
      if (this.json['differential']) {
        return new ConstraintComponent(this.json['differential']);
      }
    };

    return Profile;

  })(DomainResource);

  module.exports.Profile = Profile;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],109:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Provenance, ProvenanceAgentComponent, ProvenanceEntityComponent, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ProvenanceAgentComponent
  @exports  ProvenanceAgentComponent as ProvenanceAgentComponent
   */

  ProvenanceAgentComponent = (function(superClass) {
    extend(ProvenanceAgentComponent, superClass);

    function ProvenanceAgentComponent(json) {
      this.json = json;
      ProvenanceAgentComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The role that the participant played.
    @returns {Coding}
     */

    ProvenanceAgentComponent.prototype.role = function() {
      if (this.json['role']) {
        return new Coding(this.json['role']);
      }
    };


    /**
    The type of the participant.
    @returns {Coding}
     */

    ProvenanceAgentComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    @returns {Array} an array of {@link String} objects
     */

    ProvenanceAgentComponent.prototype.reference = function() {
      return this.json['reference'];
    };


    /**
    Human-readable description of the participant.
    @returns {Array} an array of {@link String} objects
     */

    ProvenanceAgentComponent.prototype.display = function() {
      return this.json['display'];
    };

    return ProvenanceAgentComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ProvenanceEntityComponent
  @exports  ProvenanceEntityComponent as ProvenanceEntityComponent
   */

  ProvenanceEntityComponent = (function(superClass) {
    extend(ProvenanceEntityComponent, superClass);

    function ProvenanceEntityComponent(json) {
      this.json = json;
      ProvenanceEntityComponent.__super__.constructor.call(this, this.json);
    }


    /**
    How the entity was used during the activity.
    @returns {Array} an array of {@link String} objects
     */

    ProvenanceEntityComponent.prototype.role = function() {
      return this.json['role'];
    };


    /**
    The type of the entity. If the entity is a resource, then this is a resource type.
    @returns {Coding}
     */

    ProvenanceEntityComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    @returns {Array} an array of {@link String} objects
     */

    ProvenanceEntityComponent.prototype.reference = function() {
      return this.json['reference'];
    };


    /**
    Human-readable description of the entity.
    @returns {Array} an array of {@link String} objects
     */

    ProvenanceEntityComponent.prototype.display = function() {
      return this.json['display'];
    };


    /**
    The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    @returns {ProvenanceAgentComponent}
     */

    ProvenanceEntityComponent.prototype.agent = function() {
      if (this.json['agent']) {
        return new ProvenanceAgentComponent(this.json['agent']);
      }
    };

    return ProvenanceEntityComponent;

  })(BackboneElement);


  /**
  Provenance information that describes the activity that led to the creation of a set of resources. This information can be used to help determine their reliability or trace where the information in them came from. The focus of the provenance resource is record keeping, audit and traceability, and not explicit statements of clinical significance.
  @class Provenance
  @exports Provenance as Provenance
   */

  Provenance = (function(superClass) {
    extend(Provenance, superClass);

    function Provenance(json) {
      this.json = json;
      Provenance.__super__.constructor.call(this, this.json);
    }


    /**
    The Reference(s) that were generated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    @returns {Array} an array of {@link Reference} objects
     */

    Provenance.prototype.target = function() {
      var i, item, len, ref, results;
      if (this.json['target']) {
        ref = this.json['target'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The period during which the activity occurred.
    @returns {Period}
     */

    Provenance.prototype.period = function() {
      if (this.json['period']) {
        return new Period(this.json['period']);
      }
    };


    /**
    The instant of time at which the activity was recorded.
    @returns {Array} an array of {@link Date} objects
     */

    Provenance.prototype.recorded = function() {
      if (this.json['recorded']) {
        return DT.DateTime.parse(this.json['recorded']);
      }
    };


    /**
    The reason that the activity was taking place.
    @returns {CodeableConcept}
     */

    Provenance.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };


    /**
    Where the activity occurred, if relevant.
    @returns {Reference}
     */

    Provenance.prototype.location = function() {
      if (this.json['location']) {
        return new Reference(this.json['location']);
      }
    };


    /**
    Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    @returns {Array} an array of {@link String} objects
     */

    Provenance.prototype.policy = function() {
      return this.json['policy'];
    };


    /**
    An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility.
    @returns {Array} an array of {@link ProvenanceAgentComponent} objects
     */

    Provenance.prototype.agent = function() {
      var i, item, len, ref, results;
      if (this.json['agent']) {
        ref = this.json['agent'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ProvenanceAgentComponent(item));
        }
        return results;
      }
    };


    /**
    An entity used in this activity.
    @returns {Array} an array of {@link ProvenanceEntityComponent} objects
     */

    Provenance.prototype.entity = function() {
      var i, item, len, ref, results;
      if (this.json['entity']) {
        ref = this.json['entity'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ProvenanceEntityComponent(item));
        }
        return results;
      }
    };


    /**
    A digital signature on the target Reference(s). The signature should match a Provenance.agent.reference in the provenance resource. The signature is only added to support checking cryptographic integrity of the resource, and not to represent workflow and clinical aspects of the signing process, or to support non-repudiation.
    @returns {Array} an array of {@link String} objects
     */

    Provenance.prototype.integritySignature = function() {
      return this.json['integritySignature'];
    };

    return Provenance;

  })(DomainResource);

  module.exports.Provenance = Provenance;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],110:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Query, QueryResponseComponent, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class QueryResponseComponent
  @exports  QueryResponseComponent as QueryResponseComponent
   */

  QueryResponseComponent = (function(superClass) {
    extend(QueryResponseComponent, superClass);

    function QueryResponseComponent(json) {
      this.json = json;
      QueryResponseComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Links response to source query.
    @returns {Array} an array of {@link String} objects
     */

    QueryResponseComponent.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    Outcome of processing the query.
    @returns {Array} an array of {@link String} objects
     */

    QueryResponseComponent.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    Total number of matching records.
    @returns {Array} an array of {@link Number} objects
     */

    QueryResponseComponent.prototype.total = function() {
      return this.json['total'];
    };


    /**
    Parameters server used.
    @returns {Array} an array of {@link Extension} objects
     */

    QueryResponseComponent.prototype.parameter = function() {
      var i, item, len, ref, results;
      if (this.json['parameter']) {
        ref = this.json['parameter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    To get first page (if paged).
    @returns {Array} an array of {@link Extension} objects
     */

    QueryResponseComponent.prototype.first = function() {
      var i, item, len, ref, results;
      if (this.json['first']) {
        ref = this.json['first'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    To get previous page (if paged).
    @returns {Array} an array of {@link Extension} objects
     */

    QueryResponseComponent.prototype.previous = function() {
      var i, item, len, ref, results;
      if (this.json['previous']) {
        ref = this.json['previous'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    To get next page (if paged).
    @returns {Array} an array of {@link Extension} objects
     */

    QueryResponseComponent.prototype.next = function() {
      var i, item, len, ref, results;
      if (this.json['next']) {
        ref = this.json['next'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    To get last page (if paged).
    @returns {Array} an array of {@link Extension} objects
     */

    QueryResponseComponent.prototype.last = function() {
      var i, item, len, ref, results;
      if (this.json['last']) {
        ref = this.json['last'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    Resources that are the results of the search.
    @returns {Array} an array of {@link Reference} objects
     */

    QueryResponseComponent.prototype.reference = function() {
      var i, item, len, ref, results;
      if (this.json['reference']) {
        ref = this.json['reference'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return QueryResponseComponent;

  })(BackboneElement);


  /**
  A description of a query with a set of parameters.
  @class Query
  @exports Query as Query
   */

  Query = (function(superClass) {
    extend(Query, superClass);

    function Query(json) {
      this.json = json;
      Query.__super__.constructor.call(this, this.json);
    }


    /**
    Links query and its response(s).
    @returns {Array} an array of {@link String} objects
     */

    Query.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    Set of query parameters with values.
    @returns {Array} an array of {@link Extension} objects
     */

    Query.prototype.parameter = function() {
      var i, item, len, ref, results;
      if (this.json['parameter']) {
        ref = this.json['parameter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Extension(item));
        }
        return results;
      }
    };


    /**
    If this is a response to a query.
    @returns {QueryResponseComponent}
     */

    Query.prototype.response = function() {
      if (this.json['response']) {
        return new QueryResponseComponent(this.json['response']);
      }
    };

    return Query;

  })(DomainResource);

  module.exports.Query = Query;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],111:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, GroupComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, QuestionComponent, Questionnaire, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class QuestionComponent
  @exports  QuestionComponent as QuestionComponent
   */

  QuestionComponent = (function(superClass) {
    extend(QuestionComponent, superClass);

    function QuestionComponent(json) {
      this.json = json;
      QuestionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier that is unique within the questionnaire allowing linkage to the equivalent group in a [[[QuestionnaireAnswers]]] resource.
    @returns {Array} an array of {@link String} objects
     */

    QuestionComponent.prototype.linkId = function() {
      return this.json['linkId'];
    };


    /**
    Identifies a how this question is known in a particular terminology such as LOINC.
    @returns {Array} an array of {@link Coding} objects
     */

    QuestionComponent.prototype.concept = function() {
      var i, item, len, ref, results;
      if (this.json['concept']) {
        ref = this.json['concept'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Text of the question as it is shown to the user.
    @returns {Array} an array of {@link String} objects
     */

    QuestionComponent.prototype.text = function() {
      return this.json['text'];
    };


    /**
    The expected format of the answer, e.g. the type of input (string, integer) or whether a (multiple) choice is expected.
    @returns {Array} an array of {@link String} objects
     */

    QuestionComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    If true, indicates that the group must be present and have required questions within it answered.  If false, the group may be skipped when answering the questionnaire.
    @returns {Array} an array of {@link boolean} objects
     */

    QuestionComponent.prototype.required = function() {
      return this.json['required'];
    };


    /**
    Whether the group may occur multiple times in the instance, containing multiple sets of answers.
    @returns {Array} an array of {@link boolean} objects
     */

    QuestionComponent.prototype.repeats = function() {
      return this.json['repeats'];
    };


    /**
    Reference to a valueset containing the possible options.
    @returns {Reference}
     */

    QuestionComponent.prototype.options = function() {
      if (this.json['options']) {
        return new Reference(this.json['options']);
      }
    };


    /**
    Nested group, containing nested question for this question. The order of groups within the question is relevant.
    @returns {Array} an array of {@link GroupComponent} objects
     */

    QuestionComponent.prototype.group = function() {
      var i, item, len, ref, results;
      if (this.json['group']) {
        ref = this.json['group'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new GroupComponent(item));
        }
        return results;
      }
    };

    return QuestionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class GroupComponent
  @exports  GroupComponent as GroupComponent
   */

  GroupComponent = (function(superClass) {
    extend(GroupComponent, superClass);

    function GroupComponent(json) {
      this.json = json;
      GroupComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A identifier that is unique within the questionnaire allowing linkage to the equivalent group in a QuestionnaireAnswers resource.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.linkId = function() {
      return this.json['linkId'];
    };


    /**
    The human-readable name for this section of the questionnaire.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.title = function() {
      return this.json['title'];
    };


    /**
    Identifies a how this group of questions is known in a particular terminology such as LOINC.
    @returns {Array} an array of {@link Coding} objects
     */

    GroupComponent.prototype.concept = function() {
      var i, item, len, ref, results;
      if (this.json['concept']) {
        ref = this.json['concept'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    Additional text for the group, used for display purposes.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.text = function() {
      return this.json['text'];
    };


    /**
    If true, indicates that the group must be present and have required questions within it answered.  If false, the group may be skipped when answering the questionnaire.
    @returns {Array} an array of {@link boolean} objects
     */

    GroupComponent.prototype.required = function() {
      return this.json['required'];
    };


    /**
    Whether the group may occur multiple times in the instance, containing multiple sets of answers.
    @returns {Array} an array of {@link boolean} objects
     */

    GroupComponent.prototype.repeats = function() {
      return this.json['repeats'];
    };


    /**
    A sub-group within a group. The ordering of groups within this group is relevant.
    @returns {Array} an array of {@link GroupComponent} objects
     */

    GroupComponent.prototype.group = function() {
      var i, item, len, ref, results;
      if (this.json['group']) {
        ref = this.json['group'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new GroupComponent(item));
        }
        return results;
      }
    };


    /**
    Set of questions within this group. The order of questions within the group is relevant.
    @returns {Array} an array of {@link QuestionComponent} objects
     */

    GroupComponent.prototype.question = function() {
      var i, item, len, ref, results;
      if (this.json['question']) {
        ref = this.json['question'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new QuestionComponent(item));
        }
        return results;
      }
    };

    return GroupComponent;

  })(BackboneElement);


  /**
  A structured set of questions intended to guide the collection of answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the underlying questions.
  @class Questionnaire
  @exports Questionnaire as Questionnaire
   */

  Questionnaire = (function(superClass) {
    extend(Questionnaire, superClass);

    function Questionnaire(json) {
      this.json = json;
      Questionnaire.__super__.constructor.call(this, this.json);
    }


    /**
    This records identifiers associated with this question set that are defined by business processed and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    @returns {Array} an array of {@link Identifier} objects
     */

    Questionnaire.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version number assigned by the publisher for business reasons.  It may remain the same when the resource is updated.
    @returns {Array} an array of {@link String} objects
     */

    Questionnaire.prototype.version = function() {
      return this.json['version'];
    };


    /**
    The lifecycle status of the questionnaire as a whole.
    @returns {Array} an array of {@link String} objects
     */

    Questionnaire.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The date that this questionnaire was last changed.
    @returns {Array} an array of {@link Date} objects
     */

    Questionnaire.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    Organization responsible for developing and maintaining the questionnaire.
    @returns {Array} an array of {@link String} objects
     */

    Questionnaire.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    A collection of related questions (or further groupings of questions).
    @returns {GroupComponent}
     */

    Questionnaire.prototype.group = function() {
      if (this.json['group']) {
        return new GroupComponent(this.json['group']);
      }
    };

    return Questionnaire;

  })(DomainResource);

  module.exports.Questionnaire = Questionnaire;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],112:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, GroupComponent, HumanName, Identifier, Narrative, Parameters, Period, Quantity, QuestionAnswerComponent, QuestionComponent, QuestionnaireAnswers, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class QuestionAnswerComponent
  @exports  QuestionAnswerComponent as QuestionAnswerComponent
   */

  QuestionAnswerComponent = (function(superClass) {
    extend(QuestionAnswerComponent, superClass);

    function QuestionAnswerComponent(json) {
      this.json = json;
      QuestionAnswerComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link boolean} objects
     */

    QuestionAnswerComponent.prototype.valueBoolean = function() {
      return this.json['valueBoolean'];
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link Number} objects
     */

    QuestionAnswerComponent.prototype.valueDecimal = function() {
      return this.json['valueDecimal'];
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link Number} objects
     */

    QuestionAnswerComponent.prototype.valueInteger = function() {
      return this.json['valueInteger'];
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link Date} objects
     */

    QuestionAnswerComponent.prototype.valueDate = function() {
      if (this.json['valueDate']) {
        return DT.DateTime.parse(this.json['valueDate']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link Date} objects
     */

    QuestionAnswerComponent.prototype.valueDateTime = function() {
      if (this.json['valueDateTime']) {
        return DT.DateTime.parse(this.json['valueDateTime']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link Date} objects
     */

    QuestionAnswerComponent.prototype.valueInstant = function() {
      if (this.json['valueInstant']) {
        return DT.DateTime.parse(this.json['valueInstant']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {time}
     */

    QuestionAnswerComponent.prototype.valueTime = function() {
      if (this.json['valueTime']) {
        return new time(this.json['valueTime']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Array} an array of {@link String} objects
     */

    QuestionAnswerComponent.prototype.valueString = function() {
      return this.json['valueString'];
    };


    /**
    Single-valued answer to the question.
    @returns {Attachment}
     */

    QuestionAnswerComponent.prototype.valueAttachment = function() {
      if (this.json['valueAttachment']) {
        return new Attachment(this.json['valueAttachment']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Coding}
     */

    QuestionAnswerComponent.prototype.valueCoding = function() {
      if (this.json['valueCoding']) {
        return new Coding(this.json['valueCoding']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Quantity}
     */

    QuestionAnswerComponent.prototype.valueQuantity = function() {
      if (this.json['valueQuantity']) {
        return new Quantity(this.json['valueQuantity']);
      }
    };


    /**
    Single-valued answer to the question.
    @returns {Reference}
     */

    QuestionAnswerComponent.prototype.valueReference = function() {
      if (this.json['valueReference']) {
        return new Reference(this.json['valueReference']);
      }
    };

    return QuestionAnswerComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class QuestionComponent
  @exports  QuestionComponent as QuestionComponent
   */

  QuestionComponent = (function(superClass) {
    extend(QuestionComponent, superClass);

    function QuestionComponent(json) {
      this.json = json;
      QuestionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the question from the Questionnaire that corresponds to this question in the QuestionnaireAnswers resource.
    @returns {Array} an array of {@link String} objects
     */

    QuestionComponent.prototype.linkId = function() {
      return this.json['linkId'];
    };


    /**
    Text of the question as it is shown to the user.
    @returns {Array} an array of {@link String} objects
     */

    QuestionComponent.prototype.text = function() {
      return this.json['text'];
    };


    /**
    The respondent's answer(s) to the question.
    @returns {Array} an array of {@link QuestionAnswerComponent} objects
     */

    QuestionComponent.prototype.answer = function() {
      var i, item, len, ref, results;
      if (this.json['answer']) {
        ref = this.json['answer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new QuestionAnswerComponent(item));
        }
        return results;
      }
    };


    /**
    Nested group, containing nested question for this question. The order of groups within the question is relevant.
    @returns {Array} an array of {@link GroupComponent} objects
     */

    QuestionComponent.prototype.group = function() {
      var i, item, len, ref, results;
      if (this.json['group']) {
        ref = this.json['group'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new GroupComponent(item));
        }
        return results;
      }
    };

    return QuestionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class GroupComponent
  @exports  GroupComponent as GroupComponent
   */

  GroupComponent = (function(superClass) {
    extend(GroupComponent, superClass);

    function GroupComponent(json) {
      this.json = json;
      GroupComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the group from the Questionnaire that corresponds to this group in the QuestionnaireAnswers resource.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.linkId = function() {
      return this.json['linkId'];
    };


    /**
    Text that is displayed above the contents of the group.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.title = function() {
      return this.json['title'];
    };


    /**
    Additional text for the group, used for display purposes.
    @returns {Array} an array of {@link String} objects
     */

    GroupComponent.prototype.text = function() {
      return this.json['text'];
    };


    /**
    More specific subject this section's answers are about, details the subject given in QuestionnaireAnswers.
    @returns {Reference}
     */

    GroupComponent.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    A sub-group within a group. The ordering of groups within this group is relevant.
    @returns {Array} an array of {@link GroupComponent} objects
     */

    GroupComponent.prototype.group = function() {
      var i, item, len, ref, results;
      if (this.json['group']) {
        ref = this.json['group'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new GroupComponent(item));
        }
        return results;
      }
    };


    /**
    Set of questions within this group. The order of questions within the group is relevant.
    @returns {Array} an array of {@link QuestionComponent} objects
     */

    GroupComponent.prototype.question = function() {
      var i, item, len, ref, results;
      if (this.json['question']) {
        ref = this.json['question'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new QuestionComponent(item));
        }
        return results;
      }
    };

    return GroupComponent;

  })(BackboneElement);


  /**
  A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the underlying questions.
  @class QuestionnaireAnswers
  @exports QuestionnaireAnswers as QuestionnaireAnswers
   */

  QuestionnaireAnswers = (function(superClass) {
    extend(QuestionnaireAnswers, superClass);

    function QuestionnaireAnswers(json) {
      this.json = json;
      QuestionnaireAnswers.__super__.constructor.call(this, this.json);
    }


    /**
    A business identifier assigned to a particular completed (or partially completed) questionnaire.
    @returns {Identifier}
     */

    QuestionnaireAnswers.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Indicates the Questionnaire resource that defines the form for which answers are being provided.
    @returns {Reference}
     */

    QuestionnaireAnswers.prototype.questionnaire = function() {
      if (this.json['questionnaire']) {
        return new Reference(this.json['questionnaire']);
      }
    };


    /**
    The lifecycle status of the questionnaire answers as a whole.
    @returns {Array} an array of {@link String} objects
     */

    QuestionnaireAnswers.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The subject of the questionnaire answers.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information.
    @returns {Reference}
     */

    QuestionnaireAnswers.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Person who received the answers to the questions in the QuestionnaireAnswers and recorded them in the system.
    @returns {Reference}
     */

    QuestionnaireAnswers.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    The date and/or time that this version of the questionnaire answers was authored.
    @returns {Array} an array of {@link Date} objects
     */

    QuestionnaireAnswers.prototype.authored = function() {
      if (this.json['authored']) {
        return DT.DateTime.parse(this.json['authored']);
      }
    };


    /**
    The person who answered the questions about the subject. Only used when this is not the subject him/herself.
    @returns {Reference}
     */

    QuestionnaireAnswers.prototype.source = function() {
      if (this.json['source']) {
        return new Reference(this.json['source']);
      }
    };


    /**
    Encounter during which this set of questionnaire answers were collected. When there were multiple encounters, this is the one considered most relevant to the context of the answers.
    @returns {Reference}
     */

    QuestionnaireAnswers.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    A group of questions to a possibly similarly grouped set of questions in the questionnaire answers.
    @returns {GroupComponent}
     */

    QuestionnaireAnswers.prototype.group = function() {
      if (this.json['group']) {
        return new GroupComponent(this.json['group']);
      }
    };

    return QuestionnaireAnswers;

  })(DomainResource);

  module.exports.QuestionnaireAnswers = QuestionnaireAnswers;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],113:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, ItemsComponent, Narrative, Parameters, Period, Quantity, Range, Ratio, Readjudicate, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ItemsComponent
  @exports  ItemsComponent as ItemsComponent
   */

  ItemsComponent = (function(superClass) {
    extend(ItemsComponent, superClass);

    function ItemsComponent(json) {
      this.json = json;
      ItemsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line number.
    @returns {Array} an array of {@link Number} objects
     */

    ItemsComponent.prototype.sequenceLinkId = function() {
      return this.json['sequenceLinkId'];
    };

    return ItemsComponent;

  })(BackboneElement);


  /**
  This resource provides the request and line items details for the claim which is to be readjudicated.
  @class Readjudicate
  @exports Readjudicate as Readjudicate
   */

  Readjudicate = (function(superClass) {
    extend(Readjudicate, superClass);

    function Readjudicate(json) {
      this.json = json;
      Readjudicate.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    Readjudicate.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    Readjudicate.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    Readjudicate.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    Readjudicate.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    Readjudicate.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Readjudicate.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Readjudicate.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Reference of resource to reverse.
    @returns {Reference}
     */

    Readjudicate.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Reference of response to resource to reverse.
    @returns {Reference}
     */

    Readjudicate.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };


    /**
    A reference to supply which authenticated the process.
    @returns {Array} an array of {@link String} objects
     */

    Readjudicate.prototype.reference = function() {
      return this.json['reference'];
    };


    /**
    List of top level items to be readjudicated, if none specified then the entire submission is readjudicated.
    @returns {Array} an array of {@link ItemsComponent} objects
     */

    Readjudicate.prototype.item = function() {
      var i, item, len, ref, results;
      if (this.json['item']) {
        ref = this.json['item'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ItemsComponent(item));
        }
        return results;
      }
    };

    return Readjudicate;

  })(DomainResource);

  module.exports.Readjudicate = Readjudicate;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],114:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, ReferralRequest, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organisation.
  @class ReferralRequest
  @exports ReferralRequest as ReferralRequest
   */

  ReferralRequest = (function(superClass) {
    extend(ReferralRequest, superClass);

    function ReferralRequest(json) {
      this.json = json;
      ReferralRequest.__super__.constructor.call(this, this.json);
    }


    /**
    The workflow status of the referral or transfer of care request.
    @returns {Array} an array of {@link String} objects
     */

    ReferralRequest.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Business Id that uniquely identifies the referral/care transfer request instance.
    @returns {Array} an array of {@link Identifier} objects
     */

    ReferralRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    An indication of the type of referral (or where applicable the type of transfer of care) request.
    @returns {CodeableConcept}
     */

    ReferralRequest.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Indication of the clinical domain or discipline to which the referral or transfer of care request is sent.
    @returns {CodeableConcept}
     */

    ReferralRequest.prototype.specialty = function() {
      if (this.json['specialty']) {
        return new CodeableConcept(this.json['specialty']);
      }
    };


    /**
    An indication of the urgency of referral (or where applicable the type of transfer of care) request.
    @returns {CodeableConcept}
     */

    ReferralRequest.prototype.priority = function() {
      if (this.json['priority']) {
        return new CodeableConcept(this.json['priority']);
      }
    };


    /**
    The patient who is the subject of a referral or transfer of care request.
    @returns {Reference}
     */

    ReferralRequest.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The healthcare provider or provider organization who/which initaited the referral/transfer of care request. Can also be  Patient (a self referral).
    @returns {Reference}
     */

    ReferralRequest.prototype.requester = function() {
      if (this.json['requester']) {
        return new Reference(this.json['requester']);
      }
    };


    /**
    The healthcare provider(s) or provider organization(s) who/which is to receive the referral/transfer of care request.
    @returns {Array} an array of {@link Reference} objects
     */

    ReferralRequest.prototype.recipient = function() {
      var i, item, len, ref, results;
      if (this.json['recipient']) {
        ref = this.json['recipient'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The encounter at which the request for referral or transfer of care is initiated.
    @returns {Reference}
     */

    ReferralRequest.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Date/DateTime the request for referral or transfer of care is sent by the author.
    @returns {Array} an array of {@link Date} objects
     */

    ReferralRequest.prototype.dateSent = function() {
      if (this.json['dateSent']) {
        return DT.DateTime.parse(this.json['dateSent']);
      }
    };


    /**
    Description of clinical condition indicating why referral/transfer of care is requested.
    @returns {CodeableConcept}
     */

    ReferralRequest.prototype.reason = function() {
      if (this.json['reason']) {
        return new CodeableConcept(this.json['reason']);
      }
    };


    /**
    The reason gives a short description of why the referral is being made, the description expands on this to support a more complete clinical summary.
    @returns {Array} an array of {@link String} objects
     */

    ReferralRequest.prototype.description = function() {
      return this.json['description'];
    };


    /**
    The service(s) that is/are requested to be provided to the patient.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    ReferralRequest.prototype.serviceRequested = function() {
      var i, item, len, ref, results;
      if (this.json['serviceRequested']) {
        ref = this.json['serviceRequested'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Any additional (administrative, financial or clinical) information required to support request for referral or transfer of care.
    @returns {Array} an array of {@link Reference} objects
     */

    ReferralRequest.prototype.supportingInformation = function() {
      var i, item, len, ref, results;
      if (this.json['supportingInformation']) {
        ref = this.json['supportingInformation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The period of time within which the services identified in the referral/transfer of care is specified or required to occur.
    @returns {Period}
     */

    ReferralRequest.prototype.fulfillmentTime = function() {
      if (this.json['fulfillmentTime']) {
        return new Period(this.json['fulfillmentTime']);
      }
    };

    return ReferralRequest;

  })(DomainResource);

  module.exports.ReferralRequest = ReferralRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],115:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, RelatedPerson, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
  @class RelatedPerson
  @exports RelatedPerson as RelatedPerson
   */

  RelatedPerson = (function(superClass) {
    extend(RelatedPerson, superClass);

    function RelatedPerson(json) {
      this.json = json;
      RelatedPerson.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier for a person within a particular scope.
    @returns {Array} an array of {@link Identifier} objects
     */

    RelatedPerson.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The patient this person is related to.
    @returns {Reference}
     */

    RelatedPerson.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    The nature of the relationship between a patient and the related person.
    @returns {CodeableConcept}
     */

    RelatedPerson.prototype.relationship = function() {
      if (this.json['relationship']) {
        return new CodeableConcept(this.json['relationship']);
      }
    };


    /**
    A name associated with the person.
    @returns {HumanName}
     */

    RelatedPerson.prototype.name = function() {
      if (this.json['name']) {
        return new HumanName(this.json['name']);
      }
    };


    /**
    A contact detail for the person, e.g. a telephone number or an email address.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    RelatedPerson.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    @returns {Array} an array of {@link String} objects
     */

    RelatedPerson.prototype.gender = function() {
      return this.json['gender'];
    };


    /**
    Address where the related person can be contacted or visited.
    @returns {Address}
     */

    RelatedPerson.prototype.address = function() {
      if (this.json['address']) {
        return new Address(this.json['address']);
      }
    };


    /**
    Image of the person.
    @returns {Array} an array of {@link Attachment} objects
     */

    RelatedPerson.prototype.photo = function() {
      var i, item, len, ref, results;
      if (this.json['photo']) {
        ref = this.json['photo'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Attachment(item));
        }
        return results;
      }
    };

    return RelatedPerson;

  })(DomainResource);

  module.exports.RelatedPerson = RelatedPerson;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],116:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, PayeeComponent, Period, Quantity, Range, Ratio, Reference, Resource, Reversal, ReversalCoverageComponent, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class PayeeComponent
  @exports  PayeeComponent as PayeeComponent
   */

  PayeeComponent = (function(superClass) {
    extend(PayeeComponent, superClass);

    function PayeeComponent(json) {
      this.json = json;
      PayeeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Party to be reimbursed: Subscriber, provider, other.
    @returns {Coding}
     */

    PayeeComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The provider who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The person other than the subscriber who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    @returns {Reference}
     */

    PayeeComponent.prototype.person = function() {
      if (this.json['person']) {
        return new Reference(this.json['person']);
      }
    };

    return PayeeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ReversalCoverageComponent
  @exports  ReversalCoverageComponent as ReversalCoverageComponent
   */

  ReversalCoverageComponent = (function(superClass) {
    extend(ReversalCoverageComponent, superClass);

    function ReversalCoverageComponent(json) {
      this.json = json;
      ReversalCoverageComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A service line item.
    @returns {Array} an array of {@link Number} objects
     */

    ReversalCoverageComponent.prototype.sequence = function() {
      return this.json['sequence'];
    };


    /**
    The instance number of the Coverage which is the focus for adjudication, that is the Coverage to which the claim is to be adjudicated against.
    @returns {Array} an array of {@link boolean} objects
     */

    ReversalCoverageComponent.prototype.focal = function() {
      return this.json['focal'];
    };


    /**
    Reference to the program or plan identification, underwriter or payor.
    @returns {Reference}
     */

    ReversalCoverageComponent.prototype.coverage = function() {
      if (this.json['coverage']) {
        return new Reference(this.json['coverage']);
      }
    };


    /**
    The contract number of a business agreement which describes the terms and conditions.
    @returns {Array} an array of {@link String} objects
     */

    ReversalCoverageComponent.prototype.businessArrangement = function() {
      return this.json['businessArrangement'];
    };


    /**
    The relationship of the patient to the subscriber.
    @returns {Coding}
     */

    ReversalCoverageComponent.prototype.relationship = function() {
      if (this.json['relationship']) {
        return new Coding(this.json['relationship']);
      }
    };

    return ReversalCoverageComponent;

  })(BackboneElement);


  /**
  This resource provides the request and response details for the request for which all actions are to be reversed or terminated.
  @class Reversal
  @exports Reversal as Reversal
   */

  Reversal = (function(superClass) {
    extend(Reversal, superClass);

    function Reversal(json) {
      this.json = json;
      Reversal.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    Reversal.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    Reversal.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    Reversal.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    Reversal.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    Reversal.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Reversal.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    Reversal.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Reference of resource to reverse.
    @returns {Reference}
     */

    Reversal.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Reference of response to resource to reverse.
    @returns {Reference}
     */

    Reversal.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };


    /**
    Payee information suypplied for matching purposes.
    @returns {PayeeComponent}
     */

    Reversal.prototype.payee = function() {
      if (this.json['payee']) {
        return new PayeeComponent(this.json['payee']);
      }
    };


    /**
    Financial instrument by which payment information for health care.
    @returns {ReversalCoverageComponent}
     */

    Reversal.prototype.coverage = function() {
      if (this.json['coverage']) {
        return new ReversalCoverageComponent(this.json['coverage']);
      }
    };


    /**
    If true remove all history excluding audit.
    @returns {Array} an array of {@link boolean} objects
     */

    Reversal.prototype.nullify = function() {
      return this.json['nullify'];
    };

    return Reversal;

  })(DomainResource);

  module.exports.Reversal = Reversal;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],117:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, RiskAssessment, RiskAssessmentPredictionComponent, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class RiskAssessmentPredictionComponent
  @exports  RiskAssessmentPredictionComponent as RiskAssessmentPredictionComponent
   */

  RiskAssessmentPredictionComponent = (function(superClass) {
    extend(RiskAssessmentPredictionComponent, superClass);

    function RiskAssessmentPredictionComponent(json) {
      this.json = json;
      RiskAssessmentPredictionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
    @returns {CodeableConcept}
     */

    RiskAssessmentPredictionComponent.prototype.outcome = function() {
      if (this.json['outcome']) {
        return new CodeableConcept(this.json['outcome']);
      }
    };


    /**
    How likely is the outcome (in the specified timeframe).
    @returns {Array} an array of {@link Number} objects
     */

    RiskAssessmentPredictionComponent.prototype.probabilityDecimal = function() {
      return this.json['probabilityDecimal'];
    };


    /**
    How likely is the outcome (in the specified timeframe).
    @returns {Range}
     */

    RiskAssessmentPredictionComponent.prototype.probabilityRange = function() {
      if (this.json['probabilityRange']) {
        return new Range(this.json['probabilityRange']);
      }
    };


    /**
    How likely is the outcome (in the specified timeframe).
    @returns {CodeableConcept}
     */

    RiskAssessmentPredictionComponent.prototype.probabilityCodeableConcept = function() {
      if (this.json['probabilityCodeableConcept']) {
        return new CodeableConcept(this.json['probabilityCodeableConcept']);
      }
    };


    /**
    Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    @returns {Array} an array of {@link Number} objects
     */

    RiskAssessmentPredictionComponent.prototype.relativeRisk = function() {
      return this.json['relativeRisk'];
    };


    /**
    Indicates the period of time or age range of the subject to which the specified probability applies.
    @returns {Period}
     */

    RiskAssessmentPredictionComponent.prototype.whenPeriod = function() {
      if (this.json['whenPeriod']) {
        return new Period(this.json['whenPeriod']);
      }
    };


    /**
    Indicates the period of time or age range of the subject to which the specified probability applies.
    @returns {Range}
     */

    RiskAssessmentPredictionComponent.prototype.whenRange = function() {
      if (this.json['whenRange']) {
        return new Range(this.json['whenRange']);
      }
    };


    /**
    Additional information explaining the basis for the prediction.
    @returns {Array} an array of {@link String} objects
     */

    RiskAssessmentPredictionComponent.prototype.rationale = function() {
      return this.json['rationale'];
    };

    return RiskAssessmentPredictionComponent;

  })(BackboneElement);


  /**
  An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
  @class RiskAssessment
  @exports RiskAssessment as RiskAssessment
   */

  RiskAssessment = (function(superClass) {
    extend(RiskAssessment, superClass);

    function RiskAssessment(json) {
      this.json = json;
      RiskAssessment.__super__.constructor.call(this, this.json);
    }


    /**
    The patient or group the risk assessment applies to.
    @returns {Reference}
     */

    RiskAssessment.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The date (and possibly time) the risk assessment was performed.
    @returns {Array} an array of {@link Date} objects
     */

    RiskAssessment.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
    @returns {Reference}
     */

    RiskAssessment.prototype.condition = function() {
      if (this.json['condition']) {
        return new Reference(this.json['condition']);
      }
    };


    /**
    The provider or software application that performed the assessment.
    @returns {Reference}
     */

    RiskAssessment.prototype.performer = function() {
      if (this.json['performer']) {
        return new Reference(this.json['performer']);
      }
    };


    /**
    Business identifier assigned to the risk assessment.
    @returns {Identifier}
     */

    RiskAssessment.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The algorithm, processs or mechanism used to evaluate the risk.
    @returns {CodeableConcept}
     */

    RiskAssessment.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    Indicates the source data considered as part of the assessment (FamilyHistory, Observations, Procedures, Conditions, etc.).
    @returns {Array} an array of {@link Reference} objects
     */

    RiskAssessment.prototype.basis = function() {
      var i, item, len, ref, results;
      if (this.json['basis']) {
        ref = this.json['basis'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    Describes the expected outcome for the subject.
    @returns {Array} an array of {@link RiskAssessmentPredictionComponent} objects
     */

    RiskAssessment.prototype.prediction = function() {
      var i, item, len, ref, results;
      if (this.json['prediction']) {
        ref = this.json['prediction'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new RiskAssessmentPredictionComponent(item));
        }
        return results;
      }
    };


    /**
    A description of the steps that might be taken to reduce the identified risk(s).
    @returns {Array} an array of {@link String} objects
     */

    RiskAssessment.prototype.mitigation = function() {
      return this.json['mitigation'];
    };

    return RiskAssessment;

  })(DomainResource);

  module.exports.RiskAssessment = RiskAssessment;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],118:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SearchParameter, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  A Search Parameter that defines a named search item that can be used to search/filter on a resource.
  @class SearchParameter
  @exports SearchParameter as SearchParameter
   */

  SearchParameter = (function(superClass) {
    extend(SearchParameter, superClass);

    function SearchParameter(json) {
      this.json = json;
      SearchParameter.__super__.constructor.call(this, this.json);
    }


    /**
    The URL at which this search parameter is (or will be) published, and which is used to reference this profile in conformance statements.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.url = function() {
      return this.json['url'];
    };


    /**
    The name of the standard or custom search parameter.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the search parameter.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    SearchParameter.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    The Scope and Usage that this search parameter was created to meet.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    The base resource type that this search parameter refers to.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.base = function() {
      return this.json['base'];
    };


    /**
    The type of value a search parameter refers to, and how the content is interpreted.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.type = function() {
      return this.json['type'];
    };


    /**
    A description of the search parameters and how it used.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.description = function() {
      return this.json['description'];
    };


    /**
    An XPath expression that returns a set of elements for the search parameter.
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.xpath = function() {
      return this.json['xpath'];
    };


    /**
    Types of resource (if a resource is referenced).
    @returns {Array} an array of {@link String} objects
     */

    SearchParameter.prototype.target = function() {
      return this.json['target'];
    };

    return SearchParameter;

  })(DomainResource);

  module.exports.SearchParameter = SearchParameter;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],119:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SecurityEvent, SecurityEventEventComponent, SecurityEventObjectComponent, SecurityEventObjectDetailComponent, SecurityEventParticipantComponent, SecurityEventParticipantNetworkComponent, SecurityEventSourceComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SecurityEventEventComponent
  @exports  SecurityEventEventComponent as SecurityEventEventComponent
   */

  SecurityEventEventComponent = (function(superClass) {
    extend(SecurityEventEventComponent, superClass);

    function SecurityEventEventComponent(json) {
      this.json = json;
      SecurityEventEventComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier for a family of the event.
    @returns {CodeableConcept}
     */

    SecurityEventEventComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Identifier for the category of event.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    SecurityEventEventComponent.prototype.subtype = function() {
      var i, item, len, ref, results;
      if (this.json['subtype']) {
        ref = this.json['subtype'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Indicator for type of action performed during the event that generated the audit.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventEventComponent.prototype.action = function() {
      return this.json['action'];
    };


    /**
    The time when the event occurred on the source.
    @returns {Array} an array of {@link Date} objects
     */

    SecurityEventEventComponent.prototype.dateTime = function() {
      if (this.json['dateTime']) {
        return DT.DateTime.parse(this.json['dateTime']);
      }
    };


    /**
    Indicates whether the event succeeded or failed.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventEventComponent.prototype.outcome = function() {
      return this.json['outcome'];
    };


    /**
    A free text description of the outcome of the event.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventEventComponent.prototype.outcomeDesc = function() {
      return this.json['outcomeDesc'];
    };

    return SecurityEventEventComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SecurityEventParticipantNetworkComponent
  @exports  SecurityEventParticipantNetworkComponent as SecurityEventParticipantNetworkComponent
   */

  SecurityEventParticipantNetworkComponent = (function(superClass) {
    extend(SecurityEventParticipantNetworkComponent, superClass);

    function SecurityEventParticipantNetworkComponent(json) {
      this.json = json;
      SecurityEventParticipantNetworkComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier for the network access point of the user device for the audit event.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventParticipantNetworkComponent.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    An identifier for the type of network access point that originated the audit event.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventParticipantNetworkComponent.prototype.type = function() {
      return this.json['type'];
    };

    return SecurityEventParticipantNetworkComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SecurityEventParticipantComponent
  @exports  SecurityEventParticipantComponent as SecurityEventParticipantComponent
   */

  SecurityEventParticipantComponent = (function(superClass) {
    extend(SecurityEventParticipantComponent, superClass);

    function SecurityEventParticipantComponent(json) {
      this.json = json;
      SecurityEventParticipantComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Specification of the role(s) the user plays when performing the event. Usually the codes used in this element are local codes defined by the role-based access control security system used in the local context.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    SecurityEventParticipantComponent.prototype.role = function() {
      var i, item, len, ref, results;
      if (this.json['role']) {
        ref = this.json['role'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    Direct reference to a resource that identifies the participant.
    @returns {Reference}
     */

    SecurityEventParticipantComponent.prototype.reference = function() {
      if (this.json['reference']) {
        return new Reference(this.json['reference']);
      }
    };


    /**
    Unique identifier for the user actively participating in the event.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventParticipantComponent.prototype.userId = function() {
      return this.json['userId'];
    };


    /**
    Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventParticipantComponent.prototype.altId = function() {
      return this.json['altId'];
    };


    /**
    Human-meaningful name for the user.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventParticipantComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    @returns {Array} an array of {@link boolean} objects
     */

    SecurityEventParticipantComponent.prototype.requestor = function() {
      return this.json['requestor'];
    };


    /**
    Type of media involved. Used when the event is about exporting/importing onto media.
    @returns {Coding}
     */

    SecurityEventParticipantComponent.prototype.media = function() {
      if (this.json['media']) {
        return new Coding(this.json['media']);
      }
    };


    /**
    Logical network location for application activity, if the activity has a network location.
    @returns {SecurityEventParticipantNetworkComponent}
     */

    SecurityEventParticipantComponent.prototype.network = function() {
      if (this.json['network']) {
        return new SecurityEventParticipantNetworkComponent(this.json['network']);
      }
    };

    return SecurityEventParticipantComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SecurityEventSourceComponent
  @exports  SecurityEventSourceComponent as SecurityEventSourceComponent
   */

  SecurityEventSourceComponent = (function(superClass) {
    extend(SecurityEventSourceComponent, superClass);

    function SecurityEventSourceComponent(json) {
      this.json = json;
      SecurityEventSourceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Logical source location within the healthcare enterprise network.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventSourceComponent.prototype.site = function() {
      return this.json['site'];
    };


    /**
    Identifier of the source where the event originated.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventSourceComponent.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    Code specifying the type of source where event originated.
    @returns {Array} an array of {@link Coding} objects
     */

    SecurityEventSourceComponent.prototype.type = function() {
      var i, item, len, ref, results;
      if (this.json['type']) {
        ref = this.json['type'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };

    return SecurityEventSourceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SecurityEventObjectDetailComponent
  @exports  SecurityEventObjectDetailComponent as SecurityEventObjectDetailComponent
   */

  SecurityEventObjectDetailComponent = (function(superClass) {
    extend(SecurityEventObjectDetailComponent, superClass);

    function SecurityEventObjectDetailComponent(json) {
      this.json = json;
      SecurityEventObjectDetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Name of the property.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectDetailComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Property value.
    @returns {Array} an array of {@link } objects
     */

    SecurityEventObjectDetailComponent.prototype.value = function() {
      return this.json['value'];
    };

    return SecurityEventObjectDetailComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SecurityEventObjectComponent
  @exports  SecurityEventObjectComponent as SecurityEventObjectComponent
   */

  SecurityEventObjectComponent = (function(superClass) {
    extend(SecurityEventObjectComponent, superClass);

    function SecurityEventObjectComponent(json) {
      this.json = json;
      SecurityEventObjectComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies a specific instance of the participant object. The reference should always be version specific.
    @returns {Identifier}
     */

    SecurityEventObjectComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Identifies a specific instance of the participant object. The reference should always be version specific.
    @returns {Reference}
     */

    SecurityEventObjectComponent.prototype.reference = function() {
      if (this.json['reference']) {
        return new Reference(this.json['reference']);
      }
    };


    /**
    Object type being audited.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Code representing the functional application role of Participant Object being audited.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectComponent.prototype.role = function() {
      return this.json['role'];
    };


    /**
    Identifier for the data life-cycle stage for the participant object.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectComponent.prototype.lifecycle = function() {
      return this.json['lifecycle'];
    };


    /**
    Denotes policy-defined sensitivity for the Participant Object ID such as VIP, HIV status, mental health status or similar topics.
    @returns {CodeableConcept}
     */

    SecurityEventObjectComponent.prototype.sensitivity = function() {
      if (this.json['sensitivity']) {
        return new CodeableConcept(this.json['sensitivity']);
      }
    };


    /**
    An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Text that describes the object in more detail.
    @returns {Array} an array of {@link String} objects
     */

    SecurityEventObjectComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    The actual query for a query-type participant object.
    @returns {Array} an array of {@link } objects
     */

    SecurityEventObjectComponent.prototype.query = function() {
      return this.json['query'];
    };


    /**
    Additional Information about the Object.
    @returns {Array} an array of {@link SecurityEventObjectDetailComponent} objects
     */

    SecurityEventObjectComponent.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SecurityEventObjectDetailComponent(item));
        }
        return results;
      }
    };

    return SecurityEventObjectComponent;

  })(BackboneElement);


  /**
  A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
  @class SecurityEvent
  @exports SecurityEvent as SecurityEvent
   */

  SecurityEvent = (function(superClass) {
    extend(SecurityEvent, superClass);

    function SecurityEvent(json) {
      this.json = json;
      SecurityEvent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifies the name, action type, time, and disposition of the audited event.
    @returns {SecurityEventEventComponent}
     */

    SecurityEvent.prototype.event = function() {
      if (this.json['event']) {
        return new SecurityEventEventComponent(this.json['event']);
      }
    };


    /**
    A person, a hardware device or software process.
    @returns {Array} an array of {@link SecurityEventParticipantComponent} objects
     */

    SecurityEvent.prototype.participant = function() {
      var i, item, len, ref, results;
      if (this.json['participant']) {
        ref = this.json['participant'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SecurityEventParticipantComponent(item));
        }
        return results;
      }
    };


    /**
    Application systems and processes.
    @returns {SecurityEventSourceComponent}
     */

    SecurityEvent.prototype.source = function() {
      if (this.json['source']) {
        return new SecurityEventSourceComponent(this.json['source']);
      }
    };


    /**
    Specific instances of data or objects that have been accessed.
    @returns {Array} an array of {@link SecurityEventObjectComponent} objects
     */

    SecurityEvent.prototype.object = function() {
      var i, item, len, ref, results;
      if (this.json['object']) {
        ref = this.json['object'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SecurityEventObjectComponent(item));
        }
        return results;
      }
    };

    return SecurityEvent;

  })(DomainResource);

  module.exports.SecurityEvent = SecurityEvent;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],120:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Slot, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  (informative) A slot of time on a schedule that may be available for booking appointments.
  @class Slot
  @exports Slot as Slot
   */

  Slot = (function(superClass) {
    extend(Slot, superClass);

    function Slot(json) {
      this.json = json;
      Slot.__super__.constructor.call(this, this.json);
    }


    /**
    External Ids for this item.
    @returns {Array} an array of {@link Identifier} objects
     */

    Slot.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the availability resource.
    @returns {CodeableConcept}
     */

    Slot.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The availability resource that this slot defines an interval of status information.
    @returns {Reference}
     */

    Slot.prototype.availability = function() {
      if (this.json['availability']) {
        return new Reference(this.json['availability']);
      }
    };


    /**
    BUSY | FREE | BUSY-UNAVAILABLE | BUSY-TENTATIVE.
    @returns {Array} an array of {@link String} objects
     */

    Slot.prototype.freeBusyType = function() {
      return this.json['freeBusyType'];
    };


    /**
    Date/Time that the slot is to begin.
    @returns {Array} an array of {@link Date} objects
     */

    Slot.prototype.start = function() {
      if (this.json['start']) {
        return DT.DateTime.parse(this.json['start']);
      }
    };


    /**
    Date/Time that the slot is to conclude.
    @returns {Array} an array of {@link Date} objects
     */

    Slot.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };


    /**
    This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    @returns {Array} an array of {@link boolean} objects
     */

    Slot.prototype.overbooked = function() {
      return this.json['overbooked'];
    };


    /**
    Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    @returns {Array} an array of {@link String} objects
     */

    Slot.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    When this slot was created, or last revised.
    @returns {Array} an array of {@link Date} objects
     */

    Slot.prototype.lastModified = function() {
      if (this.json['lastModified']) {
        return DT.DateTime.parse(this.json['lastModified']);
      }
    };

    return Slot;

  })(DomainResource);

  module.exports.Slot = Slot;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],121:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Specimen, SpecimenCollectionComponent, SpecimenContainerComponent, SpecimenSourceComponent, SpecimenTreatmentComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SpecimenSourceComponent
  @exports  SpecimenSourceComponent as SpecimenSourceComponent
   */

  SpecimenSourceComponent = (function(superClass) {
    extend(SpecimenSourceComponent, superClass);

    function SpecimenSourceComponent(json) {
      this.json = json;
      SpecimenSourceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Whether this relationship is to a parent or to a child.
    @returns {Array} an array of {@link String} objects
     */

    SpecimenSourceComponent.prototype.relationship = function() {
      return this.json['relationship'];
    };


    /**
    The specimen resource that is the target of this relationship.
    @returns {Array} an array of {@link Reference} objects
     */

    SpecimenSourceComponent.prototype.target = function() {
      var i, item, len, ref, results;
      if (this.json['target']) {
        ref = this.json['target'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return SpecimenSourceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SpecimenCollectionComponent
  @exports  SpecimenCollectionComponent as SpecimenCollectionComponent
   */

  SpecimenCollectionComponent = (function(superClass) {
    extend(SpecimenCollectionComponent, superClass);

    function SpecimenCollectionComponent(json) {
      this.json = json;
      SpecimenCollectionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Person who collected the specimen.
    @returns {Reference}
     */

    SpecimenCollectionComponent.prototype.collector = function() {
      if (this.json['collector']) {
        return new Reference(this.json['collector']);
      }
    };


    /**
    To communicate any details or issues encountered during the specimen collection procedure.
    @returns {Array} an array of {@link String} objects
     */

    SpecimenCollectionComponent.prototype.comment = function() {
      return this.json['comment'];
    };


    /**
    Time when specimen was collected from subject - the physiologically relevant time.
    @returns {Array} an array of {@link Date} objects
     */

    SpecimenCollectionComponent.prototype.collectedDateTime = function() {
      if (this.json['collectedDateTime']) {
        return DT.DateTime.parse(this.json['collectedDateTime']);
      }
    };


    /**
    Time when specimen was collected from subject - the physiologically relevant time.
    @returns {Period}
     */

    SpecimenCollectionComponent.prototype.collectedPeriod = function() {
      if (this.json['collectedPeriod']) {
        return new Period(this.json['collectedPeriod']);
      }
    };


    /**
    The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    @returns {Quantity}
     */

    SpecimenCollectionComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    A coded value specifying the technique that is used to perform the procedure.
    @returns {CodeableConcept}
     */

    SpecimenCollectionComponent.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    Anatomical location from which the specimen should be collected (if subject is a patient). This element is not used for environmental specimens.
    @returns {CodeableConcept}
     */

    SpecimenCollectionComponent.prototype.sourceSite = function() {
      if (this.json['sourceSite']) {
        return new CodeableConcept(this.json['sourceSite']);
      }
    };

    return SpecimenCollectionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SpecimenTreatmentComponent
  @exports  SpecimenTreatmentComponent as SpecimenTreatmentComponent
   */

  SpecimenTreatmentComponent = (function(superClass) {
    extend(SpecimenTreatmentComponent, superClass);

    function SpecimenTreatmentComponent(json) {
      this.json = json;
      SpecimenTreatmentComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Textual description of procedure.
    @returns {Array} an array of {@link String} objects
     */

    SpecimenTreatmentComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A coded value specifying the procedure used to process the specimen.
    @returns {CodeableConcept}
     */

    SpecimenTreatmentComponent.prototype.procedure = function() {
      if (this.json['procedure']) {
        return new CodeableConcept(this.json['procedure']);
      }
    };


    /**
    Material used in the processing step.
    @returns {Array} an array of {@link Reference} objects
     */

    SpecimenTreatmentComponent.prototype.additive = function() {
      var i, item, len, ref, results;
      if (this.json['additive']) {
        ref = this.json['additive'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return SpecimenTreatmentComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SpecimenContainerComponent
  @exports  SpecimenContainerComponent as SpecimenContainerComponent
   */

  SpecimenContainerComponent = (function(superClass) {
    extend(SpecimenContainerComponent, superClass);

    function SpecimenContainerComponent(json) {
      this.json = json;
      SpecimenContainerComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    @returns {Array} an array of {@link Identifier} objects
     */

    SpecimenContainerComponent.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Textual description of the container.
    @returns {Array} an array of {@link String} objects
     */

    SpecimenContainerComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    The type of container associated with the specimen (e.g. slide, aliquot, etc).
    @returns {CodeableConcept}
     */

    SpecimenContainerComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The capacity (volume or other measure) the container may contain.
    @returns {Quantity}
     */

    SpecimenContainerComponent.prototype.capacity = function() {
      if (this.json['capacity']) {
        return new Quantity(this.json['capacity']);
      }
    };


    /**
    The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    @returns {Quantity}
     */

    SpecimenContainerComponent.prototype.specimenQuantity = function() {
      if (this.json['specimenQuantity']) {
        return new Quantity(this.json['specimenQuantity']);
      }
    };


    /**
    Introduced substance to preserve, maintain or enhance the specimen. examples: Formalin, Citrate, EDTA.
    @returns {CodeableConcept}
     */

    SpecimenContainerComponent.prototype.additiveCodeableConcept = function() {
      if (this.json['additiveCodeableConcept']) {
        return new CodeableConcept(this.json['additiveCodeableConcept']);
      }
    };


    /**
    Introduced substance to preserve, maintain or enhance the specimen. examples: Formalin, Citrate, EDTA.
    @returns {Reference}
     */

    SpecimenContainerComponent.prototype.additiveReference = function() {
      if (this.json['additiveReference']) {
        return new Reference(this.json['additiveReference']);
      }
    };

    return SpecimenContainerComponent;

  })(BackboneElement);


  /**
  Sample for analysis.
  @class Specimen
  @exports Specimen as Specimen
   */

  Specimen = (function(superClass) {
    extend(Specimen, superClass);

    function Specimen(json) {
      this.json = json;
      Specimen.__super__.constructor.call(this, this.json);
    }


    /**
    Id for specimen.
    @returns {Array} an array of {@link Identifier} objects
     */

    Specimen.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Kind of material that forms the specimen.
    @returns {CodeableConcept}
     */

    Specimen.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    Parent specimen from which the focal specimen was a component.
    @returns {Array} an array of {@link SpecimenSourceComponent} objects
     */

    Specimen.prototype.source = function() {
      var i, item, len, ref, results;
      if (this.json['source']) {
        ref = this.json['source'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SpecimenSourceComponent(item));
        }
        return results;
      }
    };


    /**
    Where the specimen came from. This may be the patient(s) or from the environment or  a device.
    @returns {Reference}
     */

    Specimen.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    @returns {Identifier}
     */

    Specimen.prototype.accessionIdentifier = function() {
      if (this.json['accessionIdentifier']) {
        return new Identifier(this.json['accessionIdentifier']);
      }
    };


    /**
    Time when specimen was received for processing or testing.
    @returns {Array} an array of {@link Date} objects
     */

    Specimen.prototype.receivedTime = function() {
      if (this.json['receivedTime']) {
        return DT.DateTime.parse(this.json['receivedTime']);
      }
    };


    /**
    Details concerning the specimen collection.
    @returns {SpecimenCollectionComponent}
     */

    Specimen.prototype.collection = function() {
      if (this.json['collection']) {
        return new SpecimenCollectionComponent(this.json['collection']);
      }
    };


    /**
    Details concerning treatment and processing steps for the specimen.
    @returns {Array} an array of {@link SpecimenTreatmentComponent} objects
     */

    Specimen.prototype.treatment = function() {
      var i, item, len, ref, results;
      if (this.json['treatment']) {
        ref = this.json['treatment'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SpecimenTreatmentComponent(item));
        }
        return results;
      }
    };


    /**
    The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    @returns {Array} an array of {@link SpecimenContainerComponent} objects
     */

    Specimen.prototype.container = function() {
      var i, item, len, ref, results;
      if (this.json['container']) {
        ref = this.json['container'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SpecimenContainerComponent(item));
        }
        return results;
      }
    };

    return Specimen;

  })(DomainResource);

  module.exports.Specimen = Specimen;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],122:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, StatusRequest, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /**
  This resource provides the request and response details for the resource for which the stsatus is to be checked.
  @class StatusRequest
  @exports StatusRequest as StatusRequest
   */

  StatusRequest = (function(superClass) {
    extend(StatusRequest, superClass);

    function StatusRequest(json) {
      this.json = json;
      StatusRequest.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    StatusRequest.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    StatusRequest.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    StatusRequest.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    StatusRequest.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who is target  of the request.
    @returns {Reference}
     */

    StatusRequest.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    StatusRequest.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    StatusRequest.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Reference of resource to reverse.
    @returns {Reference}
     */

    StatusRequest.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Reference of response to resource to reverse.
    @returns {Reference}
     */

    StatusRequest.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };

    return StatusRequest;

  })(DomainResource);

  module.exports.StatusRequest = StatusRequest;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],123:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, StatusResponse, StatusResponseNotesComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class StatusResponseNotesComponent
  @exports  StatusResponseNotesComponent as StatusResponseNotesComponent
   */

  StatusResponseNotesComponent = (function(superClass) {
    extend(StatusResponseNotesComponent, superClass);

    function StatusResponseNotesComponent(json) {
      this.json = json;
      StatusResponseNotesComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The note purpose: Print/Display.
    @returns {Coding}
     */

    StatusResponseNotesComponent.prototype.type = function() {
      if (this.json['type']) {
        return new Coding(this.json['type']);
      }
    };


    /**
    The note text.
    @returns {Array} an array of {@link String} objects
     */

    StatusResponseNotesComponent.prototype.text = function() {
      return this.json['text'];
    };

    return StatusResponseNotesComponent;

  })(BackboneElement);


  /**
  This resource provides processing status, errors and notes from the processing of a resource.
  @class StatusResponse
  @exports StatusResponse as StatusResponse
   */

  StatusResponse = (function(superClass) {
    extend(StatusResponse, superClass);

    function StatusResponse(json) {
      this.json = json;
      StatusResponse.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    StatusResponse.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    Original request resource referrence.
    @returns {Reference}
     */

    StatusResponse.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Transaction status: error, complete, held.
    @returns {Coding}
     */

    StatusResponse.prototype.outcome = function() {
      if (this.json['outcome']) {
        return new Coding(this.json['outcome']);
      }
    };


    /**
    A description of the status of the adjudication or processing.
    @returns {Array} an array of {@link String} objects
     */

    StatusResponse.prototype.disposition = function() {
      return this.json['disposition'];
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    StatusResponse.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    StatusResponse.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when the enclosed suite of services were performed or completed.
    @returns {Array} an array of {@link Date} objects
     */

    StatusResponse.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer who produced this adjudicated response.
    @returns {Reference}
     */

    StatusResponse.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    StatusResponse.prototype.requestProvider = function() {
      if (this.json['requestProvider']) {
        return new Reference(this.json['requestProvider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    StatusResponse.prototype.requestOrganization = function() {
      if (this.json['requestOrganization']) {
        return new Reference(this.json['requestOrganization']);
      }
    };


    /**
    The form to be used for printing the content.
    @returns {Coding}
     */

    StatusResponse.prototype.form = function() {
      if (this.json['form']) {
        return new Coding(this.json['form']);
      }
    };


    /**
    Suite of processing note or additional requirements is the processing has been held.
    @returns {Array} an array of {@link StatusResponseNotesComponent} objects
     */

    StatusResponse.prototype.notes = function() {
      var i, item, len, ref, results;
      if (this.json['notes']) {
        ref = this.json['notes'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new StatusResponseNotesComponent(item));
        }
        return results;
      }
    };


    /**
    Processing errors.
    @returns {Array} an array of {@link Coding} objects
     */

    StatusResponse.prototype.error = function() {
      var i, item, len, ref, results;
      if (this.json['error']) {
        ref = this.json['error'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };

    return StatusResponse;

  })(DomainResource);

  module.exports.StatusResponse = StatusResponse;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],124:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Subscription, SubscriptionChannelComponent, SubscriptionTagComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SubscriptionChannelComponent
  @exports  SubscriptionChannelComponent as SubscriptionChannelComponent
   */

  SubscriptionChannelComponent = (function(superClass) {
    extend(SubscriptionChannelComponent, superClass);

    function SubscriptionChannelComponent(json) {
      this.json = json;
      SubscriptionChannelComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionChannelComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionChannelComponent.prototype.url = function() {
      return this.json['url'];
    };


    /**
    ToDo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionChannelComponent.prototype.payload = function() {
      return this.json['payload'];
    };


    /**
    Usage depends on the channel type.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionChannelComponent.prototype.header = function() {
      return this.json['header'];
    };

    return SubscriptionChannelComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SubscriptionTagComponent
  @exports  SubscriptionTagComponent as SubscriptionTagComponent
   */

  SubscriptionTagComponent = (function(superClass) {
    extend(SubscriptionTagComponent, superClass);

    function SubscriptionTagComponent(json) {
      this.json = json;
      SubscriptionTagComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionTagComponent.prototype.term = function() {
      return this.json['term'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionTagComponent.prototype.scheme = function() {
      return this.json['scheme'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    SubscriptionTagComponent.prototype.description = function() {
      return this.json['description'];
    };

    return SubscriptionTagComponent;

  })(BackboneElement);


  /**
  Todo.
  @class Subscription
  @exports Subscription as Subscription
   */

  Subscription = (function(superClass) {
    extend(Subscription, superClass);

    function Subscription(json) {
      this.json = json;
      Subscription.__super__.constructor.call(this, this.json);
    }


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    Subscription.prototype.criteria = function() {
      return this.json['criteria'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    Subscription.prototype.contact = function() {
      var i, item, len, ref, results;
      if (this.json['contact']) {
        ref = this.json['contact'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    Subscription.prototype.reason = function() {
      return this.json['reason'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    Subscription.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Todo.
    @returns {Array} an array of {@link String} objects
     */

    Subscription.prototype.error = function() {
      return this.json['error'];
    };


    /**
    Todo.
    @returns {SubscriptionChannelComponent}
     */

    Subscription.prototype.channel = function() {
      if (this.json['channel']) {
        return new SubscriptionChannelComponent(this.json['channel']);
      }
    };


    /**
    Todo.
    @returns {Array} an array of {@link Date} objects
     */

    Subscription.prototype.end = function() {
      if (this.json['end']) {
        return DT.DateTime.parse(this.json['end']);
      }
    };


    /**
    Todo.
    @returns {Array} an array of {@link SubscriptionTagComponent} objects
     */

    Subscription.prototype.tag = function() {
      var i, item, len, ref, results;
      if (this.json['tag']) {
        ref = this.json['tag'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SubscriptionTagComponent(item));
        }
        return results;
      }
    };

    return Subscription;

  })(DomainResource);

  module.exports.Subscription = Subscription;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],125:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Substance, SubstanceIngredientComponent, SubstanceInstanceComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SubstanceInstanceComponent
  @exports  SubstanceInstanceComponent as SubstanceInstanceComponent
   */

  SubstanceInstanceComponent = (function(superClass) {
    extend(SubstanceInstanceComponent, superClass);

    function SubstanceInstanceComponent(json) {
      this.json = json;
      SubstanceInstanceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier associated with the package/container (usually a label affixed directly).
    @returns {Identifier}
     */

    SubstanceInstanceComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    @returns {Array} an array of {@link Date} objects
     */

    SubstanceInstanceComponent.prototype.expiry = function() {
      if (this.json['expiry']) {
        return DT.DateTime.parse(this.json['expiry']);
      }
    };


    /**
    The amount of the substance.
    @returns {Quantity}
     */

    SubstanceInstanceComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };

    return SubstanceInstanceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class SubstanceIngredientComponent
  @exports  SubstanceIngredientComponent as SubstanceIngredientComponent
   */

  SubstanceIngredientComponent = (function(superClass) {
    extend(SubstanceIngredientComponent, superClass);

    function SubstanceIngredientComponent(json) {
      this.json = json;
      SubstanceIngredientComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The amount of the ingredient in the substance - a concentration ratio.
    @returns {Ratio}
     */

    SubstanceIngredientComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Ratio(this.json['quantity']);
      }
    };


    /**
    Another substance that is a component of this substance.
    @returns {Reference}
     */

    SubstanceIngredientComponent.prototype.substance = function() {
      if (this.json['substance']) {
        return new Reference(this.json['substance']);
      }
    };

    return SubstanceIngredientComponent;

  })(BackboneElement);


  /**
  A homogeneous material with a definite composition.
  @class Substance
  @exports Substance as Substance
   */

  Substance = (function(superClass) {
    extend(Substance, superClass);

    function Substance(json) {
      this.json = json;
      Substance.__super__.constructor.call(this, this.json);
    }


    /**
    A code (or set of codes) that identify this substance.
    @returns {CodeableConcept}
     */

    Substance.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    A description of the substance - its appearance, handling requirements, and other usage notes.
    @returns {Array} an array of {@link String} objects
     */

    Substance.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
    @returns {SubstanceInstanceComponent}
     */

    Substance.prototype.instance = function() {
      if (this.json['instance']) {
        return new SubstanceInstanceComponent(this.json['instance']);
      }
    };


    /**
    A substance can be composed of other substances.
    @returns {Array} an array of {@link SubstanceIngredientComponent} objects
     */

    Substance.prototype.ingredient = function() {
      var i, item, len, ref, results;
      if (this.json['ingredient']) {
        ref = this.json['ingredient'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SubstanceIngredientComponent(item));
        }
        return results;
      }
    };

    return Substance;

  })(DomainResource);

  module.exports.Substance = Substance;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],126:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Supply, SupplyDispenseComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SupplyDispenseComponent
  @exports  SupplyDispenseComponent as SupplyDispenseComponent
   */

  SupplyDispenseComponent = (function(superClass) {
    extend(SupplyDispenseComponent, superClass);

    function SupplyDispenseComponent(json) {
      this.json = json;
      SupplyDispenseComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Identifier assigned by the dispensing facility when the dispense occurs.
    @returns {Identifier}
     */

    SupplyDispenseComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    A code specifying the state of the dispense event.
    @returns {Array} an array of {@link String} objects
     */

    SupplyDispenseComponent.prototype.status = function() {
      return this.json['status'];
    };


    /**
    Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    @returns {CodeableConcept}
     */

    SupplyDispenseComponent.prototype.type = function() {
      if (this.json['type']) {
        return new CodeableConcept(this.json['type']);
      }
    };


    /**
    The amount of supply that has been dispensed. Includes unit of measure.
    @returns {Quantity}
     */

    SupplyDispenseComponent.prototype.quantity = function() {
      if (this.json['quantity']) {
        return new Quantity(this.json['quantity']);
      }
    };


    /**
    Identifies the medication or substance or device being dispensed. This is either a link to a resource representing the details of the item or a simple attribute carrying a code that identifies the item from a known list.
    @returns {Reference}
     */

    SupplyDispenseComponent.prototype.suppliedItem = function() {
      if (this.json['suppliedItem']) {
        return new Reference(this.json['suppliedItem']);
      }
    };


    /**
    The individual responsible for dispensing the medication, supplier or device.
    @returns {Reference}
     */

    SupplyDispenseComponent.prototype.supplier = function() {
      if (this.json['supplier']) {
        return new Reference(this.json['supplier']);
      }
    };


    /**
    The time the dispense event occurred.
    @returns {Period}
     */

    SupplyDispenseComponent.prototype.whenPrepared = function() {
      if (this.json['whenPrepared']) {
        return new Period(this.json['whenPrepared']);
      }
    };


    /**
    The time the dispensed item was sent or handed to the patient (or agent).
    @returns {Period}
     */

    SupplyDispenseComponent.prototype.whenHandedOver = function() {
      if (this.json['whenHandedOver']) {
        return new Period(this.json['whenHandedOver']);
      }
    };


    /**
    Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    @returns {Reference}
     */

    SupplyDispenseComponent.prototype.destination = function() {
      if (this.json['destination']) {
        return new Reference(this.json['destination']);
      }
    };


    /**
    Identifies the person who picked up the Supply.
    @returns {Array} an array of {@link Reference} objects
     */

    SupplyDispenseComponent.prototype.receiver = function() {
      var i, item, len, ref, results;
      if (this.json['receiver']) {
        ref = this.json['receiver'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };

    return SupplyDispenseComponent;

  })(BackboneElement);


  /**
  A supply - a  request for something, and provision of what is supplied.
  @class Supply
  @exports Supply as Supply
   */

  Supply = (function(superClass) {
    extend(Supply, superClass);

    function Supply(json) {
      this.json = json;
      Supply.__super__.constructor.call(this, this.json);
    }


    /**
    Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process.
    @returns {CodeableConcept}
     */

    Supply.prototype.kind = function() {
      if (this.json['kind']) {
        return new CodeableConcept(this.json['kind']);
      }
    };


    /**
    Unique identifier for this supply request.
    @returns {Identifier}
     */

    Supply.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    Status of the supply request.
    @returns {Array} an array of {@link String} objects
     */

    Supply.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The item that is requested to be supplied.
    @returns {Reference}
     */

    Supply.prototype.orderedItem = function() {
      if (this.json['orderedItem']) {
        return new Reference(this.json['orderedItem']);
      }
    };


    /**
    A link to a resource representing the person whom the ordered item is for.
    @returns {Reference}
     */

    Supply.prototype.patient = function() {
      if (this.json['patient']) {
        return new Reference(this.json['patient']);
      }
    };


    /**
    Indicates the details of the dispense event such as the days supply and quantity of a supply dispensed.
    @returns {Array} an array of {@link SupplyDispenseComponent} objects
     */

    Supply.prototype.dispense = function() {
      var i, item, len, ref, results;
      if (this.json['dispense']) {
        ref = this.json['dispense'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SupplyDispenseComponent(item));
        }
        return results;
      }
    };

    return Supply;

  })(DomainResource);

  module.exports.Supply = Supply;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],127:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, SupportingDocumentation, SupportingDocumentationDetailComponent, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class SupportingDocumentationDetailComponent
  @exports  SupportingDocumentationDetailComponent as SupportingDocumentationDetailComponent
   */

  SupportingDocumentationDetailComponent = (function(superClass) {
    extend(SupportingDocumentationDetailComponent, superClass);

    function SupportingDocumentationDetailComponent(json) {
      this.json = json;
      SupportingDocumentationDetailComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A link Id for the response to reference.
    @returns {Array} an array of {@link Number} objects
     */

    SupportingDocumentationDetailComponent.prototype.linkId = function() {
      return this.json['linkId'];
    };


    /**
    The attached content.
    @returns {Reference}
     */

    SupportingDocumentationDetailComponent.prototype.contentReference = function() {
      if (this.json['contentReference']) {
        return new Reference(this.json['contentReference']);
      }
    };


    /**
    The attached content.
    @returns {Attachment}
     */

    SupportingDocumentationDetailComponent.prototype.contentAttachment = function() {
      if (this.json['contentAttachment']) {
        return new Attachment(this.json['contentAttachment']);
      }
    };


    /**
    The date and optionally time when the material was created.
    @returns {Array} an array of {@link Date} objects
     */

    SupportingDocumentationDetailComponent.prototype.dateTime = function() {
      if (this.json['dateTime']) {
        return DT.DateTime.parse(this.json['dateTime']);
      }
    };

    return SupportingDocumentationDetailComponent;

  })(BackboneElement);


  /**
  This resource provides the supporting information for a process, for example clinical or financial  information related to a claim or pre-authorization.
  @class SupportingDocumentation
  @exports SupportingDocumentation as SupportingDocumentation
   */

  SupportingDocumentation = (function(superClass) {
    extend(SupportingDocumentation, superClass);

    function SupportingDocumentation(json) {
      this.json = json;
      SupportingDocumentation.__super__.constructor.call(this, this.json);
    }


    /**
    The Response Business Identifier.
    @returns {Array} an array of {@link Identifier} objects
     */

    SupportingDocumentation.prototype.identifier = function() {
      var i, item, len, ref, results;
      if (this.json['identifier']) {
        ref = this.json['identifier'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Identifier(item));
        }
        return results;
      }
    };


    /**
    The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    @returns {Coding}
     */

    SupportingDocumentation.prototype.ruleset = function() {
      if (this.json['ruleset']) {
        return new Coding(this.json['ruleset']);
      }
    };


    /**
    The style (standard) and version of the original material which was converted into this resource.
    @returns {Coding}
     */

    SupportingDocumentation.prototype.originalRuleset = function() {
      if (this.json['originalRuleset']) {
        return new Coding(this.json['originalRuleset']);
      }
    };


    /**
    The date when this resource was created.
    @returns {Array} an array of {@link Date} objects
     */

    SupportingDocumentation.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The Insurer, organization or Provider who is target  of the submission.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };


    /**
    The practitioner who is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.provider = function() {
      if (this.json['provider']) {
        return new Reference(this.json['provider']);
      }
    };


    /**
    The organization which is responsible for the services rendered to the patient.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.organization = function() {
      if (this.json['organization']) {
        return new Reference(this.json['organization']);
      }
    };


    /**
    Original request identifer.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.request = function() {
      if (this.json['request']) {
        return new Reference(this.json['request']);
      }
    };


    /**
    Original response identifer.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.response = function() {
      if (this.json['response']) {
        return new Reference(this.json['response']);
      }
    };


    /**
    Person who created the submission.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.author = function() {
      if (this.json['author']) {
        return new Reference(this.json['author']);
      }
    };


    /**
    The patient who is directly or indirectly the subject of the supporting information.
    @returns {Reference}
     */

    SupportingDocumentation.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    Supporting Files.
    @returns {Array} an array of {@link SupportingDocumentationDetailComponent} objects
     */

    SupportingDocumentation.prototype.detail = function() {
      var i, item, len, ref, results;
      if (this.json['detail']) {
        ref = this.json['detail'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new SupportingDocumentationDetailComponent(item));
        }
        return results;
      }
    };

    return SupportingDocumentation;

  })(DomainResource);

  module.exports.SupportingDocumentation = SupportingDocumentation;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],128:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ConceptDefinitionComponent, ConceptDefinitionDesignationComponent, ConceptReferenceComponent, ConceptSetComponent, ConceptSetFilterComponent, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing, ValueSet, ValueSetComposeComponent, ValueSetDefineComponent, ValueSetExpansionComponent, ValueSetExpansionContainsComponent,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ConceptDefinitionDesignationComponent
  @exports  ConceptDefinitionDesignationComponent as ConceptDefinitionDesignationComponent
   */

  ConceptDefinitionDesignationComponent = (function(superClass) {
    extend(ConceptDefinitionDesignationComponent, superClass);

    function ConceptDefinitionDesignationComponent(json) {
      this.json = json;
      ConceptDefinitionDesignationComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The language this designation is defined for.
    @returns {Array} an array of {@link String} objects
     */

    ConceptDefinitionDesignationComponent.prototype.language = function() {
      return this.json['language'];
    };


    /**
    A code that details how this designation would be used.
    @returns {Coding}
     */

    ConceptDefinitionDesignationComponent.prototype.use = function() {
      if (this.json['use']) {
        return new Coding(this.json['use']);
      }
    };


    /**
    The text value for this designation.
    @returns {Array} an array of {@link String} objects
     */

    ConceptDefinitionDesignationComponent.prototype.value = function() {
      return this.json['value'];
    };

    return ConceptDefinitionDesignationComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptDefinitionComponent
  @exports  ConceptDefinitionComponent as ConceptDefinitionComponent
   */

  ConceptDefinitionComponent = (function(superClass) {
    extend(ConceptDefinitionComponent, superClass);

    function ConceptDefinitionComponent(json) {
      this.json = json;
      ConceptDefinitionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Code that identifies concept.
    @returns {Array} an array of {@link String} objects
     */

    ConceptDefinitionComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    If this code is not for use as a real concept.
    @returns {Array} an array of {@link boolean} objects
     */

    ConceptDefinitionComponent.prototype.abstract = function() {
      return this.json['abstract'];
    };


    /**
    Text to Display to the user.
    @returns {Array} an array of {@link String} objects
     */

    ConceptDefinitionComponent.prototype.display = function() {
      return this.json['display'];
    };


    /**
    The formal definition of the concept. Formal definitions are not required, because of the prevalence of legacy systems without them, but they are highly recommended, as without them there is no formal meaning associated with the concept.
    @returns {Array} an array of {@link String} objects
     */

    ConceptDefinitionComponent.prototype.definition = function() {
      return this.json['definition'];
    };


    /**
    Additional representations for the concept - other languages, aliases, specialised purposes, used for particular purposes, etc.
    @returns {Array} an array of {@link ConceptDefinitionDesignationComponent} objects
     */

    ConceptDefinitionComponent.prototype.designation = function() {
      var i, item, len, ref, results;
      if (this.json['designation']) {
        ref = this.json['designation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptDefinitionDesignationComponent(item));
        }
        return results;
      }
    };


    /**
    Child Concepts (is-a / contains).
    @returns {Array} an array of {@link ConceptDefinitionComponent} objects
     */

    ConceptDefinitionComponent.prototype.concept = function() {
      var i, item, len, ref, results;
      if (this.json['concept']) {
        ref = this.json['concept'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptDefinitionComponent(item));
        }
        return results;
      }
    };

    return ConceptDefinitionComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ValueSetDefineComponent
  @exports  ValueSetDefineComponent as ValueSetDefineComponent
   */

  ValueSetDefineComponent = (function(superClass) {
    extend(ValueSetDefineComponent, superClass);

    function ValueSetDefineComponent(json) {
      this.json = json;
      ValueSetDefineComponent.__super__.constructor.call(this, this.json);
    }


    /**
    URI to identify the code system.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetDefineComponent.prototype.system = function() {
      return this.json['system'];
    };


    /**
    The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetDefineComponent.prototype.version = function() {
      return this.json['version'];
    };


    /**
    If code comparison is case sensitive when codes within this system are compared to each other.
    @returns {Array} an array of {@link boolean} objects
     */

    ValueSetDefineComponent.prototype.caseSensitive = function() {
      return this.json['caseSensitive'];
    };


    /**
    Concepts in the code system.
    @returns {Array} an array of {@link ConceptDefinitionComponent} objects
     */

    ValueSetDefineComponent.prototype.concept = function() {
      var i, item, len, ref, results;
      if (this.json['concept']) {
        ref = this.json['concept'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptDefinitionComponent(item));
        }
        return results;
      }
    };

    return ValueSetDefineComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptReferenceComponent
  @exports  ConceptReferenceComponent as ConceptReferenceComponent
   */

  ConceptReferenceComponent = (function(superClass) {
    extend(ConceptReferenceComponent, superClass);

    function ConceptReferenceComponent(json) {
      this.json = json;
      ConceptReferenceComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Specifies a code for the concept to be included or excluded.
    @returns {Array} an array of {@link String} objects
     */

    ConceptReferenceComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    @returns {Array} an array of {@link String} objects
     */

    ConceptReferenceComponent.prototype.display = function() {
      return this.json['display'];
    };


    /**
    Additional representations for this concept when used in this value set - other languages, aliases, specialised purposes, used for particular purposes, etc.
    @returns {Array} an array of {@link ConceptDefinitionDesignationComponent} objects
     */

    ConceptReferenceComponent.prototype.designation = function() {
      var i, item, len, ref, results;
      if (this.json['designation']) {
        ref = this.json['designation'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptDefinitionDesignationComponent(item));
        }
        return results;
      }
    };

    return ConceptReferenceComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptSetFilterComponent
  @exports  ConceptSetFilterComponent as ConceptSetFilterComponent
   */

  ConceptSetFilterComponent = (function(superClass) {
    extend(ConceptSetFilterComponent, superClass);

    function ConceptSetFilterComponent(json) {
      this.json = json;
      ConceptSetFilterComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code that identifies a property defined in the code system.
    @returns {Array} an array of {@link String} objects
     */

    ConceptSetFilterComponent.prototype.property = function() {
      return this.json['property'];
    };


    /**
    The kind of operation to perform as a part of the filter criteria.
    @returns {Array} an array of {@link String} objects
     */

    ConceptSetFilterComponent.prototype.op = function() {
      return this.json['op'];
    };


    /**
    The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    @returns {Array} an array of {@link String} objects
     */

    ConceptSetFilterComponent.prototype.value = function() {
      return this.json['value'];
    };

    return ConceptSetFilterComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ConceptSetComponent
  @exports  ConceptSetComponent as ConceptSetComponent
   */

  ConceptSetComponent = (function(superClass) {
    extend(ConceptSetComponent, superClass);

    function ConceptSetComponent(json) {
      this.json = json;
      ConceptSetComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The code system from which the selected codes come from.
    @returns {Array} an array of {@link String} objects
     */

    ConceptSetComponent.prototype.system = function() {
      return this.json['system'];
    };


    /**
    The version of the code system that the codes are selected from.
    @returns {Array} an array of {@link String} objects
     */

    ConceptSetComponent.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Specifies a concept to be included or excluded.
    @returns {Array} an array of {@link ConceptReferenceComponent} objects
     */

    ConceptSetComponent.prototype.concept = function() {
      var i, item, len, ref, results;
      if (this.json['concept']) {
        ref = this.json['concept'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptReferenceComponent(item));
        }
        return results;
      }
    };


    /**
    Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
    @returns {Array} an array of {@link ConceptSetFilterComponent} objects
     */

    ConceptSetComponent.prototype.filter = function() {
      var i, item, len, ref, results;
      if (this.json['filter']) {
        ref = this.json['filter'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptSetFilterComponent(item));
        }
        return results;
      }
    };

    return ConceptSetComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ValueSetComposeComponent
  @exports  ValueSetComposeComponent as ValueSetComposeComponent
   */

  ValueSetComposeComponent = (function(superClass) {
    extend(ValueSetComposeComponent, superClass);

    function ValueSetComposeComponent(json) {
      this.json = json;
      ValueSetComposeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    Includes the contents of the referenced value set as a part of the contents of this value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetComposeComponent.prototype["import"] = function() {
      return this.json['import'];
    };


    /**
    Include one or more codes from a code system.
    @returns {Array} an array of {@link ConceptSetComponent} objects
     */

    ValueSetComposeComponent.prototype.include = function() {
      var i, item, len, ref, results;
      if (this.json['include']) {
        ref = this.json['include'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptSetComponent(item));
        }
        return results;
      }
    };


    /**
    Exclude one or more codes from the value set.
    @returns {Array} an array of {@link ConceptSetComponent} objects
     */

    ValueSetComposeComponent.prototype.exclude = function() {
      var i, item, len, ref, results;
      if (this.json['exclude']) {
        ref = this.json['exclude'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ConceptSetComponent(item));
        }
        return results;
      }
    };

    return ValueSetComposeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ValueSetExpansionContainsComponent
  @exports  ValueSetExpansionContainsComponent as ValueSetExpansionContainsComponent
   */

  ValueSetExpansionContainsComponent = (function(superClass) {
    extend(ValueSetExpansionContainsComponent, superClass);

    function ValueSetExpansionContainsComponent(json) {
      this.json = json;
      ValueSetExpansionContainsComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The system in which the code for this item in the expansion is defined.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetExpansionContainsComponent.prototype.system = function() {
      return this.json['system'];
    };


    /**
    If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    @returns {Array} an array of {@link boolean} objects
     */

    ValueSetExpansionContainsComponent.prototype.abstract = function() {
      return this.json['abstract'];
    };


    /**
    The version of this code system that defined this code and/or display. This should only be used with code systems that do not enforce concept permanence.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetExpansionContainsComponent.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Code - if blank, this is not a choosable code.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetExpansionContainsComponent.prototype.code = function() {
      return this.json['code'];
    };


    /**
    User display for the concept.
    @returns {Array} an array of {@link String} objects
     */

    ValueSetExpansionContainsComponent.prototype.display = function() {
      return this.json['display'];
    };


    /**
    Codes contained in this concept.
    @returns {Array} an array of {@link ValueSetExpansionContainsComponent} objects
     */

    ValueSetExpansionContainsComponent.prototype.contains = function() {
      var i, item, len, ref, results;
      if (this.json['contains']) {
        ref = this.json['contains'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ValueSetExpansionContainsComponent(item));
        }
        return results;
      }
    };

    return ValueSetExpansionContainsComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ValueSetExpansionComponent
  @exports  ValueSetExpansionComponent as ValueSetExpansionComponent
   */

  ValueSetExpansionComponent = (function(superClass) {
    extend(ValueSetExpansionComponent, superClass);

    function ValueSetExpansionComponent(json) {
      this.json = json;
      ValueSetExpansionComponent.__super__.constructor.call(this, this.json);
    }


    /**
    An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    @returns {Identifier}
     */

    ValueSetExpansionComponent.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The time at which the expansion was produced by the expanding system.
    @returns {Array} an array of {@link Date} objects
     */

    ValueSetExpansionComponent.prototype.timestamp = function() {
      if (this.json['timestamp']) {
        return DT.DateTime.parse(this.json['timestamp']);
      }
    };


    /**
    The codes that are contained in the value set expansion.
    @returns {Array} an array of {@link ValueSetExpansionContainsComponent} objects
     */

    ValueSetExpansionComponent.prototype.contains = function() {
      var i, item, len, ref, results;
      if (this.json['contains']) {
        ref = this.json['contains'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ValueSetExpansionContainsComponent(item));
        }
        return results;
      }
    };

    return ValueSetExpansionComponent;

  })(BackboneElement);


  /**
  A value set specifies a set of codes drawn from one or more code systems.
  @class ValueSet
  @exports ValueSet as ValueSet
   */

  ValueSet = (function(superClass) {
    extend(ValueSet, superClass);

    function ValueSet(json) {
      this.json = json;
      ValueSet.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this value set when it is referenced in a specification, model, design or an instance (should be globally unique OID, UUID, or URI).
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.identifier = function() {
      return this.json['identifier'];
    };


    /**
    The identifier that is used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.version = function() {
      return this.json['version'];
    };


    /**
    A free text natural language name describing the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.name = function() {
      return this.json['name'];
    };


    /**
    This should describe "the semantic space" to be included in the value set. This can also describe the approach taken to build the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.purpose = function() {
      return this.json['purpose'];
    };


    /**
    If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    @returns {Array} an array of {@link boolean} objects
     */

    ValueSet.prototype.immutable = function() {
      return this.json['immutable'];
    };


    /**
    The name of the individual or organization that published the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contacts of the publisher to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    ValueSet.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    A free text natural language description of the use of the value set - reason for definition, conditions of use, etc. The description may include a list of expected usages for the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.description = function() {
      return this.json['description'];
    };


    /**
    A copyright statement relating to the value set and/or its contents. These are generally legal restrictions on the use and publishing of the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.copyright = function() {
      return this.json['copyright'];
    };


    /**
    The status of the value set.
    @returns {Array} an array of {@link String} objects
     */

    ValueSet.prototype.status = function() {
      return this.json['status'];
    };


    /**
    This valueset was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    @returns {Array} an array of {@link boolean} objects
     */

    ValueSet.prototype.experimental = function() {
      return this.json['experimental'];
    };


    /**
    Whether this is intended to be used with an extensible binding or not.
    @returns {Array} an array of {@link boolean} objects
     */

    ValueSet.prototype.extensible = function() {
      return this.json['extensible'];
    };


    /**
    The date that the value set status was last changed.
    @returns {Array} an array of {@link Date} objects
     */

    ValueSet.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    If a Stability Date is expanded by evaluating the Content Logical Definition using the current version of all referenced code system(s) and value sets as of the Stability Date.
    @returns {Array} an array of {@link Date} objects
     */

    ValueSet.prototype.stableDate = function() {
      if (this.json['stableDate']) {
        return DT.DateTime.parse(this.json['stableDate']);
      }
    };


    /**
    When value set defines its own codes.
    @returns {ValueSetDefineComponent}
     */

    ValueSet.prototype.define = function() {
      if (this.json['define']) {
        return new ValueSetDefineComponent(this.json['define']);
      }
    };


    /**
    When value set includes codes from elsewhere.
    @returns {ValueSetComposeComponent}
     */

    ValueSet.prototype.compose = function() {
      if (this.json['compose']) {
        return new ValueSetComposeComponent(this.json['compose']);
      }
    };


    /**
    A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
    @returns {ValueSetExpansionComponent}
     */

    ValueSet.prototype.expansion = function() {
      if (this.json['expansion']) {
        return new ValueSetExpansionComponent(this.json['expansion']);
      }
    };

    return ValueSet;

  })(DomainResource);

  module.exports.ValueSet = ValueSet;

}).call(this);



},{"../cql-datatypes":2,"./core":56}],129:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Context, Exception, Library, PatientContext, PopulationContext, typeIsArray, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Library = require('../elm/library').Library;

  Exception = require('../datatypes/exception').Exception;

  typeIsArray = require('../util/util').typeIsArray;

  util = require('util');

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  module.exports.Context = Context = (function() {
    function Context(parent, _codeService, _parameters) {
      this.parent = parent;
      this._codeService = _codeService != null ? _codeService : null;
      if (_parameters == null) {
        _parameters = {};
      }
      this.context_values = {};
      this.library_context = {};
      this.localId_context = {};
      this.checkParameters(_parameters);
      this._parameters = _parameters;
    }

    Context.property("parameters", {
      get: function() {
        var k, p, ref, v;
        p = (ref = this.parent) != null ? ref.parameters : void 0;
        for (k in p) {
          v = p[k];
          if (!(k in this._parameters)) {
            this._parameters[k] = v;
          }
        }
        return this._parameters;
      },
      set: function(params) {
        this.checkParameters(params);
        return this._parameters = params;
      }
    });

    Context.property("codeService", {
      get: function() {
        var ref;
        return this._codeService || ((ref = this.parent) != null ? ref.codeService : void 0);
      },
      set: function(cs) {
        return this._codeService = cs;
      }
    });

    Context.prototype.withParameters = function(params) {
      this.parameters = params != null ? params : {};
      return this;
    };

    Context.prototype.withCodeService = function(cs) {
      this.codeService = cs;
      return this;
    };

    Context.prototype.rootContext = function() {
      if (this.parent) {
        return this.parent.rootContext();
      } else {
        return this;
      }
    };

    Context.prototype.findRecords = function(profile) {
      var ref;
      return (ref = this.parent) != null ? ref.findRecords(profile) : void 0;
    };

    Context.prototype.childContext = function(context_values) {
      var ctx;
      if (context_values == null) {
        context_values = {};
      }
      ctx = new Context(this);
      ctx.context_values = context_values;
      return ctx;
    };

    Context.prototype.getLibraryContext = function(library) {
      var ref;
      return (ref = this.parent) != null ? ref.getLibraryContext(library) : void 0;
    };

    Context.prototype.getLocalIdContext = function(localId) {
      var ref;
      return (ref = this.parent) != null ? ref.getLocalIdContext(localId) : void 0;
    };

    Context.prototype.getParameter = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getParameter(name) : void 0;
    };

    Context.prototype.getValueSet = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getValueSet(name) : void 0;
    };

    Context.prototype.getCodeSystem = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getCodeSystem(name) : void 0;
    };

    Context.prototype.getCode = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getCode(name) : void 0;
    };

    Context.prototype.getConcept = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getConcept(name) : void 0;
    };

    Context.prototype.get = function(identifier) {
      var ref;
      if (typeof this.context_values[identifier] !== 'undefined') {
        return this.context_values[identifier];
      } else {
        return (ref = this.parent) != null ? ref.get(identifier) : void 0;
      }
    };

    Context.prototype.set = function(identifier, value) {
      return this.context_values[identifier] = value;
    };

    Context.prototype.checkParameters = function(params) {
      var pDef, pName, pVal;
      for (pName in params) {
        pVal = params[pName];
        pDef = this.getParameter(pName);
        if (pVal == null) {
          return;
        }
        if (typeof pDef === "undefined") {
          return;
        } else if ((pDef.parameterTypeSpecifier != null) && !this.matchesTypeSpecifier(pVal, pDef.parameterTypeSpecifier)) {
          throw new Error("Passed in parameter '" + pName + "' is wrong type");
        } else if ((pDef['default'] != null) && !this.matchesInstanceType(pVal, pDef['default'])) {
          throw new Error("Passed in parameter '" + pName + "' is wrong type");
        }
      }
      return true;
    };

    Context.prototype.matchesTypeSpecifier = function(val, spec) {
      switch (spec.type) {
        case "NamedTypeSpecifier":
          return this.matchesNamedTypeSpecifier(val, spec);
        case "ListTypeSpecifier":
          return this.matchesListTypeSpecifier(val, spec);
        case "TupleTypeSpecifier":
          return this.matchesTupleTypeSpecifier(val, spec);
        case "IntervalTypeSpecifier":
          return this.matchesIntervalTypeSpecifier(val, spec);
        default:
          return true;
      }
    };

    Context.prototype.matchesListTypeSpecifier = function(val, spec) {
      return typeIsArray(val) && val.every((function(_this) {
        return function(x) {
          return _this.matchesTypeSpecifier(x, spec.elementType);
        };
      })(this));
    };

    Context.prototype.matchesTupleTypeSpecifier = function(val, spec) {
      return typeof val === "object" && !typeIsArray(val) && spec.element.every((function(_this) {
        return function(x) {
          return typeof val[x.name] === "undefined" || _this.matchesTypeSpecifier(val[x.name], x.type);
        };
      })(this));
    };

    Context.prototype.matchesIntervalTypeSpecifier = function(val, spec) {
      var ref;
      return ((ref = val.constructor) != null ? ref.name : void 0) === "Interval" && ((val.low == null) || this.matchesTypeSpecifier(val.low, spec.pointType)) && ((val.high == null) || this.matchesTypeSpecifier(val.high, spec.pointType));
    };

    Context.prototype.matchesNamedTypeSpecifier = function(val, spec) {
      var ref, ref1, ref2, ref3;
      switch (spec.name) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return typeof val === "boolean";
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return typeof val === "number";
        case "{urn:hl7-org:elm-types:r1}Integer":
          return typeof val === "number" && Math.floor(val) === val;
        case "{urn:hl7-org:elm-types:r1}String":
          return typeof val === "string";
        case "{urn:hl7-org:elm-types:r1}Concept":
          return (val != null ? (ref = val.constructor) != null ? ref.name : void 0 : void 0) === 'Concept';
        case "{urn:hl7-org:elm-types:r1}DateTime":
          return (val != null ? (ref1 = val.constructor) != null ? ref1.name : void 0 : void 0) === 'DateTime';
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return (val != null ? (ref2 = val.constructor) != null ? ref2.name : void 0 : void 0) === 'Quantity';
        case "{urn:hl7-org:elm-types:r1}Time":
          return (val != null ? (ref3 = val.constructor) != null ? ref3.name : void 0 : void 0) === 'DateTime' && val.isTime();
        default:
          return true;
      }
    };

    Context.prototype.matchesInstanceType = function(val, inst) {
      var ref, ref1, ref2, ref3, ref4;
      switch ((ref = inst.constructor) != null ? ref.name : void 0) {
        case "BooleanLiteral":
          return typeof val === "boolean";
        case "DecimalLiteral":
          return typeof val === "number";
        case "IntegerLiteral":
          return typeof val === "number" && Math.floor(val) === val;
        case "StringLiteral":
          return typeof val === "string";
        case "Concept":
          return (val != null ? (ref1 = val.constructor) != null ? ref1.name : void 0 : void 0) === "Concept";
        case "DateTime":
          return (val != null ? (ref2 = val.constructor) != null ? ref2.name : void 0 : void 0) === "DateTime";
        case "Quantity":
          return (val != null ? (ref3 = val.constructor) != null ? ref3.name : void 0 : void 0) === "Quantity";
        case "Time":
          return (val != null ? (ref4 = val.constructor) != null ? ref4.name : void 0 : void 0) === "DateTime" && val.isTime();
        case "List":
          return this.matchesListInstanceType(val, inst);
        case "Tuple":
          return this.matchesTupleInstanceType(val, inst);
        case "Interval":
          return this.matchesIntervalInstanceType(val, inst);
        default:
          return true;
      }
    };

    Context.prototype.matchesListInstanceType = function(val, list) {
      return typeIsArray(val) && val.every((function(_this) {
        return function(x) {
          return _this.matchesInstanceType(x, list.elements[0]);
        };
      })(this));
    };

    Context.prototype.matchesTupleInstanceType = function(val, tpl) {
      return typeof val === "object" && !typeIsArray(val) && tpl.elements.every((function(_this) {
        return function(x) {
          return typeof val[x.name] === "undefined" || _this.matchesInstanceType(val[x.name], x.value);
        };
      })(this));
    };

    Context.prototype.matchesIntervalInstanceType = function(val, ivl) {
      var pointType, ref, ref1;
      pointType = (ref = ivl.low) != null ? ref : ivl.high;
      return ((ref1 = val.constructor) != null ? ref1.name : void 0) === "Interval" && ((val.low == null) || this.matchesInstanceType(val.low, pointType)) && ((val.high == null) || this.matchesInstanceType(val.high, pointType));
    };

    return Context;

  })();

  module.exports.PatientContext = PatientContext = (function(superClass) {
    extend(PatientContext, superClass);

    function PatientContext(library1, patient, codeService, parameters) {
      this.library = library1;
      this.patient = patient;
      PatientContext.__super__.constructor.call(this, this.library, codeService, parameters);
    }

    PatientContext.prototype.rootContext = function() {
      return this;
    };

    PatientContext.prototype.getLibraryContext = function(library) {
      var base;
      return (base = this.library_context)[library] || (base[library] = new PatientContext(this.get(library), this.patient, this.codeService, this.parameters));
    };

    PatientContext.prototype.getLocalIdContext = function(localId) {
      var base;
      return (base = this.localId_context)[localId] || (base[localId] = new PatientContext(this.get(library), this.patient, this.codeService, this.parameters));
    };

    PatientContext.prototype.findRecords = function(profile) {
      var ref;
      return (ref = this.patient) != null ? ref.findRecords(profile) : void 0;
    };

    return PatientContext;

  })(Context);

  module.exports.PopulationContext = PopulationContext = (function(superClass) {
    extend(PopulationContext, superClass);

    function PopulationContext(library1, results, codeService, parameters) {
      this.library = library1;
      this.results = results;
      PopulationContext.__super__.constructor.call(this, this.library, codeService, parameters);
    }

    PopulationContext.prototype.rootContext = function() {
      return this;
    };

    PopulationContext.prototype.findRecords = function(template) {
      throw new Exception("Retreives are not currently supported in Population Context");
    };

    PopulationContext.prototype.getLibraryContext = function(library) {
      throw new Exception("Library expressions are not currently supported in Population Context");
    };

    PopulationContext.prototype.get = function(identifier) {
      var pid, ref, ref1, res, results;
      if (this.context_values[identifier]) {
        return this.context_values[identifier];
      }
      if (((ref = this.library[identifier]) != null ? ref.context : void 0) === "Population") {
        return this.library.expressions[identifier];
      }
      ref1 = this.results.patientResults;
      results = [];
      for (pid in ref1) {
        res = ref1[pid];
        results.push(res[identifier]);
      }
      return results;
    };

    return PopulationContext;

  })(Context);

}).call(this);



},{"../datatypes/exception":8,"../elm/library":25,"../util/util":135,"util":139}],130:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Executor, PatientContext, PopulationContext, Results, ref;

  module.exports.Executor = Executor = (function() {
    function Executor(library, codeService, parameters) {
      this.library = library;
      this.codeService = codeService;
      this.parameters = parameters;
    }

    Executor.prototype.withLibrary = function(lib) {
      this.library = lib;
      return this;
    };

    Executor.prototype.withParameters = function(params) {
      this.parameters = params != null ? params : {};
      return this;
    };

    Executor.prototype.withCodeService = function(cs) {
      this.codeService = cs;
      return this;
    };

    Executor.prototype.exec_expression = function(expression, patientSource) {
      var expr, p, patient_ctx, r;
      Results(r = new Results());
      expr = this.library.expressions[expression];
      while (expr && (p = patientSource.currentPatient())) {
        patient_ctx = new PatientContext(this.library, p, this.codeService, this.parameters);
        r.recordPatientResult(patient_ctx.patient.id(), expression, expr.exec(patient_ctx));
        patientSource.nextPatient();
      }
      return r;
    };

    Executor.prototype.exec = function(patientSource) {
      var expr, key, popContext, r, ref;
      Results(r = this.exec_patient_context(patientSource));
      popContext = new PopulationContext(this.library, r, this.codeService, this.parameters);
      ref = this.library.expressions;
      for (key in ref) {
        expr = ref[key];
        if (expr.context === "Population") {
          r.recordPopulationResult(key, expr.exec(popContext));
        }
      }
      return r;
    };

    Executor.prototype.exec_patient_context = function(patientSource) {
      var expr, key, p, patient_ctx, r, ref;
      Results(r = new Results());
      while (p = patientSource.currentPatient()) {
        patient_ctx = new PatientContext(this.library, p, this.codeService, this.parameters);
        ref = this.library.expressions;
        for (key in ref) {
          expr = ref[key];
          if (expr.context === "Patient") {
            r.recordPatientResult(patient_ctx.patient.id(), key, patient_ctx.localId_context, expr.execute(patient_ctx));
          }
        }
        patientSource.nextPatient();
      }
      return r;
    };

    return Executor;

  })();

  Results = require('./results').Results;

  ref = require('./context'), PopulationContext = ref.PopulationContext, PatientContext = ref.PatientContext;

}).call(this);



},{"./context":129,"./results":132}],131:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Repository, cql;

  cql = require('../cql');

  module.exports.Repository = Repository = (function() {
    function Repository(data) {
      var k, v;
      this.data = data;
      this.libraries = (function() {
        var ref, results;
        ref = this.data;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(v);
        }
        return results;
      }).call(this);
    }

    Repository.prototype.resolve = function(library, version) {
      var i, len, lib, ref, ref1, ref2, ref3, ref4;
      ref = this.libraries;
      for (i = 0, len = ref.length; i < len; i++) {
        lib = ref[i];
        if (((ref1 = lib.library) != null ? (ref2 = ref1.identifier) != null ? ref2.id : void 0 : void 0) === library && ((ref3 = lib.library) != null ? (ref4 = ref3.identifier) != null ? ref4.version : void 0 : void 0) === version) {
          return new cql.Library(lib, this);
        }
      }
    };

    return Repository;

  })();

}).call(this);



},{"../cql":4}],132:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Results;

  module.exports.Results = Results = (function() {
    function Results() {
      this.patientResults = {};
      this.populationResults = {};
      this.localIdPatientResultsMap = {};
    }

    Results.prototype.recordPatientResult = function(patientId, resultName, localId_hash, result) {
      var base, base1, localId, results, value;
      if ((base = this.patientResults)[patientId] == null) {
        base[patientId] = {};
      }
      if ((base1 = this.localIdPatientResultsMap)[patientId] == null) {
        base1[patientId] = {};
      }
      this.patientResults[patientId][resultName] = result;
      results = [];
      for (localId in localId_hash) {
        value = localId_hash[localId];
        results.push(this.localIdPatientResultsMap[patientId][localId] = value);
      }
      return results;
    };

    Results.prototype.recordPopulationResult = function(resultName, result) {
      return this.populationResults[resultName] = result;
    };

    return Results;

  })();

}).call(this);



},{}],133:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DateTime, Uncertainty, areDateTimesOrQuantities, areNumbers, equals, isUncertainty;

  DateTime = require('../datatypes/datetime').DateTime;

  Uncertainty = require('../datatypes/uncertainty').Uncertainty;

  areNumbers = function(a, b) {
    return typeof a === 'number' && typeof b === 'number';
  };

  areDateTimesOrQuantities = function(a, b) {
    var ref, ref1;
    return (a instanceof DateTime && b instanceof DateTime) || ((a != null ? (ref = a.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity' && (b != null ? (ref1 = b.constructor) != null ? ref1.name : void 0 : void 0) === 'Quantity');
  };

  isUncertainty = function(x) {
    return x instanceof Uncertainty;
  };

  module.exports.lessThan = function(a, b, precision) {
    if (precision == null) {
      precision = DateTime.Unit.MILLISECOND;
    }
    switch (false) {
      case !areNumbers(a, b):
        return a < b;
      case !areDateTimesOrQuantities(a, b):
        return a.before(b, precision);
      case !isUncertainty(a):
        return a.lessThan(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).lessThan(b);
      default:
        return null;
    }
  };

  module.exports.lessThanOrEquals = function(a, b, precision) {
    if (precision == null) {
      precision = DateTime.Unit.MILLISECOND;
    }
    switch (false) {
      case !areNumbers(a, b):
        return a <= b;
      case !areDateTimesOrQuantities(a, b):
        return a.sameOrBefore(b, precision);
      case !isUncertainty(a):
        return a.lessThanOrEquals(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).lessThanOrEquals(b);
      default:
        return null;
    }
  };

  module.exports.greaterThan = function(a, b, precision) {
    if (precision == null) {
      precision = DateTime.Unit.MILLISECOND;
    }
    switch (false) {
      case !areNumbers(a, b):
        return a > b;
      case !areDateTimesOrQuantities(a, b):
        return a.after(b, precision);
      case !isUncertainty(a):
        return a.greaterThan(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).greaterThan(b);
      default:
        return null;
    }
  };

  module.exports.greaterThanOrEquals = function(a, b, precision) {
    if (precision == null) {
      precision = DateTime.Unit.MILLISECOND;
    }
    switch (false) {
      case !areNumbers(a, b):
        return a >= b;
      case !areDateTimesOrQuantities(a, b):
        return a.sameOrAfter(b, precision);
      case !isUncertainty(a):
        return a.greaterThanOrEquals(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).greaterThanOrEquals(b);
      default:
        return null;
    }
  };

  module.exports.equals = equals = function(a, b) {
    var aClass, aKeys, bClass, bKeys, key, obj, ref, ref1;
    if ((a == null) || (b == null)) {
      return a === b;
    }
    if ((a != null ? (ref = a.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity') {
      return a.equals(b);
    }
    if (a instanceof Uncertainty) {
      b = Uncertainty.from(b);
    } else if (b instanceof Uncertainty) {
      a = Uncertainty.from(a);
    }
    if (typeof a.equals === 'function') {
      return a.equals(b);
    }
    if (a === b) {
      return true;
    }
    ref1 = (function() {
      var j, len, ref1, results;
      ref1 = [a, b];
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        obj = ref1[j];
        results.push({}.toString.call(obj));
      }
      return results;
    })(), aClass = ref1[0], bClass = ref1[1];
    if (aClass !== bClass) {
      return false;
    }
    switch (aClass) {
      case '[object Date]':
        return a.getTime() === b.getTime();
      case '[object RegExp]':
        return ['source', 'global', 'ignoreCase', 'multiline'].every(function(p) {
          return a[p] === b[p];
        });
      case '[object Array]':
        return a.length === b.length && a.every(function(item, i) {
          return equals(item, b[i]);
        });
      case '[object Object]':
        if (!(b instanceof a.constructor)) {
          return false;
        }
        aKeys = ((function() {
          var results;
          if (typeof key !== 'function') {
            results = [];
            for (key in a) {
              results.push(key);
            }
            return results;
          }
        })());
        bKeys = ((function() {
          var results;
          if (typeof key !== 'function') {
            results = [];
            for (key in b) {
              results.push(key);
            }
            return results;
          }
        })());
        return aKeys.length === bKeys.length && aKeys.every(function(key) {
          return equals(a[key], b[key]);
        });
    }
    return false;
  };

}).call(this);



},{"../datatypes/datetime":7,"../datatypes/uncertainty":11}],134:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var DateTime, Exception, MAX_DATE_VALUE, MAX_FLOAT_VALUE, MAX_INT_VALUE, MIN_DATE_VALUE, MIN_FLOAT_PRECISION_VALUE, MIN_FLOAT_VALUE, MIN_INT_VALUE, OverFlowException, Uncertainty, predecessor, successor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Exception = require('../datatypes/exception').Exception;

  DateTime = require('../datatypes/datetime').DateTime;

  Uncertainty = require('../datatypes/uncertainty').Uncertainty;

  module.exports.MAX_INT_VALUE = MAX_INT_VALUE = Math.pow(2, 31) - 1;

  module.exports.MIN_INT_VALUE = MIN_INT_VALUE = Math.pow(-2, 31);

  module.exports.MAX_FLOAT_VALUE = MAX_FLOAT_VALUE = (Math.pow(10, 37) - 1) / Math.pow(10, 8);

  module.exports.MIN_FLOAT_VALUE = MIN_FLOAT_VALUE = (Math.pow(-10, 37) + 1) / Math.pow(10, 8);

  module.exports.MIN_FLOAT_PRECISION_VALUE = MIN_FLOAT_PRECISION_VALUE = Math.pow(10, -8);

  module.exports.MIN_DATE_VALUE = MIN_DATE_VALUE = DateTime.parse("0001-01-01T00:00:00.000");

  module.exports.MAX_DATE_VALUE = MAX_DATE_VALUE = DateTime.parse("9999-12-31T23:59:59.999");

  module.exports.OverFlowException = OverFlowException = OverFlowException = (function(superClass) {
    extend(OverFlowException, superClass);

    function OverFlowException() {
      return OverFlowException.__super__.constructor.apply(this, arguments);
    }

    return OverFlowException;

  })(Exception);

  module.exports.successor = successor = function(val) {
    var e, high, ref, succ;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MAX_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val + 1;
        }
      } else {
        return val + MIN_FLOAT_PRECISION_VALUE;
      }
    } else if (val instanceof DateTime) {
      if (val.sameAs(MAX_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.successor();
      }
    } else if (val instanceof Uncertainty) {
      high = (function() {
        try {
          return successor(val.high);
        } catch (error) {
          e = error;
          return val.high;
        }
      })();
      return new Uncertainty(successor(val.low), high);
    } else if ((val != null ? (ref = val.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity') {
      succ = val.clone();
      succ.value = successor(val.value);
      return succ;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.predecessor = predecessor = function(val) {
    var e, low, pred, ref;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MIN_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val - 1;
        }
      } else {
        return val - MIN_FLOAT_PRECISION_VALUE;
      }
    } else if (val instanceof DateTime) {
      if (val.sameAs(MIN_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.predecessor();
      }
    } else if (val instanceof Uncertainty) {
      low = (function() {
        try {
          return predecessor(val.low);
        } catch (error) {
          e = error;
          return val.low;
        }
      })();
      return new Uncertainty(low, predecessor(val.high));
    } else if ((val != null ? (ref = val.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity') {
      pred = val.clone();
      pred.value = predecessor(val.value);
      return pred;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.maxValueForInstance = function(val) {
    var ref, val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MAX_INT_VALUE;
      } else {
        return MAX_FLOAT_VALUE;
      }
    } else if (val instanceof DateTime) {
      return MAX_DATE_VALUE;
    } else if ((val != null ? (ref = val.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity') {
      val2 = val.clone();
      val2.value = maxValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

  module.exports.minValueForInstance = function(val) {
    var ref, val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MIN_INT_VALUE;
      } else {
        return MIN_FLOAT_VALUE;
      }
    } else if (val instanceof DateTime) {
      return MIN_DATE_VALUE;
    } else if ((val != null ? (ref = val.constructor) != null ? ref.name : void 0 : void 0) === 'Quantity') {
      val2 = val.clone();
      val2.value = minValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

}).call(this);



},{"../datatypes/datetime":7,"../datatypes/exception":8,"../datatypes/uncertainty":11}],135:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var typeIsArray;

  module.exports.compact = function(things) {
    return things.filter(function(x) {
      return x != null;
    });
  };

  module.exports.numerical_sort = function(things, direction) {
    if (direction == null) {
      direction = "asc";
    }
    return things.sort(function(a, b) {
      if (direction === "asc") {
        return a - b;
      } else {
        return b - a;
      }
    });
  };

  module.exports.isNull = function(value) {
    return value === null;
  };

  module.exports.typeIsArray = typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  module.exports.allTrue = function(things) {
    if (typeIsArray(things)) {
      return things.every(function(x) {
        return x;
      });
    } else {
      return things;
    }
  };

  module.exports.anyTrue = function(things) {
    if (typeIsArray(things)) {
      return things.some(function(x) {
        return x;
      });
    } else {
      return things;
    }
  };

}).call(this);



},{}],136:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],137:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],138:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],139:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":138,"_process":136,"inherits":137}]},{},[38]);
