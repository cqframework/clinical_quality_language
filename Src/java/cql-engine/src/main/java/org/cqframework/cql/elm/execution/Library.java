//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.04.12 at 08:52:42 PM MDT 
//


package org.cqframework.cql.elm.execution;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * A Library is an instance of a CQL-ELM library. 
 * 
 * <p>Java class for Library complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Library"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{urn:hl7-org:elm:r1}Element"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="identifier" type="{urn:hl7-org:elm:r1}VersionedIdentifier"/&gt;
 *         &lt;element name="schemaIdentifier" type="{urn:hl7-org:elm:r1}VersionedIdentifier"/&gt;
 *         &lt;element name="usings" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}UsingDef" maxOccurs="unbounded"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="includes" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}IncludeDef" maxOccurs="unbounded"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="parameters" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}ParameterDef" maxOccurs="unbounded" minOccurs="0"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="codeSystems" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}CodeSystemDef" maxOccurs="unbounded" minOccurs="0"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="valueSets" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}ValueSetDef" maxOccurs="unbounded" minOccurs="0"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="statements" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="def" type="{urn:hl7-org:elm:r1}ExpressionDef" maxOccurs="unbounded" minOccurs="0"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Library", namespace = "urn:hl7-org:elm:r1", propOrder = {
    "identifier",
    "schemaIdentifier",
    "usings",
    "includes",
    "parameters",
    "codeSystems",
    "valueSets",
    "statements"
})
public class Library
    extends Element
    implements Equals, HashCode, ToString
{

    @XmlElement(namespace = "urn:hl7-org:elm:r1", required = true)
    protected VersionedIdentifier identifier;
    @XmlElement(namespace = "urn:hl7-org:elm:r1", required = true)
    protected VersionedIdentifier schemaIdentifier;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.Usings usings;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.Includes includes;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.Parameters parameters;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.CodeSystems codeSystems;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.ValueSets valueSets;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Library.Statements statements;

    /**
     * Gets the value of the identifier property.
     * 
     * @return
     *     possible object is
     *     {@link VersionedIdentifier }
     *     
     */
    public VersionedIdentifier getIdentifier() {
        return identifier;
    }

    /**
     * Sets the value of the identifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link VersionedIdentifier }
     *     
     */
    public void setIdentifier(VersionedIdentifier value) {
        this.identifier = value;
    }

    /**
     * Gets the value of the schemaIdentifier property.
     * 
     * @return
     *     possible object is
     *     {@link VersionedIdentifier }
     *     
     */
    public VersionedIdentifier getSchemaIdentifier() {
        return schemaIdentifier;
    }

    /**
     * Sets the value of the schemaIdentifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link VersionedIdentifier }
     *     
     */
    public void setSchemaIdentifier(VersionedIdentifier value) {
        this.schemaIdentifier = value;
    }

    /**
     * Gets the value of the usings property.
     * 
     * @return
     *     possible object is
     *     {@link Library.Usings }
     *     
     */
    public Library.Usings getUsings() {
        return usings;
    }

    /**
     * Sets the value of the usings property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.Usings }
     *     
     */
    public void setUsings(Library.Usings value) {
        this.usings = value;
    }

    /**
     * Gets the value of the includes property.
     * 
     * @return
     *     possible object is
     *     {@link Library.Includes }
     *     
     */
    public Library.Includes getIncludes() {
        return includes;
    }

    /**
     * Sets the value of the includes property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.Includes }
     *     
     */
    public void setIncludes(Library.Includes value) {
        this.includes = value;
    }

    /**
     * Gets the value of the parameters property.
     * 
     * @return
     *     possible object is
     *     {@link Library.Parameters }
     *     
     */
    public Library.Parameters getParameters() {
        return parameters;
    }

    /**
     * Sets the value of the parameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.Parameters }
     *     
     */
    public void setParameters(Library.Parameters value) {
        this.parameters = value;
    }

    /**
     * Gets the value of the codeSystems property.
     * 
     * @return
     *     possible object is
     *     {@link Library.CodeSystems }
     *     
     */
    public Library.CodeSystems getCodeSystems() {
        return codeSystems;
    }

    /**
     * Sets the value of the codeSystems property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.CodeSystems }
     *     
     */
    public void setCodeSystems(Library.CodeSystems value) {
        this.codeSystems = value;
    }

    /**
     * Gets the value of the valueSets property.
     * 
     * @return
     *     possible object is
     *     {@link Library.ValueSets }
     *     
     */
    public Library.ValueSets getValueSets() {
        return valueSets;
    }

    /**
     * Sets the value of the valueSets property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.ValueSets }
     *     
     */
    public void setValueSets(Library.ValueSets value) {
        this.valueSets = value;
    }

    /**
     * Gets the value of the statements property.
     * 
     * @return
     *     possible object is
     *     {@link Library.Statements }
     *     
     */
    public Library.Statements getStatements() {
        return statements;
    }

    /**
     * Sets the value of the statements property.
     * 
     * @param value
     *     allowed object is
     *     {@link Library.Statements }
     *     
     */
    public void setStatements(Library.Statements value) {
        this.statements = value;
    }

    public Library withIdentifier(VersionedIdentifier value) {
        setIdentifier(value);
        return this;
    }

    public Library withSchemaIdentifier(VersionedIdentifier value) {
        setSchemaIdentifier(value);
        return this;
    }

    public Library withUsings(Library.Usings value) {
        setUsings(value);
        return this;
    }

    public Library withIncludes(Library.Includes value) {
        setIncludes(value);
        return this;
    }

    public Library withParameters(Library.Parameters value) {
        setParameters(value);
        return this;
    }

    public Library withCodeSystems(Library.CodeSystems value) {
        setCodeSystems(value);
        return this;
    }

    public Library withValueSets(Library.ValueSets value) {
        setValueSets(value);
        return this;
    }

    public Library withStatements(Library.Statements value) {
        setStatements(value);
        return this;
    }

    @Override
    public Library withAnnotation(Object... values) {
        if (values!= null) {
            for (Object value: values) {
                getAnnotation().add(value);
            }
        }
        return this;
    }

    @Override
    public Library withAnnotation(Collection<Object> values) {
        if (values!= null) {
            getAnnotation().addAll(values);
        }
        return this;
    }

    @Override
    public Library withLocalId(String value) {
        setLocalId(value);
        return this;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof Library)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final Library that = ((Library) object);
        {
            VersionedIdentifier lhsIdentifier;
            lhsIdentifier = this.getIdentifier();
            VersionedIdentifier rhsIdentifier;
            rhsIdentifier = that.getIdentifier();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "identifier", lhsIdentifier), LocatorUtils.property(thatLocator, "identifier", rhsIdentifier), lhsIdentifier, rhsIdentifier)) {
                return false;
            }
        }
        {
            VersionedIdentifier lhsSchemaIdentifier;
            lhsSchemaIdentifier = this.getSchemaIdentifier();
            VersionedIdentifier rhsSchemaIdentifier;
            rhsSchemaIdentifier = that.getSchemaIdentifier();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "schemaIdentifier", lhsSchemaIdentifier), LocatorUtils.property(thatLocator, "schemaIdentifier", rhsSchemaIdentifier), lhsSchemaIdentifier, rhsSchemaIdentifier)) {
                return false;
            }
        }
        {
            Library.Usings lhsUsings;
            lhsUsings = this.getUsings();
            Library.Usings rhsUsings;
            rhsUsings = that.getUsings();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "usings", lhsUsings), LocatorUtils.property(thatLocator, "usings", rhsUsings), lhsUsings, rhsUsings)) {
                return false;
            }
        }
        {
            Library.Includes lhsIncludes;
            lhsIncludes = this.getIncludes();
            Library.Includes rhsIncludes;
            rhsIncludes = that.getIncludes();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "includes", lhsIncludes), LocatorUtils.property(thatLocator, "includes", rhsIncludes), lhsIncludes, rhsIncludes)) {
                return false;
            }
        }
        {
            Library.Parameters lhsParameters;
            lhsParameters = this.getParameters();
            Library.Parameters rhsParameters;
            rhsParameters = that.getParameters();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "parameters", lhsParameters), LocatorUtils.property(thatLocator, "parameters", rhsParameters), lhsParameters, rhsParameters)) {
                return false;
            }
        }
        {
            Library.CodeSystems lhsCodeSystems;
            lhsCodeSystems = this.getCodeSystems();
            Library.CodeSystems rhsCodeSystems;
            rhsCodeSystems = that.getCodeSystems();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "codeSystems", lhsCodeSystems), LocatorUtils.property(thatLocator, "codeSystems", rhsCodeSystems), lhsCodeSystems, rhsCodeSystems)) {
                return false;
            }
        }
        {
            Library.ValueSets lhsValueSets;
            lhsValueSets = this.getValueSets();
            Library.ValueSets rhsValueSets;
            rhsValueSets = that.getValueSets();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "valueSets", lhsValueSets), LocatorUtils.property(thatLocator, "valueSets", rhsValueSets), lhsValueSets, rhsValueSets)) {
                return false;
            }
        }
        {
            Library.Statements lhsStatements;
            lhsStatements = this.getStatements();
            Library.Statements rhsStatements;
            rhsStatements = that.getStatements();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "statements", lhsStatements), LocatorUtils.property(thatLocator, "statements", rhsStatements), lhsStatements, rhsStatements)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            VersionedIdentifier theIdentifier;
            theIdentifier = this.getIdentifier();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "identifier", theIdentifier), currentHashCode, theIdentifier);
        }
        {
            VersionedIdentifier theSchemaIdentifier;
            theSchemaIdentifier = this.getSchemaIdentifier();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "schemaIdentifier", theSchemaIdentifier), currentHashCode, theSchemaIdentifier);
        }
        {
            Library.Usings theUsings;
            theUsings = this.getUsings();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "usings", theUsings), currentHashCode, theUsings);
        }
        {
            Library.Includes theIncludes;
            theIncludes = this.getIncludes();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "includes", theIncludes), currentHashCode, theIncludes);
        }
        {
            Library.Parameters theParameters;
            theParameters = this.getParameters();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "parameters", theParameters), currentHashCode, theParameters);
        }
        {
            Library.CodeSystems theCodeSystems;
            theCodeSystems = this.getCodeSystems();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "codeSystems", theCodeSystems), currentHashCode, theCodeSystems);
        }
        {
            Library.ValueSets theValueSets;
            theValueSets = this.getValueSets();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "valueSets", theValueSets), currentHashCode, theValueSets);
        }
        {
            Library.Statements theStatements;
            theStatements = this.getStatements();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "statements", theStatements), currentHashCode, theStatements);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            VersionedIdentifier theIdentifier;
            theIdentifier = this.getIdentifier();
            strategy.appendField(locator, this, "identifier", buffer, theIdentifier);
        }
        {
            VersionedIdentifier theSchemaIdentifier;
            theSchemaIdentifier = this.getSchemaIdentifier();
            strategy.appendField(locator, this, "schemaIdentifier", buffer, theSchemaIdentifier);
        }
        {
            Library.Usings theUsings;
            theUsings = this.getUsings();
            strategy.appendField(locator, this, "usings", buffer, theUsings);
        }
        {
            Library.Includes theIncludes;
            theIncludes = this.getIncludes();
            strategy.appendField(locator, this, "includes", buffer, theIncludes);
        }
        {
            Library.Parameters theParameters;
            theParameters = this.getParameters();
            strategy.appendField(locator, this, "parameters", buffer, theParameters);
        }
        {
            Library.CodeSystems theCodeSystems;
            theCodeSystems = this.getCodeSystems();
            strategy.appendField(locator, this, "codeSystems", buffer, theCodeSystems);
        }
        {
            Library.ValueSets theValueSets;
            theValueSets = this.getValueSets();
            strategy.appendField(locator, this, "valueSets", buffer, theValueSets);
        }
        {
            Library.Statements theStatements;
            theStatements = this.getStatements();
            strategy.appendField(locator, this, "statements", buffer, theStatements);
        }
        return buffer;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}CodeSystemDef" maxOccurs="unbounded" minOccurs="0"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class CodeSystems
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1")
        protected List<CodeSystemDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CodeSystemDef }
         * 
         * 
         */
        public List<CodeSystemDef> getDef() {
            if (def == null) {
                def = new ArrayList<CodeSystemDef>();
            }
            return this.def;
        }

        public Library.CodeSystems withDef(CodeSystemDef... values) {
            if (values!= null) {
                for (CodeSystemDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.CodeSystems withDef(Collection<CodeSystemDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.CodeSystems)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.CodeSystems that = ((Library.CodeSystems) object);
            {
                List<CodeSystemDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<CodeSystemDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<CodeSystemDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<CodeSystemDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}IncludeDef" maxOccurs="unbounded"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class Includes
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1", required = true)
        protected List<IncludeDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link IncludeDef }
         * 
         * 
         */
        public List<IncludeDef> getDef() {
            if (def == null) {
                def = new ArrayList<IncludeDef>();
            }
            return this.def;
        }

        public Library.Includes withDef(IncludeDef... values) {
            if (values!= null) {
                for (IncludeDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.Includes withDef(Collection<IncludeDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.Includes)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.Includes that = ((Library.Includes) object);
            {
                List<IncludeDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<IncludeDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<IncludeDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<IncludeDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}ParameterDef" maxOccurs="unbounded" minOccurs="0"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class Parameters
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1")
        protected List<ParameterDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ParameterDef }
         * 
         * 
         */
        public List<ParameterDef> getDef() {
            if (def == null) {
                def = new ArrayList<ParameterDef>();
            }
            return this.def;
        }

        public Library.Parameters withDef(ParameterDef... values) {
            if (values!= null) {
                for (ParameterDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.Parameters withDef(Collection<ParameterDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.Parameters)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.Parameters that = ((Library.Parameters) object);
            {
                List<ParameterDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<ParameterDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<ParameterDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<ParameterDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}ExpressionDef" maxOccurs="unbounded" minOccurs="0"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class Statements
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1")
        protected List<ExpressionDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ExpressionDef }
         * 
         * 
         */
        public List<ExpressionDef> getDef() {
            if (def == null) {
                def = new ArrayList<ExpressionDef>();
            }
            return this.def;
        }

        public Library.Statements withDef(ExpressionDef... values) {
            if (values!= null) {
                for (ExpressionDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.Statements withDef(Collection<ExpressionDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.Statements)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.Statements that = ((Library.Statements) object);
            {
                List<ExpressionDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<ExpressionDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<ExpressionDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<ExpressionDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}UsingDef" maxOccurs="unbounded"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class Usings
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1", required = true)
        protected List<UsingDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link UsingDef }
         * 
         * 
         */
        public List<UsingDef> getDef() {
            if (def == null) {
                def = new ArrayList<UsingDef>();
            }
            return this.def;
        }

        public Library.Usings withDef(UsingDef... values) {
            if (values!= null) {
                for (UsingDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.Usings withDef(Collection<UsingDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.Usings)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.Usings that = ((Library.Usings) object);
            {
                List<UsingDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<UsingDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<UsingDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<UsingDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="def" type="{urn:hl7-org:elm:r1}ValueSetDef" maxOccurs="unbounded" minOccurs="0"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "def"
    })
    public static class ValueSets
        extends org.cqframework.cql.elm.execution.Executable
        implements Equals, HashCode, ToString
    {

        @XmlElement(namespace = "urn:hl7-org:elm:r1")
        protected List<ValueSetDef> def;

        /**
         * Gets the value of the def property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the def property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ValueSetDef }
         * 
         * 
         */
        public List<ValueSetDef> getDef() {
            if (def == null) {
                def = new ArrayList<ValueSetDef>();
            }
            return this.def;
        }

        public Library.ValueSets withDef(ValueSetDef... values) {
            if (values!= null) {
                for (ValueSetDef value: values) {
                    getDef().add(value);
                }
            }
            return this;
        }

        public Library.ValueSets withDef(Collection<ValueSetDef> values) {
            if (values!= null) {
                getDef().addAll(values);
            }
            return this;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof Library.ValueSets)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final Library.ValueSets that = ((Library.ValueSets) object);
            {
                List<ValueSetDef> lhsDef;
                lhsDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                List<ValueSetDef> rhsDef;
                rhsDef = (((that.def!= null)&&(!that.def.isEmpty()))?that.getDef():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "def", lhsDef), LocatorUtils.property(thatLocator, "def", rhsDef), lhsDef, rhsDef)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<ValueSetDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "def", theDef), currentHashCode, theDef);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<ValueSetDef> theDef;
                theDef = (((this.def!= null)&&(!this.def.isEmpty()))?this.getDef():null);
                strategy.appendField(locator, this, "def", buffer, theDef);
            }
            return buffer;
        }

    }

}
