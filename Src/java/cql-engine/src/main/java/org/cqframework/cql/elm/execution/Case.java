//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.04.12 at 08:52:42 PM MDT 
//


package org.cqframework.cql.elm.execution;

import org.apache.commons.lang3.NotImplementedException;
import org.cqframework.cql.execution.Context;
import org.jvnet.jaxb2_commons.lang.*;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;


/**
 * The Case operator allows for multiple conditional expressions to be chained together in a single expression, rather than having to nest multiple If operators. In addition, the comparand operand provides a variant on the case that allows a single value to be compared in each conditional.
 * 			
 * If a comparand is not provided, the type of each when element of the caseItems within the Case is expected to be boolean. If a comparand is provided, the type of each when element of the caseItems within the Case is expected to be of the same type as the comparand. An else element must always be provided.
 * 
 * The static type of the then argument within the first caseItem determines the type of the result, and the then argument of each subsequent caseItem and the else argument must be of that same type.
 * 
 * <p>Java class for Case complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Case"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{urn:hl7-org:elm:r1}Expression"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="comparand" type="{urn:hl7-org:elm:r1}Expression" minOccurs="0"/&gt;
 *         &lt;element name="caseItem" type="{urn:hl7-org:elm:r1}CaseItem" maxOccurs="unbounded"/&gt;
 *         &lt;element name="else" type="{urn:hl7-org:elm:r1}Expression"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Case", namespace = "urn:hl7-org:elm:r1", propOrder = {
    "comparand",
    "caseItem",
    "_else"
})
public class Case
    extends Expression
    implements Equals, HashCode, ToString
{

    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Expression comparand;
    @XmlElement(namespace = "urn:hl7-org:elm:r1", required = true)
    protected List<CaseItem> caseItem;
    @XmlElement(name = "else", namespace = "urn:hl7-org:elm:r1", required = true)
    protected Expression _else;

    /**
     * Gets the value of the comparand property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getComparand() {
        return comparand;
    }

    /**
     * Sets the value of the comparand property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setComparand(Expression value) {
        this.comparand = value;
    }

    /**
     * Gets the value of the caseItem property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the caseItem property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCaseItem().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CaseItem }
     * 
     * 
     */
    public List<CaseItem> getCaseItem() {
        if (caseItem == null) {
            caseItem = new ArrayList<CaseItem>();
        }
        return this.caseItem;
    }

    /**
     * Gets the value of the else property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getElse() {
        return _else;
    }

    /**
     * Sets the value of the else property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setElse(Expression value) {
        this._else = value;
    }

    public Case withComparand(Expression value) {
        setComparand(value);
        return this;
    }

    public Case withCaseItem(CaseItem... values) {
        if (values!= null) {
            for (CaseItem value: values) {
                getCaseItem().add(value);
            }
        }
        return this;
    }

    public Case withCaseItem(Collection<CaseItem> values) {
        if (values!= null) {
            getCaseItem().addAll(values);
        }
        return this;
    }

    public Case withElse(Expression value) {
        setElse(value);
        return this;
    }

    @Override
    public Case withAnnotation(Object... values) {
        if (values!= null) {
            for (Object value: values) {
                getAnnotation().add(value);
            }
        }
        return this;
    }

    @Override
    public Case withAnnotation(Collection<Object> values) {
        if (values!= null) {
            getAnnotation().addAll(values);
        }
        return this;
    }

    @Override
    public Case withLocalId(String value) {
        setLocalId(value);
        return this;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof Case)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final Case that = ((Case) object);
        {
            Expression lhsComparand;
            lhsComparand = this.getComparand();
            Expression rhsComparand;
            rhsComparand = that.getComparand();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "comparand", lhsComparand), LocatorUtils.property(thatLocator, "comparand", rhsComparand), lhsComparand, rhsComparand)) {
                return false;
            }
        }
        {
            List<CaseItem> lhsCaseItem;
            lhsCaseItem = (((this.caseItem!= null)&&(!this.caseItem.isEmpty()))?this.getCaseItem():null);
            List<CaseItem> rhsCaseItem;
            rhsCaseItem = (((that.caseItem!= null)&&(!that.caseItem.isEmpty()))?that.getCaseItem():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "caseItem", lhsCaseItem), LocatorUtils.property(thatLocator, "caseItem", rhsCaseItem), lhsCaseItem, rhsCaseItem)) {
                return false;
            }
        }
        {
            Expression lhsElse;
            lhsElse = this.getElse();
            Expression rhsElse;
            rhsElse = that.getElse();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "_else", lhsElse), LocatorUtils.property(thatLocator, "_else", rhsElse), lhsElse, rhsElse)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            Expression theComparand;
            theComparand = this.getComparand();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "comparand", theComparand), currentHashCode, theComparand);
        }
        {
            List<CaseItem> theCaseItem;
            theCaseItem = (((this.caseItem!= null)&&(!this.caseItem.isEmpty()))?this.getCaseItem():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "caseItem", theCaseItem), currentHashCode, theCaseItem);
        }
        {
            Expression theElse;
            theElse = this.getElse();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "_else", theElse), currentHashCode, theElse);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            Expression theComparand;
            theComparand = this.getComparand();
            strategy.appendField(locator, this, "comparand", buffer, theComparand);
        }
        {
            List<CaseItem> theCaseItem;
            theCaseItem = (((this.caseItem!= null)&&(!this.caseItem.isEmpty()))?this.getCaseItem():null);
            strategy.appendField(locator, this, "caseItem", buffer, theCaseItem);
        }
        {
            Expression theElse;
            theElse = this.getElse();
            strategy.appendField(locator, this, "_else", buffer, theElse);
        }
        return buffer;
    }

    @Override
    public Object evaluate(Context context) {
        throw new NotImplementedException("Evaluate not implemented.");
    }
}
