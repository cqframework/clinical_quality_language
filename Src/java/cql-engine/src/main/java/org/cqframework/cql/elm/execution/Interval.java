//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.04.12 at 08:52:42 PM MDT 
//


package org.cqframework.cql.elm.execution;

import java.util.Collection;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * The Interval selector defines an interval value. An interval must be defined using a point type that supports comparison, as well as Successor and Predecessor operations, and Minimum and Maximum Value operations.
 * 			
 * The low and high bounds of the interval may each be defined as open or closed. Following standard terminology usage in interval mathematics, an open interval is defined to exclude the specified point, whereas a closed interval includes the point. The default is closed, indicating an inclusive interval.
 * 
 * The low and high elements are both optional. If the low element is not specified, the low bound of the resulting interval is null. If the high element is not specified, the high bound of the resulting interval is null.
 * 
 * The static type of the low bound determines the type of the interval, and the high bound must be of the same type.
 * 
 * If the low bound of the interval is null and open, the low bound of the interval is interpreted as unknown, and computations involving the low boundary will result in null.
 * 
 * If the low bound of the interval is null and closed, the interval is interpreted to start at the minimum value of the point type, and computations involving the low boundary will be performed with that value.
 * 
 * If the high bound of the interval is null and open, the high bound of the interval is unknown, and computations involving the high boundary will result in null. 
 * 
 * If the high bound of the interval is null and closed, the interval is interpreted to end at the maximum value of the point type, and computations involving the high boundary will be performed with that interpretation.
 * 
 * <p>Java class for Interval complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Interval"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{urn:hl7-org:elm:r1}Expression"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="low" type="{urn:hl7-org:elm:r1}Expression" minOccurs="0"/&gt;
 *         &lt;element name="lowClosedExpression" type="{urn:hl7-org:elm:r1}Expression" minOccurs="0"/&gt;
 *         &lt;element name="high" type="{urn:hl7-org:elm:r1}Expression" minOccurs="0"/&gt;
 *         &lt;element name="highClosedExpression" type="{urn:hl7-org:elm:r1}Expression" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="lowClosed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" /&gt;
 *       &lt;attribute name="highClosed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Interval", namespace = "urn:hl7-org:elm:r1", propOrder = {
    "low",
    "lowClosedExpression",
    "high",
    "highClosedExpression"
})
public class Interval
    extends Expression
    implements Equals, HashCode, ToString
{

    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Expression low;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Expression lowClosedExpression;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Expression high;
    @XmlElement(namespace = "urn:hl7-org:elm:r1")
    protected Expression highClosedExpression;
    @XmlAttribute(name = "lowClosed")
    protected Boolean lowClosed;
    @XmlAttribute(name = "highClosed")
    protected Boolean highClosed;

    /**
     * Gets the value of the low property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getLow() {
        return low;
    }

    /**
     * Sets the value of the low property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setLow(Expression value) {
        this.low = value;
    }

    /**
     * Gets the value of the lowClosedExpression property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getLowClosedExpression() {
        return lowClosedExpression;
    }

    /**
     * Sets the value of the lowClosedExpression property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setLowClosedExpression(Expression value) {
        this.lowClosedExpression = value;
    }

    /**
     * Gets the value of the high property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getHigh() {
        return high;
    }

    /**
     * Sets the value of the high property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setHigh(Expression value) {
        this.high = value;
    }

    /**
     * Gets the value of the highClosedExpression property.
     * 
     * @return
     *     possible object is
     *     {@link Expression }
     *     
     */
    public Expression getHighClosedExpression() {
        return highClosedExpression;
    }

    /**
     * Sets the value of the highClosedExpression property.
     * 
     * @param value
     *     allowed object is
     *     {@link Expression }
     *     
     */
    public void setHighClosedExpression(Expression value) {
        this.highClosedExpression = value;
    }

    /**
     * Gets the value of the lowClosed property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isLowClosed() {
        if (lowClosed == null) {
            return true;
        } else {
            return lowClosed;
        }
    }

    /**
     * Sets the value of the lowClosed property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setLowClosed(Boolean value) {
        this.lowClosed = value;
    }

    /**
     * Gets the value of the highClosed property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isHighClosed() {
        if (highClosed == null) {
            return true;
        } else {
            return highClosed;
        }
    }

    /**
     * Sets the value of the highClosed property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setHighClosed(Boolean value) {
        this.highClosed = value;
    }

    public Interval withLow(Expression value) {
        setLow(value);
        return this;
    }

    public Interval withLowClosedExpression(Expression value) {
        setLowClosedExpression(value);
        return this;
    }

    public Interval withHigh(Expression value) {
        setHigh(value);
        return this;
    }

    public Interval withHighClosedExpression(Expression value) {
        setHighClosedExpression(value);
        return this;
    }

    public Interval withLowClosed(Boolean value) {
        setLowClosed(value);
        return this;
    }

    public Interval withHighClosed(Boolean value) {
        setHighClosed(value);
        return this;
    }

    @Override
    public Interval withAnnotation(Object... values) {
        if (values!= null) {
            for (Object value: values) {
                getAnnotation().add(value);
            }
        }
        return this;
    }

    @Override
    public Interval withAnnotation(Collection<Object> values) {
        if (values!= null) {
            getAnnotation().addAll(values);
        }
        return this;
    }

    @Override
    public Interval withLocalId(String value) {
        setLocalId(value);
        return this;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof Interval)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final Interval that = ((Interval) object);
        {
            Expression lhsLow;
            lhsLow = this.getLow();
            Expression rhsLow;
            rhsLow = that.getLow();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "low", lhsLow), LocatorUtils.property(thatLocator, "low", rhsLow), lhsLow, rhsLow)) {
                return false;
            }
        }
        {
            Expression lhsLowClosedExpression;
            lhsLowClosedExpression = this.getLowClosedExpression();
            Expression rhsLowClosedExpression;
            rhsLowClosedExpression = that.getLowClosedExpression();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "lowClosedExpression", lhsLowClosedExpression), LocatorUtils.property(thatLocator, "lowClosedExpression", rhsLowClosedExpression), lhsLowClosedExpression, rhsLowClosedExpression)) {
                return false;
            }
        }
        {
            Expression lhsHigh;
            lhsHigh = this.getHigh();
            Expression rhsHigh;
            rhsHigh = that.getHigh();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "high", lhsHigh), LocatorUtils.property(thatLocator, "high", rhsHigh), lhsHigh, rhsHigh)) {
                return false;
            }
        }
        {
            Expression lhsHighClosedExpression;
            lhsHighClosedExpression = this.getHighClosedExpression();
            Expression rhsHighClosedExpression;
            rhsHighClosedExpression = that.getHighClosedExpression();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "highClosedExpression", lhsHighClosedExpression), LocatorUtils.property(thatLocator, "highClosedExpression", rhsHighClosedExpression), lhsHighClosedExpression, rhsHighClosedExpression)) {
                return false;
            }
        }
        {
            boolean lhsLowClosed;
            lhsLowClosed = ((this.lowClosed!= null)?this.isLowClosed():false);
            boolean rhsLowClosed;
            rhsLowClosed = ((that.lowClosed!= null)?that.isLowClosed():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "lowClosed", lhsLowClosed), LocatorUtils.property(thatLocator, "lowClosed", rhsLowClosed), lhsLowClosed, rhsLowClosed)) {
                return false;
            }
        }
        {
            boolean lhsHighClosed;
            lhsHighClosed = ((this.highClosed!= null)?this.isHighClosed():false);
            boolean rhsHighClosed;
            rhsHighClosed = ((that.highClosed!= null)?that.isHighClosed():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "highClosed", lhsHighClosed), LocatorUtils.property(thatLocator, "highClosed", rhsHighClosed), lhsHighClosed, rhsHighClosed)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            Expression theLow;
            theLow = this.getLow();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "low", theLow), currentHashCode, theLow);
        }
        {
            Expression theLowClosedExpression;
            theLowClosedExpression = this.getLowClosedExpression();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lowClosedExpression", theLowClosedExpression), currentHashCode, theLowClosedExpression);
        }
        {
            Expression theHigh;
            theHigh = this.getHigh();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "high", theHigh), currentHashCode, theHigh);
        }
        {
            Expression theHighClosedExpression;
            theHighClosedExpression = this.getHighClosedExpression();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "highClosedExpression", theHighClosedExpression), currentHashCode, theHighClosedExpression);
        }
        {
            boolean theLowClosed;
            theLowClosed = ((this.lowClosed!= null)?this.isLowClosed():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lowClosed", theLowClosed), currentHashCode, theLowClosed);
        }
        {
            boolean theHighClosed;
            theHighClosed = ((this.highClosed!= null)?this.isHighClosed():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "highClosed", theHighClosed), currentHashCode, theHighClosed);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            Expression theLow;
            theLow = this.getLow();
            strategy.appendField(locator, this, "low", buffer, theLow);
        }
        {
            Expression theLowClosedExpression;
            theLowClosedExpression = this.getLowClosedExpression();
            strategy.appendField(locator, this, "lowClosedExpression", buffer, theLowClosedExpression);
        }
        {
            Expression theHigh;
            theHigh = this.getHigh();
            strategy.appendField(locator, this, "high", buffer, theHigh);
        }
        {
            Expression theHighClosedExpression;
            theHighClosedExpression = this.getHighClosedExpression();
            strategy.appendField(locator, this, "highClosedExpression", buffer, theHighClosedExpression);
        }
        {
            boolean theLowClosed;
            theLowClosed = ((this.lowClosed!= null)?this.isLowClosed():false);
            strategy.appendField(locator, this, "lowClosed", buffer, theLowClosed);
        }
        {
            boolean theHighClosed;
            theHighClosed = ((this.highClosed!= null)?this.isHighClosed():false);
            strategy.appendField(locator, this, "highClosed", buffer, theHighClosed);
        }
        return buffer;
    }

}
