<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:CalculateAgeAtEvaluator.kt$CalculateAgeAtEvaluator$(birthDate is Date &amp;&amp; asOf is Date) || (birthDate is DateTime &amp;&amp; asOf is DateTime)</ID>
    <ID>ComplexCondition:ChildrenEvaluator.kt$ChildrenEvaluator$source is Int || source is BigDecimal || source is String || source is Boolean</ID>
    <ID>ComplexCondition:Code.kt$Code$codeIsEqual == null || systemIsEqual == null || versionIsEqual == null || displayIsEqual == null</ID>
    <ID>ComplexCondition:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$argument is String || argument is Ratio || argument is BigDecimal || argument is Int</ID>
    <ID>ComplexCondition:ConvertsToStringEvaluator.kt$ConvertsToStringEvaluator$argument is Boolean || argument is Int || argument is Long || argument is BigDecimal || argument is Quantity || argument is Ratio || argument is Date || argument is DateTime || argument is String || argument is Time</ID>
    <ID>ComplexCondition:EqualEvaluator.kt$EqualEvaluator$left is Boolean || left is Int || left is Long || left is String</ID>
    <ID>ComplexCondition:ExceptEvaluator.kt$ExceptEvaluator$leftStart == null || leftEnd == null || rightStart == null || rightEnd == null</ID>
    <ID>ComplexCondition:GreaterOrEqualEvaluator.kt$GreaterOrEqualEvaluator$(left is Interval &amp;&amp; right is Int) || (left is Int &amp;&amp; right is Interval)</ID>
    <ID>ComplexCondition:IncludedInEvaluator.kt$IncludedInEvaluator$leftStart is BaseTemporal || leftEnd is BaseTemporal || rightStart is BaseTemporal || rightEnd is BaseTemporal</ID>
    <ID>ComplexCondition:LessOrEqualEvaluator.kt$LessOrEqualEvaluator$(left is Interval &amp;&amp; right is Int) || (left is Int &amp;&amp; right is Interval)</ID>
    <ID>ComplexCondition:NodeMatcher.kt$NodeMatcher$!(this.contextMatcher.matches(node.context) &amp;&amp; this.countMatcher.matches(node.count) &amp;&amp; this.timeMatcher.matches(node.time) &amp;&amp; this.missesMatcher.matches(node.misses))</ID>
    <ID>ComplexCondition:PredecessorEvaluator.kt$PredecessorEvaluator$t.time.getHour() == 0 &amp;&amp; t.time.getMinute() == 0 &amp;&amp; t.time.getSecond() == 0 &amp;&amp; t.time.get(Precision.MILLISECOND.toChronoField()) == 0</ID>
    <ID>ComplexCondition:ProductEvaluator.kt$ProductEvaluator$(element is Int &amp;&amp; result is Int) || (element is Long &amp;&amp; result is Long) || (element is BigDecimal &amp;&amp; result is BigDecimal)</ID>
    <ID>ComplexCondition:ProperIncludesEvaluator.kt$ProperIncludesEvaluator$leftStart is BaseTemporal || leftEnd is BaseTemporal || rightStart is BaseTemporal || rightEnd is BaseTemporal</ID>
    <ID>ComplexCondition:QueryEvaluator.kt$QueryEvaluator$(relationship is With &amp;&amp; !hasSatisfyingData) || (relationship is Without &amp;&amp; hasSatisfyingData)</ID>
    <ID>ComplexCondition:SameAsEvaluator.kt$SameAsEvaluator$leftStart is BaseTemporal &amp;&amp; leftEnd is BaseTemporal &amp;&amp; rightStart is BaseTemporal &amp;&amp; rightEnd is BaseTemporal</ID>
    <ID>ComplexCondition:SuccessorEvaluator.kt$SuccessorEvaluator$t.time.getHour() == 23 &amp;&amp; t.time.getMinute() == 59 &amp;&amp; t.time.getSecond() == 59 &amp;&amp; t.time.get(Precision.MILLISECOND.toChronoField()) == 999</ID>
    <ID>ComplexCondition:ToBooleanEvaluator.kt$ToBooleanEvaluator$compare == "false" || compare == "f" || compare == "no" || compare == "n" || compare == "0"</ID>
    <ID>ComplexCondition:ToBooleanEvaluator.kt$ToBooleanEvaluator$compare == "true" || compare == "t" || compare == "yes" || compare == "y" || compare == "1"</ID>
    <ID>ComplexCondition:UnionEvaluator.kt$UnionEvaluator$leftStart == null || leftEnd == null || rightStart == null || rightEnd == null</ID>
    <ID>ComplexCondition:ValueSet.kt$ValueSet$id == cs.id &amp;&amp; ((version == null &amp;&amp; cs.version == null) || (version != null &amp;&amp; version == cs.version))</ID>
    <ID>CyclomaticComplexMethod:AddEvaluator.kt$AddEvaluator$@JvmStatic fun add(left: Any?, right: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:Code.kt$Code$override fun equal(other: Any?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:CollapseEvaluator.kt$CollapseEvaluator$fun collapse(list: Iterable&lt;Interval?>?, per: Quantity?, state: State?): List&lt;Interval?>?</ID>
    <ID>CyclomaticComplexMethod:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$@JvmStatic fun difference(left: Any?, right: Any?, precision: Precision): Any?</ID>
    <ID>CyclomaticComplexMethod:DurationBetweenEvaluator.kt$DurationBetweenEvaluator$@JvmStatic fun duration(left: Any?, right: Any?, precision: Precision?): Any?</ID>
    <ID>CyclomaticComplexMethod:EqualEvaluator.kt$EqualEvaluator$@JvmStatic @JvmOverloads fun equal(left: Any?, right: Any?, state: State? = null): Boolean?</ID>
    <ID>CyclomaticComplexMethod:EquivalentEvaluator.kt$EquivalentEvaluator$@JvmStatic @JvmOverloads fun equivalent(left: Any?, right: Any?, state: State? = null): Boolean?</ID>
    <ID>CyclomaticComplexMethod:ExceptEvaluator.kt$ExceptEvaluator$@JvmStatic fun except(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>CyclomaticComplexMethod:GreaterEvaluator.kt$GreaterEvaluator$@JvmStatic fun greater(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:GreaterOrEqualEvaluator.kt$GreaterOrEqualEvaluator$@JvmStatic fun greaterOrEqual(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:HighBoundaryEvaluator.kt$HighBoundaryEvaluator$@JvmStatic fun highBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:IntersectEvaluator.kt$IntersectEvaluator$@JvmStatic fun intersect(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>CyclomaticComplexMethod:LessEvaluator.kt$LessEvaluator$@JvmStatic fun less(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:LessOrEqualEvaluator.kt$LessOrEqualEvaluator$@JvmStatic fun lessOrEqual(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:LowBoundaryEvaluator.kt$LowBoundaryEvaluator$@JvmStatic fun lowBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:MeetsEvaluator.kt$MeetsEvaluator$fun meetsOperation(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:MultiplyEvaluator.kt$MultiplyEvaluator$@JvmStatic fun multiply(left: Any?, right: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:PredecessorEvaluator.kt$PredecessorEvaluator$@JvmStatic fun predecessor(value: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:ProductEvaluator.kt$ProductEvaluator$@JvmStatic fun product(source: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:ProperContainsEvaluator.kt$ProperContainsEvaluator$fun properContains(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:Quantity.kt$Quantity.Companion$fun unitsEqual(leftUnit: String?, rightUnit: String?): Boolean</ID>
    <ID>CyclomaticComplexMethod:Quantity.kt$Quantity.Companion$fun unitsEquivalent(leftUnit: String?, rightUnit: String?): Boolean</ID>
    <ID>CyclomaticComplexMethod:QueryEvaluator.kt$QueryEvaluator$fun internalEvaluate( elm: Query, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>CyclomaticComplexMethod:SameAsEvaluator.kt$SameAsEvaluator$@JvmStatic fun sameAs(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:SubtractEvaluator.kt$SubtractEvaluator$@JvmStatic fun subtract(left: Any?, right: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:SuccessorEvaluator.kt$SuccessorEvaluator$@JvmStatic fun successor(value: Any?): Any?</ID>
    <ID>CyclomaticComplexMethod:TemporalHelper.kt$TemporalHelper$fun truncateValueToTargetPrecision( value: Long, precision: Precision, targetPrecision: Precision?, ): Long</ID>
    <ID>CyclomaticComplexMethod:ToBooleanEvaluator.kt$ToBooleanEvaluator$@JvmStatic fun toBoolean(operand: Any?): Any?</ID>
    <ID>EmptyIfBlock:PropertyEvaluator.kt$PropertyEvaluator${}</ID>
    <ID>ForbiddenComment:CachingModelResolverDecoratorTest.kt$CachingModelResolverDecoratorTest$// TODO: Extend testing to cover more of the CachedModelResolver</ID>
    <ID>ForbiddenComment:ChildrenEvaluator.kt$ChildrenEvaluator$// TODO: Intervals and Tuples?</ID>
    <ID>ForbiddenComment:CqlDateTimeOperatorsTest.kt$CqlDateTimeOperatorsTest$// TODO: uncomment once Time(x,x,x,x,x) format is fixed</ID>
    <ID>ForbiddenComment:CqlEngine.kt$CqlEngine$// TODO: Add debugging info as a parameter.</ID>
    <ID>ForbiddenComment:CqlEngine.kt$CqlEngine$// TODO: Smarter validation would be to checkout and see if any retrieves</ID>
    <ID>ForbiddenComment:CqlEngine.kt$CqlEngine$// TODO: Validate Expressions as well?</ID>
    <ID>ForbiddenComment:CqlEngine.kt$CqlEngine$// TODO: What we actually need here is a check of the actual retrieves, based on data</ID>
    <ID>ForbiddenComment:CqlMainSuiteTest.kt$CqlMainSuiteTest$// TODO: It'd be interesting to be able to inspect the</ID>
    <ID>ForbiddenComment:CqlPerformanceIT.kt$CqlPerformanceIT$// TODO: Ratio type not implemented error</ID>
    <ID>ForbiddenComment:DateTimeTest.kt$DateTimeTest$// TODO: It'd be good to extend these across different types of constructors, for example,</ID>
    <ID>ForbiddenComment:DivideEvaluator.kt$DivideEvaluator$/* /(left Decimal, right Decimal) Decimal /(left Quantity, right Decimal) Quantity /(left Quantity, right Quantity) Quantity The divide (/) operator performs numeric division of its arguments. Note that this operator is Decimal division; for Integer division, use the truncated divide (div) operator. When invoked with Integer arguments, the arguments will be implicitly converted to Decimal. TODO: For division operations involving quantities, the resulting quantity will have the appropriate unit. For example: 12 'cm2' / 3 'cm' In this example, the result will have a unit of 'cm'. If either argument is null, the result is null. */</ID>
    <ID>ForbiddenComment:Environment.kt$Environment$// TODO: Path may include .'s and []'s.</ID>
    <ID>ForbiddenComment:Environment.kt$Environment$// TODO: This doesn't allow for choice-distinguished overloads...</ID>
    <ID>ForbiddenComment:Environment.kt$Environment$// TODO: This doesn't allow for interval-distinguished overloads</ID>
    <ID>ForbiddenComment:Environment.kt$Environment$// TODO: This doesn't allow for list-distinguished overloads...</ID>
    <ID>ForbiddenComment:Environment.kt$Environment$// TODO: This doesn't allow for tuple-distinguished overloads....</ID>
    <ID>ForbiddenComment:FilterEvaluator.kt$FilterEvaluator$// TODO: verify this works for all cases -> will scope always be present?</ID>
    <ID>ForbiddenComment:GeometricMeanEvaluator.kt$GeometricMeanEvaluator$// remove nulls - operation is on non-null list elements ... TODO: generify and move this to</ID>
    <ID>ForbiddenComment:IntervalEvaluator.kt$IntervalEvaluator$// TODO: the spec states that it is possible to have an interval with null boundaries, but</ID>
    <ID>ForbiddenComment:ListOperatorsTest.kt$ListOperatorsTest$// TODO: fix test - going to ContainsEvaluator</ID>
    <ID>ForbiddenComment:ListOperatorsTest.kt$ListOperatorsTest$// TODO: fix test - going to InEvaluator</ID>
    <ID>ForbiddenComment:MultiplyEvaluator.kt$MultiplyEvaluator$/* *(left Integer, right Integer) Integer *(left Long, right Long) Long *(left Decimal, right Decimal) Decimal *(left Decimal, right Quantity) Quantity *(left Quantity, right Decimal) Quantity *(left Quantity, right Quantity) Quantity The multiply (*) operator performs numeric multiplication of its arguments. When invoked with mixed Integer and Decimal arguments, the Integer argument will be implicitly converted to Decimal. TODO: For multiplication operations involving quantities, the resulting quantity will have the appropriate unit. For example: 12 'cm' * 3 'cm' 3 'cm' * 12 'cm2' In this example, the first result will have a unit of 'cm2', and the second result will have a unit of 'cm3'. If either argument is null, the result is null. */</ID>
    <ID>ForbiddenComment:MultiplyEvaluator.kt$MultiplyEvaluator$// TODO: unit multiplication i.e. cm*cm = cm^2</ID>
    <ID>ForbiddenComment:NodeMatcher.kt$NodeMatcher$// TODO: should we ensure that there are no extra children in the node?</ID>
    <ID>ForbiddenComment:ProfilingTest.kt$ProfilingTest$// TODO: engine options to CqlTestBase.getEngine instead?</ID>
    <ID>ForbiddenComment:QueryEvaluator.kt$QueryEvaluator$// TODO: This is the most naive possible implementation here, but it should</ID>
    <ID>ForbiddenComment:RetrieveEvaluator.kt$RetrieveEvaluator$// TODO: We probably shouldn't eagerly load this, but we need to track</ID>
    <ID>ForbiddenComment:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$// TODO: Support adding more functions to an existing provider object.</ID>
    <ID>ForbiddenComment:TerminologyAwareRetrieveProvider.kt$TerminologyAwareRetrieveProvider$// TODO: Think about how to best handle the decision to expand value sets... Should it be part</ID>
    <ID>FunctionNaming:Environment.kt$Environment$fun `as`(operand: Any?, type: Class&lt;*>, isStrict: Boolean): Any?</ID>
    <ID>FunctionNaming:Environment.kt$Environment$fun `is`(operand: Any?, type: Class&lt;*>): Boolean?</ID>
    <ID>FunctionNaming:InEvaluator.kt$InEvaluator$fun `in`(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>FunctionNaming:ModelResolver.kt$ModelResolver$fun `as`(value: Any?, type: Class&lt;*>?, isStrict: Boolean): Any?</ID>
    <ID>FunctionNaming:ModelResolver.kt$ModelResolver$fun `is`(value: Any?, type: Class&lt;*>?): Boolean?</ID>
    <ID>FunctionNaming:TerminologyProvider.kt$TerminologyProvider$fun `in`(code: Code, valueSet: ValueSetInfo): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:NullEvaluator.kt$NullEvaluator$@JvmStatic fun internalEvaluate(state: State?): Any?</ID>
    <ID>FunctionParameterNaming:AsEvaluator.kt$AsEvaluator$`as`: As</ID>
    <ID>FunctionParameterNaming:IsEvaluator.kt$IsEvaluator$`is`: Is?</ID>
    <ID>ImplicitDefaultLocale:CqlEngine.kt$CqlEngine$String.format( "Library %s has terminology requirements and no terminology provider is registered.", this.getLibraryDescription(library.identifier!!), )</ID>
    <ID>ImplicitDefaultLocale:CqlEngine.kt$CqlEngine$String.format( "Unable to load library %s", libraryIdentifier.id + (if (libraryIdentifier.version != null) "-" + libraryIdentifier.version else ""), )</ID>
    <ID>ImplicitDefaultLocale:CqlEngine.kt$CqlEngine$String.format( "library %s loaded, but had errors: %s", libraryIdentifier.id + (if (libraryIdentifier.version != null) "-" + libraryIdentifier.version else ""), errors.joinToString(",") { obj -> obj.message ?: "" }, )</ID>
    <ID>ImplicitDefaultLocale:CqlEngine.kt$CqlEngine$String.format("Error evaluating expression %s: %s", expression, e.message)</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format( "400: This source should be redacted%n%s", RedactingPHIObfuscator.REDACTED_MESSAGE, )</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format("1: This is a message%n")</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format("1: This is a message%nnull")</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format("1: null%n")</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format("400: This is an error!%n")</ID>
    <ID>ImplicitDefaultLocale:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$String.format("This is a message%n")</ID>
    <ID>ImplicitDefaultLocale:CqlMainSuiteTest.kt$CqlMainSuiteTest$String.format( "Test library compiled with the following errors : %s", this.toString(errors), )</ID>
    <ID>ImplicitDefaultLocale:CqlPerformanceIT.kt$CqlPerformanceIT$String.format( "%s took longer per iteration than allowed. max: %3.2f, actual: %3.2f", libraryId.id, maxPerIterationMs, perIteration, )</ID>
    <ID>ImplicitDefaultLocale:ListOperatorsTest.kt$ListOperatorsTest$String.format( "Test library compiled with the following errors : %s", this.toString(errors), )</ID>
    <ID>ImplicitDefaultLocale:NodeMatcher.kt$NodeMatcher$String.format("\n %s -> ", expressionName)</ID>
    <ID>ImplicitDefaultLocale:NodeMatcher.kt$NodeMatcher$String.format("\n in context %s", contextName)</ID>
    <ID>ImplicitDefaultLocale:TestLibrarySourceProvider.kt$TestLibrarySourceProvider$String.format( "%s%s.cql", Optional.ofNullable&lt;String?>(subfolder) .map(Function { nonNull -> "$nonNull/" }) .orElse(""), libraryIdentifier.id, )</ID>
    <ID>IteratorNotThrowingNoSuchElementException:QueryIterator.kt$QueryIterator : Iterator</ID>
    <ID>IteratorNotThrowingNoSuchElementException:ResetIterator.kt$ResetIterator&lt;E> : Iterator</ID>
    <ID>IteratorNotThrowingNoSuchElementException:TimesIterator.kt$TimesIterator : Iterator</ID>
    <ID>LargeClass:EvaluationVisitor.kt$EvaluationVisitor : BaseElmLibraryVisitor</ID>
    <ID>LargeClass:IntervalOperatorsTest.kt$IntervalOperatorsTest : CqlTestBase</ID>
    <ID>LargeClass:ListOperatorsTest.kt$ListOperatorsTest : CqlTestBase</ID>
    <ID>LongMethod:AddEvaluator.kt$AddEvaluator$@JvmStatic fun add(left: Any?, right: Any?): Any?</ID>
    <ID>LongMethod:BacktraceTest.kt$BacktraceTest$@Test fun backtrace_smoke()</ID>
    <ID>LongMethod:CollapseEvaluator.kt$CollapseEvaluator$fun collapse(list: Iterable&lt;Interval?>?, per: Quantity?, state: State?): List&lt;Interval?>?</ID>
    <ID>LongMethod:CqlClinicalOperatorsTest.kt$CqlClinicalOperatorsTest$@Test fun all_clinical_operators_tests()</ID>
    <ID>LongMethod:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest$@Test fun multipleLibrariesWithParameters()</ID>
    <ID>LongMethod:CqlErrorsAndMessagingOperatorsTest.kt$CqlErrorsAndMessagingOperatorsTest$@Test fun message()</ID>
    <ID>LongMethod:CqlInternalTypeRepresentationSuiteTest.kt$CqlInternalTypeRepresentationSuiteTest$@ParameterizedTest @MethodSource("timeZones") fun all_internal_type_representation(zoneId: ZoneId, now: LocalDateTime)</ID>
    <ID>LongMethod:CqlLogicalOperatorsTest.kt$CqlLogicalOperatorsTest$@Test fun all_logical_operators()</ID>
    <ID>LongMethod:CqlStringOperatorsTest.kt$CqlStringOperatorsTest$@Test fun all_string_operators()</ID>
    <ID>LongMethod:CqlTypesOperatorsTest.kt$CqlTypesOperatorsTest$@ParameterizedTest @MethodSource("timezones") fun all_types_operators(timezone: String?)</ID>
    <ID>LongMethod:CqlTypesTest.kt$CqlTypesTest$@Test fun all_types()</ID>
    <ID>LongMethod:CqlValueLiteralsAndSelectorsTest.kt$CqlValueLiteralsAndSelectorsTest$@Test fun all_value_literals_and_selectors()</ID>
    <ID>LongMethod:DateTime.kt$DateTime$override fun toString(): String</ID>
    <ID>LongMethod:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun bigDecimals(): Array&lt;Array&lt;Any?>?></ID>
    <ID>LongMethod:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun dateStrings(): Array&lt;Array&lt;Any>></ID>
    <ID>LongMethod:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun dateStringsOtherZoneId(): Array&lt;Array&lt;Any>></ID>
    <ID>LongMethod:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun offsetPrecisions(): Array&lt;Array&lt;Any>></ID>
    <ID>LongMethod:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$@JvmStatic fun difference(left: Any?, right: Any?, precision: Precision): Any?</ID>
    <ID>LongMethod:DurationBetweenEvaluator.kt$DurationBetweenEvaluator$@JvmStatic fun duration(left: Any?, right: Any?, precision: Precision?): Any?</ID>
    <ID>LongMethod:ExceptEvaluator.kt$ExceptEvaluator$@JvmStatic fun except(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>LongMethod:HighBoundaryEvaluator.kt$HighBoundaryEvaluator$@JvmStatic fun highBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>LongMethod:InEvaluator.kt$InEvaluator$private fun intervalIn( left: Any?, right: Interval, precision: String?, state: State?, ): Boolean?</ID>
    <ID>LongMethod:IntersectEvaluator.kt$IntersectEvaluator$@JvmStatic fun intersect(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>LongMethod:IntervalOperatorsTest.kt$IntervalOperatorsTest$@Test fun all_interval_operators()</ID>
    <ID>LongMethod:ListOperatorsTest.kt$ListOperatorsTest$@Test fun all_interval_operators()</ID>
    <ID>LongMethod:LowBoundaryEvaluator.kt$LowBoundaryEvaluator$@JvmStatic fun lowBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>LongMethod:PredecessorEvaluator.kt$PredecessorEvaluator$@JvmStatic fun predecessor(value: Any?): Any?</ID>
    <ID>LongMethod:ProfilingTest.kt$ProfilingTest$@Test fun profilingSmoke()</ID>
    <ID>LongMethod:QueryEvaluator.kt$QueryEvaluator$fun internalEvaluate( elm: Query, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>LongMethod:RetrieveEvaluator.kt$RetrieveEvaluator$fun internalEvaluate( elm: Retrieve?, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any</ID>
    <ID>LongMethod:SameAsEvaluator.kt$SameAsEvaluator$@JvmStatic fun sameAs(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>LongMethod:SubtractEvaluator.kt$SubtractEvaluator$@JvmStatic fun subtract(left: Any?, right: Any?): Any?</ID>
    <ID>LongMethod:SuccessorEvaluator.kt$SuccessorEvaluator$@JvmStatic fun successor(value: Any?): Any?</ID>
    <ID>LongMethod:TemporalHelper.kt$TemporalHelper$fun truncateValueToTargetPrecision( value: Long, precision: Precision, targetPrecision: Precision?, ): Long</ID>
    <ID>LongParameterList:Backtrace.kt$Backtrace$( containingDefinition: ExpressionDef?, definitionFrame: ActivationFrame?, stack: Deque&lt;ActivationFrame>, contextName: String?, contextValue: Any?, expression: Expression?, )</ID>
    <ID>LongParameterList:CqlEngine.kt$CqlEngine$( libraryIdentifier: VersionedIdentifier, expressions: Set&lt;String>? = null, contextParameter: Pair&lt;String?, Any?>? = null, parameters: Map&lt;String?, Any?>? = null, debugMap: DebugMap? = null, evaluationDateTime: ZonedDateTime? = null, )</ID>
    <ID>LongParameterList:CqlEngine.kt$CqlEngine$( libraryIdentifiers: List&lt;VersionedIdentifier>, expressions: Set&lt;String>? = null, contextParameter: Pair&lt;String?, Any?>? = null, parameters: Map&lt;String?, Any?>? = null, debugMap: DebugMap? = null, nullableEvaluationDateTime: ZonedDateTime? = null, )</ID>
    <ID>LongParameterList:DateTimeEvaluator.kt$DateTimeEvaluator$( year: Int?, month: Int?, day: Int?, hour: Int?, minute: Int?, second: Int?, milliSecond: Int?, timeZoneOffset: BigDecimal?, )</ID>
    <ID>LongParameterList:MessageEvaluator.kt$MessageEvaluator$( state: State?, sourceLocator: SourceLocator?, source: Any?, condition: Boolean?, code: String?, severity: String?, message: String?, )</ID>
    <ID>LongParameterList:Profile.kt$Profile.Node$( writer: Writer, i: Int, x: Double, depth: Int, scaleX: Double, scaleY: Double, )</ID>
    <ID>LongParameterList:RetrieveProvider.kt$RetrieveProvider$( context: String?, contextPath: String?, contextValue: Any?, dataType: String, templateId: String?, codePath: String?, codes: Iterable&lt;Code>?, valueSet: String?, datePath: String?, dateLowPath: String?, dateHighPath: String?, dateRange: Interval?, )</ID>
    <ID>LoopWithTooManyJumpStatements:DistinctEvaluator.kt$DistinctEvaluator$for</ID>
    <ID>LoopWithTooManyJumpStatements:ProperContainsEvaluator.kt$ProperContainsEvaluator$for</ID>
    <ID>LoopWithTooManyJumpStatements:QueryEvaluator.kt$QueryEvaluator$while</ID>
    <ID>MagicNumber:BaseTemporal.kt$BaseTemporal.Companion$99</ID>
    <ID>MagicNumber:Date.kt$Date$9999</ID>
    <ID>MagicNumber:DateTime.kt$DateTime$3</ID>
    <ID>MagicNumber:DateTime.kt$DateTime$3600</ID>
    <ID>MagicNumber:DateTime.kt$DateTime$6</ID>
    <ID>MagicNumber:DateTime.kt$DateTime$60</ID>
    <ID>MagicNumber:DateTime.kt$DateTime$9999</ID>
    <ID>MagicNumber:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$7</ID>
    <ID>MagicNumber:DivideEvaluator.kt$DivideEvaluator$8</ID>
    <ID>MagicNumber:DurationBetweenEvaluator.kt$DurationBetweenEvaluator$7</ID>
    <ID>MagicNumber:ModuloEvaluator.kt$ModuloEvaluator$8</ID>
    <ID>MagicNumber:Precision.kt$Precision$3</ID>
    <ID>MagicNumber:Precision.kt$Precision$4</ID>
    <ID>MagicNumber:Precision.kt$Precision$5</ID>
    <ID>MagicNumber:Precision.kt$Precision$6</ID>
    <ID>MagicNumber:Precision.kt$Precision.Companion$3</ID>
    <ID>MagicNumber:Precision.kt$Precision.Companion$4</ID>
    <ID>MagicNumber:Precision.kt$Precision.Companion$5</ID>
    <ID>MagicNumber:Precision.kt$Precision.Companion$6</ID>
    <ID>MagicNumber:State.kt$State.ActivationFrame$1000000</ID>
    <ID>MagicNumber:State.kt$State.ActivationFrame$4</ID>
    <ID>MagicNumber:SuccessorEvaluator.kt$SuccessorEvaluator$23</ID>
    <ID>MagicNumber:SuccessorEvaluator.kt$SuccessorEvaluator$59</ID>
    <ID>MagicNumber:SuccessorEvaluator.kt$SuccessorEvaluator$999</ID>
    <ID>MagicNumber:Time.kt$Time$3</ID>
    <ID>MagicNumber:Value.kt$Value$8</ID>
    <ID>MaxLineLength:AddEvaluator.kt$AddEvaluator$"Add(Integer, Integer), Add(Long, Long), Add(Decimal, Decimal), Add(Quantity, Quantity), Add(Date, Quantity), Add(DateTime, Quantity) or Add(Time, Quantity)"</ID>
    <ID>MaxLineLength:AfterEvaluator.kt$AfterEvaluator$/* *** NOTES FOR INTERVAL *** after(left Interval&lt;T>, right Interval&lt;T>) Boolean after(left T, right Interval&lt;T>) Boolean after(left Interval&lt;T>, right T) Boolean The after operator for intervals returns true if the first interval starts after the second one ends. In other words, if the starting point of the first interval is greater than the ending point of the second interval. For the point-interval overload, the operator returns true if the given point is greater than the end of the interval. For the interval-point overload, the operator returns true if the given interval starts after the given point. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If either argument is null, the result is null. *** NOTES FOR DATETIME *** after _precision_ of(left Date, right Date) Boolean after _precision_ of(left DateTime, right DateTime) Boolean after _precision_ of(left Time, right Time) Boolean The after-precision-of operator compares two date/time values to the specified precision to determine whether the first argument is the after the second argument. The comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the first value is greater than the second, the result is true; if the first value is less than the second, the result is false; if either input has no value for the precision, the comparison stops and the result is null; if the specified precision has been reached, the comparison stops and the result is false. If no precision is specified, the comparison is performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime values as defined by the ToDateTime operator. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. */</ID>
    <ID>MaxLineLength:AndEvaluator.kt$AndEvaluator$"And(${if (left == null) "Null" else left.javaClass.name}, ${if (right == null) "Null" else right.javaClass.name})"</ID>
    <ID>MaxLineLength:BeforeEvaluator.kt$BeforeEvaluator$/* *** NOTES FOR INTERVAL *** before(left Interval&lt;T>, right Interval&lt;T>) Boolean before(left T, right Interval&lt;T>) Boolean before(left interval&lt;T>, right T) Boolean The before operator for intervals returns true if the first interval ends before the second one starts. In other words, if the ending point of the first interval is less than the starting point of the second interval. For the point-interval overload, the operator returns true if the given point is less than the start of the interval. For the interval-point overload, the operator returns true if the given interval ends before the given point. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If either argument is null, the result is null. *** NOTES FOR DATETIME *** before _precision_ of(left Date, right Date) Boolean before _precision_ of(left DateTime, right DateTime) Boolean before _precision_ of(left Time, right Time) Boolean The before-precision-of operator compares two date/time values to the specified precision to determine whether the first argument is the before the second argument. The comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the first value is less than the second, the result is true; if the first value is greater than the second, the result is false; if either input has no value for the precision, the comparison stops and the result is null; if the specified precision has been reached, the comparison stops and the result is false. If no precision is specified, the comparison is performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime values as defined by the ToDateTime operator. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. */</ID>
    <ID>MaxLineLength:CalculateAgeAtEvaluator.kt$CalculateAgeAtEvaluator$"CalculateAgeInYearsAt(Date, Date), CalculateAgeInYearsAt(DateTime, DateTime), CalculateAgeInMonthsAt(Date, Date), CalculateAgeInMonthsAt(DateTime, DateTime), CalculateAgeInWeeksAt(Date, Date), CalculateAgeInWeeksAt(DateTime, DateTime), CalculateAgeInDaysAt(Date, Date), CalculateAgeInDaysAt(DateTime, DateTime), CalculateAgeInHoursAt(Date, Date), CalculateAgeInHoursAt(DateTime, DateTime), CalculateAgeInMinutesAt(Date, Date), CalculateAgeInMinutesAt(DateTime, DateTime), CalculateAgeInSecondsAt(Date, Date), CalculateAgeInSecondsAt(DateTime, DateTime)"</ID>
    <ID>MaxLineLength:CalculateAgeAtEvaluator.kt$CalculateAgeAtEvaluator$/* CalculateAgeInYearsAt(birthDate Date, asOf Date) Integer CalculateAgeInYearsAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInMonthsAt(birthDate Date, asOf Date) Integer CalculateAgeInMonthsAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInWeeksAt(birthDate Date, asOf Date) Integer CalculateAgeInWeeksAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInDaysAt(birthDate Date, asOf Date) Integer CalculateAgeInDaysAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInHoursAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInMinutesAt(birthDate DateTime, asOf DateTime) Integer CalculateAgeInSecondsAt(birthDate DateTime, asOf DateTime) Integer The CalculateAgeAt operators calculate the age of a person born on the given birthdate as of the given date in the precision named in the operator. If the birthDate is null or the asOf argument is null, the result is null. The CalculateAgeAt operators are defined in terms of a date/time duration calculation. This means that if the given birthDate or asOf are not specified to the level of precision corresponding to the operator being invoked, the result will be an uncertainty over the range of possible values, potentially causing some comparisons to return null. */</ID>
    <ID>MaxLineLength:CalculateAgeEvaluator.kt$CalculateAgeEvaluator$"CalculateAgeInYears(Date), CalculateAgeInYears(DateTime), CalculateAgeInMonths(Date), CalculateAgeInMonths(DateTime), CalculateAgeInWeeks(Date), CalculateAgeInWeeks(DateTime), CalculateAgeInDays(Date), CalculateAgeInDays(DateTime), CalculateAgeInHours(Date), CalculateAgeInHours(DateTime), CalculateAgeInMinutes(Date), CalculateAgeInMinutes(DateTime), CalculateAgeInSeconds(Date), CalculateAgeInSeconds(DateTime)"</ID>
    <ID>MaxLineLength:ChildrenEvaluator.kt$ChildrenEvaluator$/* Children(argument Any) List&lt;Any> For structured types, the Children operator returns a list of all the values of the elements of the type. List-valued elements are expanded and added to the result individually, rather than as a single list. For list types, the result is the same as invoking Children on each element in the list and flattening the resulting lists into a single result. If the source is null, the result is null. */</ID>
    <ID>MaxLineLength:CoalesceEvaluator.kt$CoalesceEvaluator$/* Coalesce&lt;T>(argument1 T, argument2 T) T Coalesce&lt;T>(argument1 T, argument2 T, argument3 T) T Coalesce&lt;T>(argument1 T, argument2 T, argument3 T, argument4 T) T Coalesce&lt;T>(argument1 T, argument2 T, argument3 T, argument4 T, argument5 T) T Coalesce&lt;T>(arguments List&lt;T>) T The Coalesce operator returns the first non-null result in a list of arguments. If all arguments evaluate to null, the result is null. The static type of the first argument determines the type of the result, and all subsequent arguments must be of that same type. */</ID>
    <ID>MaxLineLength:CollapseEvaluator.kt$CollapseEvaluator$/* collapse(argument List&lt;Interval&lt;T>>) List&lt;Interval&lt;T>> collapse(argument List&lt;Interval&lt;T>>, per Quantity) List&lt;Interval&lt;T>> The collapse operator returns the unique set of intervals that completely covers the ranges present in the given list of intervals. In other words, adjacent intervals within a sorted list are merged if they either overlap or meet. Note that because the semantics for overlaps and meets are themselves defined in terms of the interval successor and predecessor operators, sets of date/time-based intervals that are only defined to a particular precision will calculate meets and overlaps at that precision. For example, a list of DateTime-based intervals where the boundaries are all specified to the hour will collapse at the hour precision, unless the collapse precision is overridden with the per argument. The per argument determines the precision at which the collapse will be performed, and must be a quantity value that is compatible with the point type of the input intervals. For numeric intervals, this means a default unit ('1'). For date/time intervals, this means a temporal duration. If the list of intervals is empty, the result is empty. If the list of intervals contains a single interval, the result is a list with that interval. If the list of intervals contains nulls, they will be excluded from the resulting list. If the list argument is null, the result is null. If the per argument is null, the default unit interval for the point type of the intervals involved will be used (i.e. the interval that has a width equal to the result of the successor function for the point type). */</ID>
    <ID>MaxLineLength:ContainsEvaluator.kt$ContainsEvaluator$/* contains(argument List&lt;T>, element T) Boolean The contains operator for lists returns true if the given element is in the list. This operator uses the notion of equivalence to determine whether or not the element being searched for is equivalent to any element in the list. In particular this means that if the list contains a null, and the element being searched for is null, the result will be true. If the list argument is null, the result is false. contains _precision_ (argument Interval&lt;T>, point T) Boolean The contains operator for intervals returns true if the given point is greater than or equal to the starting point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is null, the result of the boundary comparison is considered true. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertEvaluator.kt$ConvertEvaluator$/* convert to&lt;T>(argument Any) T The convert operator converts a value to a specific type. The result of the operator is the value of the argument converted to the target type, if possible. If there is no valid conversion from the actual value to the target type, the result is null. The following table lists the conversions supported in CQL: From\To Boolean Integer Decimal Quantity Ratio String Date Datetime Time Code	Concept List&lt;Code> Boolean N/A Explicit Explicit - - Explicit - - - - - - Integer Explicit N/A Implicit Implicit - Explicit - - - - - - Decimal Explicit - N/A Implicit - Explicit - - - - - - Quantity - - - N/A - Explicit - - - - - - Ratio - - - - N/A Explicit - - - - - - String Explicit Explicit Explicit Explicit Explicit N/A Explicit Explicit Explicit - - - Date - - - - - Explicit	N/A Implicit - - - - Datetime - - - - - Explicit Explicit N/A - - - - Time - - - - - Explicit - - N/A - - - Code - - - - - - - - - N/A Implicit - Concept - - - - - - - - - - N/A Explicit List&lt;Code> - - - - - - - - - - Explicit N/A For conversions between date/time and string values, ISO-8601 standard format is used: yyyy-MM-ddThh:mm:ss.fff(Z | +/- hh:mm) For example, the following are valid string representations for date/time values: '2014-01-01T14:30:00.0Z' // January 1st, 2014, 2:30PM UTC '2014-01-01T14:30:00.0-07:00' // January 1st, 2014, 2:30PM Mountain Standard (GMT-7:00) 'T14:30:00.0Z' // 2:30PM UTC 'T14:30:00.0-07:00' // 2:30PM Mountain Standard (GMT-7:00) For specific semantics for each conversion, refer to the explicit conversion operator documentation. */</ID>
    <ID>MaxLineLength:ConvertsToBooleanEvaluator.kt$ConvertsToBooleanEvaluator$/* ConvertsToBoolean(argument String) Boolean The ConvertsToBoolean operator returns true if its argument is or can be converted to a Boolean value. See the ToBoolean operator for a description of the supported conversions. If the input cannot be interpreted as a valid Boolean value, the result is false. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToDateEvaluator.kt$ConvertsToDateEvaluator$/* ConvertsToDate(argument String) Boolean The ConvertsToDate operator returns true if its argument is or can be converted to a Date value. See the ToDate operator for a description of the supported conversions. If the input string is not formatted correctly, or does not represent a valid date value, the result is false. As with date literals, date values may be specified to any precision. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToDateTimeEvaluator.kt$ConvertsToDateTimeEvaluator$/* ConvertsToDateTime(argument Date) Boolean ConvertsToDateTime(argument String) Boolean The ConvertsToDateTime operator returns true if its argument is or can be converted to a DateTime value. See the ToDateTime operator for a description of the supported conversions. If the input string is not formatted correctly, or does not represent a valid DateTime value, the result is false. As with date and time literals, DateTime values may be specified to any precision. If no timezone offset is supplied, the timezone offset of the evaluation request timestamp is assumed. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToDecimalEvaluator.kt$ConvertsToDecimalEvaluator$/* ConvertsToDecimal(argument String) Boolean The ToDecimal operator returns true if its argument is or can be converted to a Decimal value. See the ToDecimal operator for a description of the supported conversions. If the input string is not formatted correctly, or cannot be interpreted as a valid Decimal value, the result is false. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToIntegerEvaluator.kt$ConvertsToIntegerEvaluator$/* ConvertsToInteger(argument String) Boolean The ConvertsToInteger operator returns true if its argument is or can be converted to an Integer value. See the ToInteger operator for a description of the supported conversions. If the input string is not formatted correctly, or cannot be interpreted as a valid Integer value, the result is false. */</ID>
    <ID>MaxLineLength:ConvertsToLongEvaluator.kt$ConvertsToLongEvaluator$/* ConvertsToLong(argument String) Boolean The ConvertsToLong operator returns true if its argument is or can be converted to an Long value. See the ToLong operator for a description of the supported conversions. If the input string is not formatted correctly, or cannot be interpreted as a valid Integer value, the result is false. */</ID>
    <ID>MaxLineLength:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$"ConvertsToQuantity(String) or ConvertsToQuantity(Ratio) or ConvertsToQuantity(Integer) or ConvertsToQuantity(Decimal)"</ID>
    <ID>MaxLineLength:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$/* ConvertsToQuantity(argument Decimal) Boolean ConvertsToQuantity(argument Integer) Boolean ConvertsToQuantity(argument Ratio) Boolean ConvertsToQuantity(argument String) Boolean The ConvertsToQuantity operator returns true if its argument is or can be converted to a Quantity value. See the ToQuantity operator for a description of the supported conversions. If the input string is not formatted correctly, or cannot be interpreted as a valid Quantity value, the result is false. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToStringEvaluator.kt$ConvertsToStringEvaluator$"ConvertsToString(Boolean) or ConvertsToString(Long) or ConvertsToString(Integer) or ConvertsToString(Decimal) or ConvertsToString(Quantity) or ConvertsToString(Ratio) or ConvertsToString(Date) or ConvertsToString(DateTime) or ConvertsToString(Time)"</ID>
    <ID>MaxLineLength:ConvertsToStringEvaluator.kt$ConvertsToStringEvaluator$/* ConvertsToString(argument Boolean) Boolean ConvertsToString(argument Integer) Boolean ConvertsToString(argument Long) Boolean ConvertsToString(argument Decimal) Boolean ConvertsToString(argument Quantity) Boolean ConvertsToString(argument Ratio) Boolean ConvertsToString(argument Date) Boolean ConvertsToString(argument DateTime) Boolean ConvertsToString(argument Time) Boolean Description: The ConvertsToString operator returns true if its argument is or can be converted to a String value. See the ToString operator for a description of the supported conversions. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ConvertsToTimeEvaluator.kt$ConvertsToTimeEvaluator$/* ConvertsToTime(argument String) Time The ConvertsToTime operator returns true if its argument is or can be converted to a Time value. See the ToTime operator for a description of the supported conversions. If the input string is not formatted correctly, or does not represent a valid time-of-day value, the result is false. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest$"Library MultiLibrary1 was included with version bad, but id: MultiLibrary1 and version 1.0.0 of the library was found."</ID>
    <ID>MaxLineLength:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest$"Library NameMismatch was included with version null, but id: MismatchName and version null of the library was found."</ID>
    <ID>MaxLineLength:DateTimeComponentFromEvaluator.kt$DateTimeComponentFromEvaluator$/* _precision_ from(argument Date) Integer _precision_ from(argument DateTime) Integer _precision_ from(argument Time) Integer timezoneoffset from(argument DateTime) Decimal date from(argument DateTime) Date time from(argument DateTime) Time The component-from operator returns the specified component of the argument. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, extraction of a week component is not supported. When extracting the Time from a DateTime value, implementations should normalize to the timezone offset of the evaluation request timestamp. If the argument is null, or is not specified to the level of precision being extracted, the result is null. The following examples illustrate the behavior of the component-from operator: define MonthFrom: month from DateTime(2012, 1, 1, 12, 30, 0, 0, -7) // 1 define TimeZoneOffsetFrom: timezoneoffset from DateTime(2012, 1, 1, 12, 30, 0, 0, -7) // -7.0 define DateFrom: date from DateTime(2012, 1, 1, 12, 30, 0, 0, -7) // @2012-01-01 define TimeFrom: time from DateTime(2012, 1, 1, 12, 30, 0, 0, -7) // @T12:30:00.000-07:00 define MonthFromIsNull: month from DateTime(2012) */</ID>
    <ID>MaxLineLength:DateTimeEvaluator.kt$DateTimeEvaluator$/* simple type DateTime The DateTime type represents date and time values with potential uncertainty within CQL. CQL supports date and time values in the range @0001-01-01T00:00:00.0 to @9999-12-31T23:59:59.999 with a 1 millisecond step size. */</ID>
    <ID>MaxLineLength:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$/* difference in _precision_ between(low Date, high Date) Integer difference in _precision_ between(low DateTime, high DateTime) Integer difference in _precision_ between(low Time, high Time) Integer The difference-between operator returns the number of boundaries crossed for the specified precision between the first and second arguments. If the first argument is after the second argument, the result is negative. The result of this operation is always an integer; any fractional boundaries are dropped. As with all date/time calculations, difference calculations are performed respecting the timezone offset depending on the precision. For Date values, precision must be one of: years, months, weeks, or days. For DateTime values, precision must be one of: years, months, weeks, days, hours, minutes, seconds, or milliseconds. For Time values, precision must be one of: hours, minutes, seconds, or milliseconds. For calculations involving weeks, Sunday is considered to be the first day of the week for the purposes of determining the number of boundaries crossed. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime as defined by the ToDateTime operator. If either argument is null, the result is null. Additional Complexity: precision elements above the specified precision must also be accounted for. For example: days between DateTime(2011, 5, 1) and DateTime(2012, 5, 6) = 365 + 5 = 370 days NOTE: This is the same operation as DurationBetween, but the precision after the specified precision is truncated to get the number of boundaries crossed instead of whole calendar periods. For Example: difference in days between DateTime(2014, 5, 12, 12, 10) and DateTime(2014, 5, 25, 15, 55) will truncate the DateTimes to: DateTime(2014, 5, 12) and DateTime(2014, 5, 25) respectively */</ID>
    <ID>MaxLineLength:EndsEvaluator.kt$EndsEvaluator$/* ends _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The ends operator returns true if the first interval ends the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second, and the ending point of the first interval is equal to the ending point of the second. This operator uses the semantics described in the start and end operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:EqualEvaluator.kt$EqualEvaluator$/* *** NOTES FOR CLINICAL OPERATORS *** =(left Code, right Code) Boolean =(left Concept, right Concept) Boolean The equal (=) operator for Codes and Concepts uses tuple equality semantics. This means that the operator will return true if and only if the values for each element by name are equal. If either argument is null, or contains any null components, the result is null. *** NOTES FOR INTERVAL *** =(left Interval&lt;T>, right Interval&lt;T>) Boolean The equal (=) operator for intervals returns true if and only if the intervals are over the same point type, and they have the same value for the starting and ending points of the intervals as determined by the Start and End operators. If either argument is null, the result is null. *** NOTES FOR LIST *** =(left List&lt;T>, right List&lt;T>) Boolean The equal (=) operator for lists returns true if and only if the lists have the same element type, and have the same elements by value, in the same order. If either argument is null, or contains null elements, the result is null. */</ID>
    <ID>MaxLineLength:EquivalentEvaluator.kt$EquivalentEvaluator$/* https://cql.hl7.org/09-b-cqlreference.html#equivalent *** NOTES FOR CLINICAL OPERATORS *** ~(left Code, right Code) Boolean The ~ operator for Code values returns true if the code, system, and version elements are equivalent. The display element is ignored for the purposes of determining Code equivalence. For Concept values, equivalence is defined as a non-empty intersection of the codes in each Concept. The display element is ignored for the purposes of determining Concept equivalence. Note that this operator will always return true or false, even if either or both of its arguments are null, or contain null components. Note carefully that this notion of equivalence is not the same as the notion of equivalence used in terminology: "these codes represent the same concept." CQL specifically avoids defining terminological equivalence. The notion of equivalence defined here is used to provide consistent and intuitive semantics when dealing with missing information in membership contexts. *** NOTES FOR INTERVAL *** ~(left Interval&lt;T>, right Interval&lt;T>) Boolean The ~ operator for intervals returns true if and only if the intervals are over the same point type, and the starting and ending points of the intervals as determined by the Start and End operators are equivalent. *** NOTES FOR LIST *** ~(left List&lt;T>, right List&lt;T>) Boolean The ~ operator for lists returns true if and only if the lists contain elements of the same type, have the same number of elements, and for each element in the lists, in order, the elements are equivalent. *** NOTES FOR DECIMAL *** For decimals, equivalent means the values are the same with the comparison done on values rounded to the precision of the least precise operand; trailing zeroes after the decimal are ignored in determining precision for equivalent comparison. */</ID>
    <ID>MaxLineLength:EvaluationResultsForMultiLib.kt$EvaluationResultsForMultiLib$"Did you run an evaluation for multiple libraries? Expected exactly one result or error, but found results: ${results.size} errors: ${exceptions.size}: "</ID>
    <ID>MaxLineLength:ExceptEvaluator.kt$ExceptEvaluator$"The following interval values led to an undefined Except result: leftStart: ${leftStart.toString()}, leftEnd: ${leftEnd.toString()}, rightStart: ${rightStart.toString()}, rightEnd: ${rightEnd.toString()}"</ID>
    <ID>MaxLineLength:ExceptEvaluator.kt$ExceptEvaluator$/* except(left Interval&lt;T>, right Interval&lt;T>) Interval&lt;T> The except operator for intervals returns the set difference of two intervals. More precisely, this operator returns the portion of the first interval that does not overlap with the second. Note that to avoid returning an improper interval, if the second argument is properly contained within the first and does not start or end it, this operator returns null. If either argument is null, the result is null. except(left List&lt;T>, right List&lt;T>) List&lt;T> The except operator returns the set difference of two lists. More precisely, the operator returns a list with the elements that appear in the first operand that do not appear in the second operand. This operator uses equality semantics to determine whether two elements are the same for the purposes of computing the difference. The operator is defined with set semantics, meaning that each element will appear in the result at most once, and that there is no expectation that the order of the inputs will be preserved in the results. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:FirstEvaluator.kt$FirstEvaluator$/* First(argument List&lt;T>) T The First operator returns the first element in a list. The operator is equivalent to invoking the indexer with an index of 0. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:FunctionRefEvaluator.kt$FunctionRefEvaluator$"Ambiguous call to operator '${name}(${typesToString(state, types)})' in library '${state!!.getCurrentLibrary()!!.identifier!!.id}'."</ID>
    <ID>MaxLineLength:FunctionRefEvaluator.kt$FunctionRefEvaluator$"Could not resolve call to operator '${name}(${typesToString(state, types)})' in library '${state!!.getCurrentLibrary()!!.identifier!!.id}'."</ID>
    <ID>MaxLineLength:FunctionRefEvaluatorTest.kt$FunctionRefEvaluatorTest$"Could not resolve call to operator 'func(java.lang.Integer, java.lang.Integer, java.lang.Integer)' in library 'lib'."</ID>
    <ID>MaxLineLength:GreaterEvaluator.kt$GreaterEvaluator$"Greater(Integer, Integer), Greater(Long, Long), Greater(Decimal, Decimal), Greater(Quantity, Quantity), Greater(Date, Date), Greater(DateTime, DateTime), Greater(Time, Time) or Greater(String, String)"</ID>
    <ID>MaxLineLength:GreaterEvaluator.kt$GreaterEvaluator$/* >(left Integer, right Integer) Boolean >(left Long, right Long) Boolean >(left Decimal, right Decimal) Boolean >(left Quantity, right Quantity) Boolean >(left Date, right Date) Boolean >(left DateTime, right DateTime) Boolean >(left Time, right Time) Boolean >(left String, right String) Boolean The greater (>) operator returns true if the first argument is greater than the second argument. String comparisons are strictly lexical based on the Unicode value of the individual characters in the string. For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of 'cm' and 'm' are comparable, but units of 'cm2' and 'cm' are not. Attempting to operate on quantities with invalid units will result in a null. When a quantity has no units specified, it is treated as a quantity with the default unit ('1'). For date/time values, the comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the first value is greater than the second, the result is true; if the first value is less than the second, the result is false; if one input has a value for the precision and the other does not, the comparison stops and the result is null; if neither input has a value for the precision or the last precision has been reached, the comparison stops and the result is false. For example: define DateTimeGreaterIsNull: @2012-01-01 > @2012-01-01T12 If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:GreaterOrEqualEvaluator.kt$GreaterOrEqualEvaluator$"Cannot perform greater than or equal operator on types ${left.javaClass.getSimpleName()} and ${right.javaClass.getSimpleName()}"</ID>
    <ID>MaxLineLength:GreaterOrEqualEvaluator.kt$GreaterOrEqualEvaluator$"GreaterOrEqual(Integer, Integer), GreaterOrEqual(Long, Long), GreaterOrEqual(Decimal, Decimal), GreaterOrEqual(Quantity, Quantity), GreaterOrEqual(Date, Date), GreaterOrEqual(DateTime, DateTime), GreaterOrEqual(Time, Time) or GreaterOrEqual(String, String)"</ID>
    <ID>MaxLineLength:HighBoundaryEvaluator.kt$HighBoundaryEvaluator$"HighBoundary(Decimal, Integer) or HighBoundary(Date, Integer) or HighBoundary(DateTime, Integer) or HighBoundary(Time, Integer)"</ID>
    <ID>MaxLineLength:InCodeSystemEvaluator.kt$InCodeSystemEvaluator$/* in(code String, codesystem CodeSystemRef) Boolean in(code Code, codesystem CodeSystemRef) Boolean in(concept Concept, codesystem CodeSystemRef) Boolean The in (Codesystem) operators determine whether or not a given code is in a particular codesystem. For the String overload, if the given code system contains a code with an equivalent code element, the result is true. For the Code overload, if the given code system contains an equivalent code, the result is true. For the Concept overload, if the given code system contains a code equivalent to any code in the given concept, the result is true. If the code argument is null, the result is null. */</ID>
    <ID>MaxLineLength:InEvaluator.kt$InEvaluator$/* *** NOTES FOR INTERVAL *** in(point T, argument Interval&lt;T>) Boolean The in operator for intervals returns true if the given point is greater than or equal to the starting point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is null, the result of the boundary comparison is considered true. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:InValueSetEvaluator.kt$InValueSetEvaluator$/* in(code String, valueset ValueSetRef) Boolean in(code Code, valueset ValueSetRef) Boolean in(concept Concept, valueset ValueSetRef) Boolean The in (Valueset) operators determine whether or not a given code is in a particular valueset. For the String overload, if the given valueset contains a code with an equivalent code element, the result is true. For the Code overload, if the given valueset contains an equivalent code, the result is true. For the Concept overload, if the given valueset contains a code equivalent to any code in the given concept, the result is true. If the code argument is null, the result is null. */</ID>
    <ID>MaxLineLength:IncludedInEvaluator.kt$IncludedInEvaluator$/* *** NOTES FOR INTERVAL *** included in _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The included in operator for intervals returns true if the first interval is completely included in the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second interval, and the ending point of the first interval is less than or equal to the ending point of the second interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. Note that during is a synonym for included in and may be used to invoke the same operation whenever included in may appear. *** NOTES FOR LIST *** included in(left List&lt;T>, right list&lt;T>) Boolean included in(left T, right list&lt;T>) Boolean The included in operator for lists returns true if every element of the first list is in the second list using equality semantics. For the singleton overload, this operator returns true if the singleton is included in (i.e. in) the list. If either argument is null, the result is null. Note that the order of elements does not matter for the purposes of determining inclusion. */</ID>
    <ID>MaxLineLength:IncludesEvaluator.kt$IncludesEvaluator$/* *** NOTES FOR INTERVAL *** includes _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The includes operator for intervals returns true if the first interval completely includes the second. More precisely, if the starting point of the first interval is less than or equal to the starting point of the second interval, and the ending point of the first interval is greater than or equal to the ending point of the second interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. *** NOTES FOR LIST *** includes(left List&lt;T>, right List&lt;T>) Boolean includes(left List&lt;T>, right T) Boolean The includes operator for lists returns true if the first list contains every element of the second list using equality semantics. For the singleton overload, this operator returns true if the list includes (i.e. contains) the singleton. If either argument is null, the result is null. Note that the order of elements does not matter for the purposes of determining inclusion. */</ID>
    <ID>MaxLineLength:Interval.kt$Interval$"Cannot perform equal operation on types: '${this.javaClass.getName()}' and '${other?.javaClass?.getName()}'"</ID>
    <ID>MaxLineLength:Interval.kt$Interval$"Invalid Interval - the ending boundary (${high}) must be greater than or equal to the starting boundary (${low})."</ID>
    <ID>MaxLineLength:Interval.kt$Interval$return "Interval${if (this.lowClosed) "[" else "("}${if (this.low == null) "null" else this.low.toString()}, ${if (this.high == null) "null" else this.high.toString()}${if (this.highClosed) "]" else ")"}"</ID>
    <ID>MaxLineLength:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$"Library InvalidCqlLibraryIdentifierMismatch was included with version 1.0.0, but id: Mismatched and version null of the library was found."</ID>
    <ID>MaxLineLength:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$"Library InvalidCqlLibraryIdentifierMismatch was included with version null, but id: Mismatched and version null of the library was found."</ID>
    <ID>MaxLineLength:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$"Library InvalidCqlLibraryIdentifierMismatchWithVersion was included with version 1.0.0, but id: MismatchedWithVersion and version 1.0.0 of the library was found."</ID>
    <ID>MaxLineLength:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$"Library InvalidCqlLibraryIdentifierMismatchWithVersion was included with version null, but id: MismatchedWithVersion and version 1.0.0 of the library was found."</ID>
    <ID>MaxLineLength:LastPositionOfEvaluator.kt$LastPositionOfEvaluator$/* * LastPositionOf(pattern String, argument String) Integer * * The LastPositionOf operator returns the 0-based index of the last appearance of the given pattern in the given string. * * If the pattern is not found, the result is -1. * * If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:LessEvaluator.kt$LessEvaluator$"Less(Integer, Integer), Less(Long, Long), Less(Decimal, Decimal), Less(Quantity, Quantity), Less(Date, Date), Less(DateTime, DateTime), Less(Time, Time) or Less(String, String)"</ID>
    <ID>MaxLineLength:LessOrEqualEvaluator.kt$LessOrEqualEvaluator$"LessOrEqual(Integer, Integer), LessOrEqual(Long, Long), LessOrEqual(Decimal, Decimal), LessOrEqual(Quantity, Quantity), LessOrEqual(Date, Date), LessOrEqual(DateTime, DateTime), LessOrEqual(Time, Time) or LessOrEqual(String, String)"</ID>
    <ID>MaxLineLength:LowBoundaryEvaluator.kt$LowBoundaryEvaluator$"LowBoundary(Decimal, Integer) or LowBoundary(Date, Integer) or LowBoundary(DateTime, Integer) or LowBoundary(Time, Integer)"</ID>
    <ID>MaxLineLength:MaxEvaluator.kt$MaxEvaluator$"Max(List&lt;Integer>), Max(List&lt;Long>, Max(List&lt;Decimal>, Max(List&lt;Quantity>), Max(List&lt;Date>), Max(List&lt;DateTime>), Max(List&lt;Time>) or Max(List&lt;String>))"</ID>
    <ID>MaxLineLength:MaxValueEvaluator.kt$MaxValueEvaluator$/* maximum&lt;T>() T The maximum operator returns the maximum representable value for the given type. The maximum operator is defined for the Integer, Long, Decimal, DateTime, and Time types. For Integer, maximum returns the maximum signed 32-bit integer, 231 - 1. For Long, maximum returns the maximum signed 64-bit Long, 263 - 1. For Decimal, maximum returns the maximum representable decimal value, (10^28 – 1) / 10^8 (99999999999999999999.99999999). For DateTime, maximum returns the maximum representable date/time value, DateTime(9999, 12, 31, 23, 59, 59, 999). For Time, maximum returns the maximum representable time value, Time(23, 59, 59, 999). For any other type, attempting to invoke maximum results in an error. */</ID>
    <ID>MaxLineLength:MeetsAfterEvaluator.kt$MeetsAfterEvaluator$/* meets after _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The meets after operator returns true if the first interval starts immediately after the second interval ends. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:MeetsBeforeEvaluator.kt$MeetsBeforeEvaluator$/* meets before _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The meets before operator returns true if the first interval ends immediately before the second interval starts. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:MeetsEvaluator.kt$MeetsEvaluator$/* meets _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The meets operator returns true if the first interval ends immediately before the second interval starts, or if the first interval starts immediately after the second interval ends. In other words, if the ending point of the first interval is equal to the predecessor of the starting point of the second, or if the starting point of the first interval is equal to the successor of the ending point of the second. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:MinEvaluator.kt$MinEvaluator$"Min(List&lt;Integer>), Min(List&lt;Long>), Min(List&lt;Decimal>), Min(List&lt;Quantity>), Min(List&lt;Date>), Min(List&lt;DateTime>), Min(List&lt;Time>) or Min(List&lt;String>)"</ID>
    <ID>MaxLineLength:MinValueEvaluator.kt$MinValueEvaluator$/* minimum&lt;T>() T The minimum operator returns the minimum representable value for the given type. The minimum operator is defined for the Integer, Long, Decimal, DateTime, and Time types. For Integer, minimum returns the minimum signed 32-bit integer, -231. For Long, minimum returns the minimum signed 32-bit integer, -263. For Decimal, minimum returns the minimum representable decimal value, (-10^28 + 1) / 10^8 (-99999999999999999999.99999999). For DateTime, minimum returns the minimum representable date/time value, DateTime(1, 1, 1, 0, 0, 0, 0). For Time, minimum returns the minimum representable time value, Time(0, 0, 0, 0). For any other type, attempting to invoke minimum results in an error. */</ID>
    <ID>MaxLineLength:MultiplyEvaluator.kt$MultiplyEvaluator$"Multiply(Integer, Integer), Multiply(Long, Long), Multiply(Decimal, Decimal), Multiply(Decimal, Quantity), Multiply(Quantity, Decimal) or Multiply(Quantity, Quantity)"</ID>
    <ID>MaxLineLength:MultiplyEvaluator.kt$MultiplyEvaluator$/* *(left Integer, right Integer) Integer *(left Long, right Long) Long *(left Decimal, right Decimal) Decimal *(left Decimal, right Quantity) Quantity *(left Quantity, right Decimal) Quantity *(left Quantity, right Quantity) Quantity The multiply (*) operator performs numeric multiplication of its arguments. When invoked with mixed Integer and Decimal arguments, the Integer argument will be implicitly converted to Decimal. TODO: For multiplication operations involving quantities, the resulting quantity will have the appropriate unit. For example: 12 'cm' * 3 'cm' 3 'cm' * 12 'cm2' In this example, the first result will have a unit of 'cm2', and the second result will have a unit of 'cm3'. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:OrEvaluator.kt$OrEvaluator$"Or(${if (left == null) "Null" else left.javaClass.name}, ${if (right == null) "Null" else right.javaClass.name})"</ID>
    <ID>MaxLineLength:OverlapsAfterEvaluator.kt$OverlapsAfterEvaluator$/* overlaps after _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The overlaps after operator returns true if the first interval overlaps the second and ends after it. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:OverlapsBeforeEvaluator.kt$OverlapsBeforeEvaluator$/* overlaps before _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The operator overlaps before returns true if the first interval overlaps the second and starts before it. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:OverlapsEvaluator.kt$OverlapsEvaluator$/* overlaps _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The overlaps operator returns true if the first interval overlaps the second. More precisely, if the ending point of the first interval is greater than or equal to the starting point of the second interval, and the starting point of the first interval is less than or equal to the ending point of the second interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:PointFromEvaluator.kt$PointFromEvaluator$/* point from(argument Interval&lt;T>) : T The point from operator extracts the single point from a unit interval. If the argument is not a unit interval, a run-time error is thrown. If the argument is null, the result is null. * */</ID>
    <ID>MaxLineLength:PrecisionEvaluator.kt$PrecisionEvaluator$/* Precision(argument Decimal) Integer Precision(argument Date) Integer Precision(argument DateTime) Integer Precision(argument Time) Integer The Precision function returns the number of digits of precision in the input value. The function can be used with Decimal, Date, DateTime, and Time values. For Decimal values, the function returns the number of digits of precision after the decimal place in the input value. Precision(1.58700) // 5 For Date and DateTime values, the function returns the number of digits of precision in the input value. Precision(@2014) // 4 Precision(@2014-01-05T10:30:00.000) // 17 Precision(@T10:30) // 4 Precision(@T10:30:00.000) // 9 If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:PredecessorEvaluator.kt$PredecessorEvaluator$/* predecessor of&lt;T>(argument T) T The predecessor operator returns the predecessor of the argument. For example, the predecessor of 2 is 1. If the argument is already the minimum value for the type, a run-time error is thrown. The predecessor operator is defined for the Integer, Long, Decimal, DateTime, and Time types. For Integer, Long predecessor is equivalent to subtracting 1. For Decimal, predecessor is equivalent to subtracting the minimum precision value for the Decimal type, or 10^-08. For DateTime and Time values, predecessor is equivalent to subtracting a time-unit quantity for the lowest specified precision of the value. For example, if the DateTime is fully specified, predecessor is equivalent to subtracting 1 millisecond; if the DateTime is specified to the second, predecessor is equivalent to subtracting one second, etc. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ProductEvaluator.kt$ProductEvaluator$"Product(List&lt;Integer>), Product(List&lt;Long>), Product(List&lt;Decimal>) or Product(List&lt;Quantity>)"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$" &lt;rect x=\"${x1}\" y=\"${y1}\" width=\"${x2 - x1}\" height=\"${y2 - y1}\" style=\"fill:${color};stroke:${color};fill-opacity:0.5;\"/>\n"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$" &lt;text x=\"${x1}\" y=\"${y1 + (y2 - y1) * .15}\" clip-path=\"url(#${idString})\">&lt;tspan>${expressionLabel(this.expression)}&lt;/tspan>&lt;/text>\n"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$" &lt;text x=\"${x1}\" y=\"${y1 + (y2 - y1) * .35}\" clip-path=\"url(#${idString})\">&lt;tspan>${this.time / 1000000} ms&lt;/tspan>&lt;/text>\n"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$" &lt;text x=\"${x1}\" y=\"${y1 + (y2 - y1) * .55}\" clip-path=\"url(#${idString})\">&lt;tspan>${this.count} Calls&lt;/tspan>&lt;/text>\n"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$" &lt;text x=\"${x1}\" y=\"${y1 + (y2 - y1) * .75}\" clip-path=\"url(#${idString})\">&lt;tspan>${this.misses} Misses&lt;/tspan>&lt;/text>\n"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$"#${(red).toString(16).padStart(2, '0')}${(green).toString(16).padStart(2, '0')}${(blue).toString(16).padStart(2, '0')}"</ID>
    <ID>MaxLineLength:Profile.kt$Profile.Node$return "Node{expression=${expressionLabel(this.expression)}, context=${this.context}, count=${this.count}, time=${this.time} ms, misses=${this.misses}}"</ID>
    <ID>MaxLineLength:ProperIncludedInEvaluator.kt$ProperIncludedInEvaluator$/* *** NOTES FOR INTERVAL *** properly included in(left Interval&lt;T>, right Interval&lt;T>) Boolean The properly included in operator for intervals returns true if the first interval is completely included in the second and the first interval is strictly smaller than the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second interval, and the ending point of the first interval is less than or equal to the ending point of the second interval, and they are not the same interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If either argument is null, the result is null. Note that during is a synonym for included in. *** NOTES FOR LIST *** properly included in(left List&lt;T>, right list&lt;T>) Boolean The properly included in operator for lists returns true if every element of the first list is in the second list and the first list is strictly smaller than the second list. This operator uses the notion of equivalence to determine whether or not two elements are the same. If the left argument is null, the result is true if the right argument is not empty. Otherwise, if the right argument is null, the result is false. Note that the order of elements does not matter for the purposes of determining inclusion. */</ID>
    <ID>MaxLineLength:ProperIncludesEvaluator.kt$ProperIncludesEvaluator$/* *** NOTES FOR INTERVAL *** properly includes _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The properly includes operator for intervals returns true if the first interval completely includes the second and the first interval is strictly larger than the second. More precisely, if the starting point of the first interval is less than or equal to the starting point of the second interval, and the ending point of the first interval is greater than or equal to the ending point of the second interval, and they are not the same interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. *** NOTES FOR LIST *** properly includes(left List&lt;T>, right List&lt;T>) Boolean The properly includes operator for lists returns true if the first list contains every element of the second list, a nd the first list is strictly larger than the second list. This operator uses the notion of equivalence to determine whether or not two elements are the same. If the left argument is null, the result is false, else if the right argument is null, the result is true if the left argument is not empty. Note that the order of elements does not matter for the purposes of determining inclusion. */</ID>
    <ID>MaxLineLength:RetrieveEvaluator.kt$RetrieveEvaluator$/* This whole block is a bit a hack in the sense that the need to switch to the context (e.g. Practitioner) identifies itself in a non-domain specific way */</ID>
    <ID>MaxLineLength:SameAsEvaluator.kt$SameAsEvaluator$/* *Temporal Overload same _precision_ as(left Date, right Date) Boolean same _precision_ as(left DateTime, right DateTime) Boolean same _precision_ as(left Time, right Time) Boolean The same-precision-as operator compares two date/time values to the specified precision for equality. The comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the values are different, the comparison stops and the result is false; if either input has no value for the precision, the comparison stops and the result is null; if the specified precision has been reached, the comparison stops and the result is true. If no precision is specified, the comparison is performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime as defined by the ToDateTime operator. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. *Interval Overload same _precision_ as(left Interval&lt;T>, right Interval&lt;T>) Boolean The same-precision-as operator for intervals returns true if the two intervals start and end at the same value, using the semantics described in the Start and End operators to determine interval boundaries, and for date/time value, performing the comparisons at the specified precision, as described in the Same As operator for date/time values. If no precision is specified, comparisons are performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date-based intervals, precision must be one of: year, month, or day. For DateTime-based intervals, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time-based intervals, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with a mixture of Date- and DateTime-based intervals, the Date values will be implicitly converted to DateTime values as defined by the ToDateTime operator. For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be null, depending on whether the values involved are specified to the level of precision used for the comparison. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. */</ID>
    <ID>MaxLineLength:SameOrAfterEvaluator.kt$SameOrAfterEvaluator$"OnOrAfter(Date, Date), OnOrAfter(DateTime, DateTime), OnOrAfter(Time, Time), OnOrAfter(Interval&lt;T>, Interval&lt;T>), OnOrAfter(T, Interval&lt;T>) or OnOrAfter(Interval&lt;T>, T)"</ID>
    <ID>MaxLineLength:SameOrAfterEvaluator.kt$SameOrAfterEvaluator$"SameOrAfter(Date, Date), SameOrAfter(DateTime, DateTime), SameOrAfter(Time, Time), SameOrAfter(Interval&lt;T>, Interval&lt;T>), SameOrAfter(T, Interval&lt;T>) or SameOrAfter(Interval&lt;T>, T)"</ID>
    <ID>MaxLineLength:SameOrAfterEvaluator.kt$SameOrAfterEvaluator$/* *** SameOrAfter Temporal Overload *** same _precision_ or after(left Date, right Date) Boolean same _precision_ or after(left DateTime, right DateTime) Boolean same _precision_ or after(left Time, right Time) Boolean The same-precision-or after operator compares two date/time values to the specified precision to determine whether the first argument is the same or after the second argument. The comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the first value is greater than the second, the result is true; if the first value is less than the second, the result is false; if either input has no value for the precision, the comparison stops and the result is null; if the specified precision has been reached, the comparison stops and the result is true. If no precision is specified, the comparison is performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime as defined by the ToDateTime operator. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. Note that in timing phrases, the keyword on may be used as a synonym for same for this operator *** SameOrAfter Interval Overload *** same _precision_ or after(left Interval&lt;T>, right Interval&lt;T>) Boolean same _precision_ or after(left T, right Interval&lt;T>) Boolean same _precision_ or after(left Interval&lt;T>, right T) Boolean The same-precision-or after operator for intervals returns true if the first interval starts on or after the second one ends, using the semantics described in the Start and End operators to determine interval boundaries, and for date/time values, performing the comparisons at the specified precision, as described in the Same or After (Date/Time) operator for date/time values. If no precision is specified, comparisons are performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date-based intervals, precision must be one of: year, month, or day. For DateTime-based intervals, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time-based intervals, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with a mixture of Date-based and DateTime-based intervals, the Date values will be implicitly converted to DateTime values as defined by the ToDateTime operator. When this operator is called with a mixture of point values and intervals, the point values are implicitly converted to an interval starting and ending on the given point value. For comparisons involving date/time or time intervals with imprecision, note that the result of the comparison may be null, depending on whether the values involved are specified to the level of precision used for the comparison. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. Note that in timing phrases, the keyword on may be used as a synonym for same for this operator. *** OnOrAfter DateTime overload *** on or after _precision_ (left Date, right Date) Boolean on or after _precision_ (left DateTime, right DateTime) Boolean on or after _precision_ (left Time, right Time) Boolean The on or after operator for date/time values is a synonym for the same or after operator and is supported to enable natural phrasing. See the description of the Same Or After (Date/Time) operator. Note that this operator can be invoked using either the on or after or the after or on syntax. In timing phrases, the keyword same is a synonym for on. *** OnOrAfter Interval overload *** on or after precision (left Interval&lt;T>, right Interval&lt;T>) Boolean on or after precision (left T, right Interval&lt;T>) Boolean on or after precision (left Interval&lt;T>, right T) Boolean The on or after operator for intervals returns true if the first interval starts on or after the second one ends. In other words, if the starting point of the first interval is greater than or equal to the ending point of the second interval. For the point-interval overload, the operator returns true if the given point is greater than or equal to the end of the interval. For the interval-point overload, the operator returns true if the given interval starts on or after the given point. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. Note that this operator can be invoked using either the on or after or the after or on syntax. */</ID>
    <ID>MaxLineLength:SameOrBeforeEvaluator.kt$SameOrBeforeEvaluator$"OnOrBefore(Date, Date), OnOrBefore(DateTime, DateTime), OnOrBefore(Time, Time), OnOrBefore(Interval&lt;T>, Interval&lt;T>), OnOrBefore(T, Interval&lt;T>) or OnOrBefore(Interval&lt;T>, T)"</ID>
    <ID>MaxLineLength:SameOrBeforeEvaluator.kt$SameOrBeforeEvaluator$"SameOrBefore(Date, Date), SameOrBefore(DateTime, DateTime), SameOrBefore(Time, Time), SameOrBefore(Interval&lt;T>, Interval&lt;T>), SameOrBefore(T, Interval&lt;T>) or SameOrBefore(Interval&lt;T>, T)"</ID>
    <ID>MaxLineLength:SameOrBeforeEvaluator.kt$SameOrBeforeEvaluator$/* *** SameOrBefore Temporal Overload *** same _precision_ or before(left Date, right Date) Boolean same _precision_ or before(left DateTime, right DateTime) Boolean same _precision_ or before(left Time, right Time) Boolean The same-precision-or before operator compares two date/time values to the specified precision to determine whether the first argument is the same or before the second argument. The comparison is performed by considering each precision in order, beginning with years (or hours for time values). If the values are the same, comparison proceeds to the next precision; if the first value is less than the second, the result is true; if the first value is greater than the second, the result is false; if either input has no value for the precision, the comparison stops and the result is null; if the specified precision has been reached, the comparison stops and the result is true. If no precision is specified, the comparison is performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date values, precision must be one of: year, month, or day. For DateTime values, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time values, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with both Date and DateTime inputs, the Date values will be implicitly converted to DateTime as defined by the ToDateTime operator. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. Note that in timing phrases, the keyword on may be used as a synonym for same for this operator. *** SameOrBefore Interval Overload *** same _precision_ or before(left Interval&lt;T>, right Interval&lt;T>) Boolean same _precision_ or before(left T, right Interval&lt;T>) Boolean same _precision_ or before(left Interval&lt;T>, right T) Boolean The same-precision-or before operator returns true if the first interval ends on or before the second one starts, using the semantics described in the Start and End operators to determine interval boundaries, and for date/time values, performing the comparisons at the specified precision, as described in the Same or Before (Date/Time) operator for date/time values. If no precision is specified, comparisons are performed beginning with years (or hours for time values) and proceeding to the finest precision specified in either input. For Date-based intervals, precision must be one of: year, month, or day. For DateTime-based intervals, precision must be one of: year, month, day, hour, minute, second, or millisecond. For Time-based intervals, precision must be one of: hour, minute, second, or millisecond. Note specifically that due to variability in the way week numbers are determined, comparisons involving weeks are not supported. When this operator is called with a mixture of Date- and DateTime-based intervals, the Date values will be implicitly converted to DateTime values as defined by the ToDateTime operator. When this operator is called with a mixture of point values and intervals, the point values are implicitly converted to an interval starting and ending on the given point value. For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be null, depending on whether the values involved are specified to the level of precision used for the comparison. As with all date/time calculations, comparisons are performed respecting the timezone offset. If either or both arguments are null, the result is null. Note that in timing phrases, the keyword on may be used as a synonym for same for this operator. *** OnOrBefore DateTime overload *** on or before _precision_ (left Date, right Date) Boolean on or before _precision_ (left DateTime, right DateTime) Boolean on or before _precision_ (left Time, right Time) Boolean The on or before operator for date/time values is a synonym for the same or before operator and is supported to enable natural phrasing. See the description of the Same Or Before (Date/Time) operator. Note that this operator can be invoked using either the on or before or the before or on syntax. In timing phrases, the keyword same is a synonym for on. *** OnOrBefore Interval overload *** on or before precision (left Interval&lt;T>, right Interval&lt;T&gt;) Boolean on or before precision (left T, right Interval&lt;T>) Boolean on or before precision (left interval&lt;T>, right T) Boolean The on or before operator for intervals returns true if the first interval ends on or before the second one starts. In other words, if the ending point of the first interval is less than or equal to the starting point of the second interval. For the point-interval overload, the operator returns true if the given point is less than or equal to the start of the interval. For the interval-point overload, the operator returns true if the given interval ends on or before the given point. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. Note that this operator can be invoked using either the on or before or the before or on syntax. */</ID>
    <ID>MaxLineLength:SizeEvaluator.kt$SizeEvaluator$/* Size(argument Interval&lt;T>) T The Size operator returns the size of an interval. The result of this operator is equivalent to invoking: (end of argument – start of argument) + point-size, where point-size is determined by successor of minimum T - minimum T. Note that because CQL defines duration and difference operations for date and time valued intervals, size is not defined for intervals of these types. If the argument is null, the result is null. The following examples illustrate the behavior of the Size operator: define SizeTest: Size(Interval[3, 7]) // 5, i.e. the interval contains 5 points define SizeTestEquivalent: Size(Interval[3, 8)) // 5, i.e. the interval contains 5 points define SizeIsNull: Size(null as Interval&lt;Integer>) // null */</ID>
    <ID>MaxLineLength:SplitOnMatchesEvaluator.kt$SplitOnMatchesEvaluator$/* SplitOnMatches(stringToSplit String, separatorPattern String) List&lt;String> The SplitOnMatches operator splits a string into a list of strings using a separator that is defined by a regular expression pattern. If the stringToSplit argument is null, the result is null. The separatorPattern argument is interpreted with the same regular expression semantics as defined for the Matches operator. If the stringToSplit argument does not contain any matches for the separatorPattern, the result is a list of strings containing one element that is the value of the stringToSplit argument. */</ID>
    <ID>MaxLineLength:StartsEvaluator.kt$StartsEvaluator$/* starts _precision_ (left Interval&lt;T>, right Interval&lt;T>) Boolean The starts operator returns true if the first interval starts the second. More precisely, if the starting point of the first is equal to the starting point of the second interval and the ending point of the first interval is less than or equal to the ending point of the second interval. This operator uses the semantics described in the Start and End operators to determine interval boundaries. If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision. If either argument is null, the result is null. */</ID>
    <ID>MaxLineLength:SubstringEvaluator.kt$SubstringEvaluator$"Substring(${stringValue.javaClass.name}, ${startIndexValue.javaClass.name}${if (lengthValue == null) "" else ", " + lengthValue.javaClass.name})"</ID>
    <ID>MaxLineLength:SubtractEvaluator.kt$SubtractEvaluator$"Subtract(Integer, Integer), Subtract(Long, Long) Subtract(Decimal, Decimal), Subtract(Quantity, Quantity), Subtract(Date, Quantity), Subtract(DateTime, Quantity), Subtract(Time, Quantity)"</ID>
    <ID>MaxLineLength:SubtractEvaluator.kt$SubtractEvaluator$/* *** NOTES FOR ARITHMETIC OPERATOR *** -(left Integer, right Integer) Integer -(left Decimal, right Decimal) Decimal -(left Quantity, right Quantity) Quantity The subtract (-) operator performs numeric subtraction of its arguments. When invoked with mixed Integer and Decimal arguments, the Integer argument will be implicitly converted to Decimal. When subtracting quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of 'cm' and 'm' can be subtracted, but units of 'cm2' and 'cm' cannot. The unit of the result will be the most granular unit of either input. If either argument is null, the result is null. *** NOTES FOR DATETIME *** -(left Date, right Quantity) Date -(left DateTime, right Quantity) DateTime -(left Time, right Quantity) Time The subtract (-) operator returns the value of the given date/time, decremented by the time-valued quantity, respecting variable length periods for calendar years and months. For Date values, the quantity unit must be one of: years, months, weeks, or days. For DateTime values, the quantity unit must be one of: years, months, weeks, days, hours, minutes, seconds, or milliseconds. For Time values, the quantity unit must be one of: hours, minutes, seconds, or milliseconds. Note that the quantity units may be specified in singular, plural or UCUM form. The operation is performed by converting the time-based quantity to the most precise value specified in the date/time (truncating any resulting decimal portion) and then subtracting it from the date/time value. For example, the following subtraction: DateTime(2014) - 24 months This example results in the value DateTime(2012) even though the date/time value is not specified to the level of precision of the time-valued quantity. Note also that this means that if decimals appear in the time-valued quantities, the fractional component will be ignored. For example, the following subtraction: DateTime(2014) - 18 months This example results in the value DateTime(2013) If either argument is null, the result is null. NOTE: see note in AddEvaluator */</ID>
    <ID>MaxLineLength:SuccessorEvaluator.kt$SuccessorEvaluator$/* successor of&lt;T>(argument T) T The successor operator returns the successor of the argument. For example, the successor of 1 is 2. If the argument is already the maximum value for the type, a run-time error is thrown. The successor operator is defined for the Integer, Long, Decimal, DateTime, and Time types. For Integer, Long successor is equivalent to adding 1. For Decimal, successor is equivalent to adding the minimum precision value for the Decimal type, or 10^-08. For DateTime and Time values, successor is equivalent to adding a time-unit quantity for the lowest specified precision of the value. For example, if the DateTime is fully specified, successor is equivalent to adding 1 millisecond; if the DateTime is specified to the second, successor is equivalent to adding one second, etc. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:SystemDataProvider.kt$SystemDataProvider$"Errors occurred attempting to invoke the accessor function for property ${path} of type ${clazz.getSimpleName()}"</ID>
    <ID>MaxLineLength:TimezoneFromEvaluator.kt$/* timezone from(argument DateTime) Decimal NOTE: This operator is _not_ part of CQL 1.4, it was renamed from 1.3 and is included so that the 1.4 engine can run 1.3 ELM */</ID>
    <ID>MaxLineLength:ToCharsEvaluator.kt$ToCharsEvaluator$/* ToChars(argument String) List&lt;String> The ToChars operator takes a string and returns a list with one string for each character in the input, in the order in which they appear in the string. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ToConceptEvaluator.kt$ToConceptEvaluator$/* ToConcept(argument Code) Concept The ToConcept operator converts a value of type Code to a Concept value with the given Code as its primary and only Code. If the Code has a display value, the resulting Concept will have the same display value. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ToDecimalEvaluator.kt$ToDecimalEvaluator$/* ToDecimal(argument String) Decimal The ToDecimal operator converts the value of its argument to a Decimal value. The operator accepts strings using the following format: (+|-)?#0(.0#)? Meaning an optional polarity indicator, followed by any number of digits (including none), followed by at least one digit, followed optionally by a decimal point, at least one digit, and any number of additional digits (including none). Note that the decimal value returned by this operator must be limited in precision and scale to the maximum precision and scale representable for Decimal values within CQL. If the input string is not formatted correctly, or cannot be interpreted as a valid Decimal value, the result is null. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ToIntegerEvaluator.kt$ToIntegerEvaluator$/* ToInteger(argument String) Integer The ToInteger operator converts the value of its argument to an Integer value. The operator accepts strings using the following format: (+|-)?#0 Meaning an optional polarity indicator, followed by any number of digits (including none), followed by at least one digit. Note that the integer value returned by this operator must be a valid value in the range representable for Integer values in CQL. If the input string is not formatted correctly, or cannot be interpreted as a valid Integer value, the result is null. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ToLongEvaluator.kt$ToLongEvaluator$/* ToLong(argument String) Long The ToLong operator converts the value of its argument to an Long value. The operator accepts strings using the following format: (+|-)?#0 Meaning an optional polarity indicator, followed by any number of digits (including none), followed by at least one digit. Note that the integer value returned by this operator must be a valid value in the range representable for Long values in CQL. If the input string is not formatted correctly, or cannot be interpreted as a valid long value, the result is null. If the argument is null, the result is null. */</ID>
    <ID>MaxLineLength:ToQuantityEvaluator.kt$ToQuantityEvaluator$"Cannot cast a value of type ${operand.javaClass.name} as Quantity - use String, Integer, Decimal, or Ratio values."</ID>
    <ID>MaxLineLength:ToQuantityEvaluator.kt$ToQuantityEvaluator$/* ToQuantity(argument Decimal) Quantity ToQuantity(argument Integer) Quantity ToQuantity(argument Ratio) Quantity ToQuantity(argument String) Quantity Description: The ToQuantity operator converts the value of its argument to a Quantity value. For the String overload, the operator accepts strings using the following format: (+|-)?#0(.0#)?('&lt;unit>')? Meaning an optional polarity indicator, followed by any number of digits (including none) followed by at least one digit, optionally followed by a decimal point, at least one digit, and any number of additional digits, all optionally followed by a unit designator as a string literal specifying a valid, case-sensitive UCUM unit of measure. Spaces are allowed between the quantity value and the unit designator. Note that the decimal value of the quantity returned by this operator must be a valid value in the range representable for Decimal values in CQL. If the input string is not formatted correctly, or cannot be interpreted as a valid Quantity value, the result is null. For the Integer and Decimal overloads, the operator returns a quantity with the value of the argument and a unit of '1' (the default unit). For the Ratio overload, the operator is equivalent to dividing the numerator of the ratio by the denominator. If the argument is null, the result is null. The following examples illustrate the behavior of the ToQuantity operator: define DecimalOverload: ToQuantity(0.1) // 0.1 '1' define IntegerOverload: ToQuantity(13) // 13 '1' define StringOverload: ToQuantity('-0.1 \'mg\'') // -0.1 'mg' define IsNull: ToQuantity('444 \'cm') */</ID>
    <ID>MaxLineLength:ToRatioEvaluator.kt$ToRatioEvaluator$/* ToRatio(argument String) Ratio The ToRatio operator converts the value of its argument to a Ratio value. The operator accepts strings using the following format: &lt;quantity>:&lt;quantity> where &lt;quantity> is the format used to by the ToQuantity operator. If the input string is not formatted correctly, or cannot be interpreted as a valid Ratio value, the result is null. If the argument is null, the result is null. The following examples illustrate the behavior of the ToRatio operator: define IsValid: ToRatio('1.0 \'mg\':2.0 \'mg\'') define IsNull: ToRatio('1.0 \'mg\';2.0 \'mg\'') */</ID>
    <ID>MaxLineLength:TodayEvaluator.kt$TodayEvaluator$/* Today() Date The Today operator returns the date (with no time component) of the start timestamp associated with the evaluation request. See the Now operator for more information on the rationale for defining the Today operator in this way. */</ID>
    <ID>MaxLineLength:TruncatedDivideEvaluator.kt$TruncatedDivideEvaluator$"TruncatedDivide(Integer, Integer), TruncatedDivide(Decimal, Decimal), TruncatedDivide(Quantity, Quantity)"</ID>
    <ID>MemberNameEqualsClassName:Code.kt$Code$var code: String? = null</ID>
    <ID>MemberNameEqualsClassName:Date.kt$Date$var date: LocalDate? = null set(date) { if (date!!.year &lt; 1) { throw InvalidDate( String.format( Locale.US, "The year: %d falls below the accepted bounds of 0001-9999.", date.year, ) ) } if (date.year > 9999) { throw InvalidDate( String.format( Locale.US, "The year: %d falls above the accepted bounds of 0001-9999.", date.year, ) ) } if (this.precision == null) { this.precision = Precision.DAY } field = date }</ID>
    <ID>MemberNameEqualsClassName:DateTime.kt$DateTime$var dateTime: OffsetDateTime? = null set(dateTime) { if (dateTime!!.year &lt; 1) { throw InvalidDateTime( "The year: ${dateTime.year} falls below the accepted bounds of 0001-9999." ) } if (dateTime.year > 9999) { throw InvalidDateTime( "The year: ${dateTime.year} falls above the accepted bounds of 0001-9999." ) } field = dateTime }</ID>
    <ID>MemberNameEqualsClassName:Time.kt$Time$var time: LocalTime private set</ID>
    <ID>NestedBlockDepth:AllTrueEvaluator.kt$AllTrueEvaluator$@JvmStatic fun allTrue(src: Any?): Boolean?</ID>
    <ID>NestedBlockDepth:AnyTrueEvaluator.kt$AnyTrueEvaluator$@JvmStatic fun anyTrue(src: Any?): Boolean?</ID>
    <ID>NestedBlockDepth:AvgEvaluator.kt$AvgEvaluator$@JvmStatic fun avg(source: Any?, state: State?): Any?</ID>
    <ID>NestedBlockDepth:CoalesceEvaluator.kt$CoalesceEvaluator$fun coalesce(operands: List&lt;Any?>): Any?</ID>
    <ID>NestedBlockDepth:CombineEvaluator.kt$CombineEvaluator$@JvmStatic fun combine(source: Any?, separator: String?): Any?</ID>
    <ID>NestedBlockDepth:CqlEngine.kt$CqlEngine$private fun evaluateExpressions(expressions: Set&lt;String>): EvaluationResult</ID>
    <ID>NestedBlockDepth:CqlEngine.kt$CqlEngine$private fun loadAndValidate(libraryIdentifiers: List&lt;VersionedIdentifier>): LoadMultiLibResult</ID>
    <ID>NestedBlockDepth:DebugLibraryMapEntry.kt$DebugLibraryMapEntry$@Suppress("ReturnCount") fun shouldDebug(node: Element?): DebugAction?</ID>
    <ID>NestedBlockDepth:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$@JvmStatic fun difference(left: Any?, right: Any?, precision: Precision): Any?</ID>
    <ID>NestedBlockDepth:DurationBetweenEvaluator.kt$DurationBetweenEvaluator$@JvmStatic fun duration(left: Any?, right: Any?, precision: Precision?): Any?</ID>
    <ID>NestedBlockDepth:FilterEvaluator.kt$FilterEvaluator$@JvmStatic fun filter(elm: Filter?, source: Any?, condition: Any?, state: State?): Any?</ID>
    <ID>NestedBlockDepth:FlattenEvaluator.kt$FlattenEvaluator$@JvmStatic fun flatten(operand: Any?): List&lt;Any?>?</ID>
    <ID>NestedBlockDepth:FunctionRefEvaluator.kt$FunctionRefEvaluator$fun internalEvaluate( functionRef: FunctionRef?, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>NestedBlockDepth:InCodeSystemEvaluator.kt$InCodeSystemEvaluator$@JvmStatic fun inCodeSystem(code: Any?, codeSystem: Any?, state: State?): Any?</ID>
    <ID>NestedBlockDepth:InValueSetEvaluator.kt$InValueSetEvaluator$@JvmStatic fun inValueSet(code: Any?, valueset: Any?, state: State?): Any?</ID>
    <ID>NestedBlockDepth:IndexerEvaluator.kt$IndexerEvaluator$@JvmStatic fun indexer(left: Any?, right: Any?): Any?</ID>
    <ID>NestedBlockDepth:ModeEvaluator.kt$ModeEvaluator$@JvmStatic fun mode(source: Any?, state: State?): Any?</ID>
    <ID>NestedBlockDepth:NodeMatcher.kt$NodeMatcher$override fun matchesSafely(node: Profile.Node): Boolean</ID>
    <ID>NestedBlockDepth:ProperContainsEvaluator.kt$ProperContainsEvaluator$fun properContains(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>NestedBlockDepth:QueryEvaluator.kt$QueryEvaluator$private fun evaluateRelationships( elm: Query, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Boolean</ID>
    <ID>NestedBlockDepth:RetrieveEvaluator.kt$RetrieveEvaluator$fun internalEvaluate( elm: Retrieve?, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any</ID>
    <ID>NestedBlockDepth:State.kt$State$fun resolveIdentifierRef(name: String): Any?</ID>
    <ID>NestedBlockDepth:SystemDataProvider.kt$SystemDataProvider$private fun getWriteAccessor(clazz: Class&lt;*>, path: String?): Method</ID>
    <ID>NestedBlockDepth:ToDecimalEvaluator.kt$ToDecimalEvaluator$@JvmStatic fun toDecimal(operand: Any?): Any?</ID>
    <ID>NestedBlockDepth:ToIntegerEvaluator.kt$ToIntegerEvaluator$@JvmStatic fun toInteger(operand: Any?): Any?</ID>
    <ID>NestedBlockDepth:ToLongEvaluator.kt$ToLongEvaluator$@JvmStatic fun toLong(operand: Any?): Any?</ID>
    <ID>NestedBlockDepth:VarianceEvaluator.kt$VarianceEvaluator$@JvmStatic fun variance(source: Any?, state: State?): Any?</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _1900_01_01 = DateTime("1900-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _1900_01_01_TO_1901_01_01 = Interval(_1900_01_01, true, _1901_01_01, false)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _1901_01_01 = DateTime("1901-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2021_01_01 = DateTime("2021-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2021_01_01_TO_2022_01_01 = Interval(_2021_01_01, true, _2022_01_01, false)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2022_01_01 = DateTime("2022-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2022_01_01_TO_2023_01_01 = Interval(_2022_01_01, true, _2023_01_01, false)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2023_01_01 = DateTime("2023-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2023_01_01_TO_2024_01_01 = Interval(_2023_01_01, true, _2024_01_01, false)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2024_01_01 = DateTime("2024-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2031_01_01 = DateTime("2031-01-01", ZoneOffset.UTC)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2031_01_01_TO_2032_01_01 = Interval(_2031_01_01, true, _2032_01_01, false)</ID>
    <ID>ObjectPropertyNaming:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$private val _2032_01_01 = DateTime("2032-01-01", ZoneOffset.UTC)</ID>
    <ID>ProtectedMemberInFinalClass:Cache.kt$Cache$protected fun constructLibraryExpressionHashMap(): MutableMap&lt;String?, ExpressionResult?></ID>
    <ID>ProtectedMemberInFinalClass:Cache.kt$Cache$protected fun getExpressionCache( libraryId: VersionedIdentifier? ): MutableMap&lt;String?, ExpressionResult?>?</ID>
    <ID>ReturnCount:AbsEvaluator.kt$AbsEvaluator$@JvmStatic fun abs(operand: Any?): Any?</ID>
    <ID>ReturnCount:AddEvaluator.kt$AddEvaluator$@JvmStatic fun add(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:AfterEvaluator.kt$AfterEvaluator$@JvmStatic fun after(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:AllTrueEvaluator.kt$AllTrueEvaluator$@JvmStatic fun allTrue(src: Any?): Boolean?</ID>
    <ID>ReturnCount:AndEvaluator.kt$AndEvaluator$@JvmStatic fun and(left: Any?, right: Any?): Boolean?</ID>
    <ID>ReturnCount:AnyInCodeSystemEvaluator.kt$AnyInCodeSystemEvaluator$@JvmStatic fun internalEvaluate( codes: Any?, codeSystemRef: CodeSystemRef?, codeSystem: Any?, state: State?, ): Any?</ID>
    <ID>ReturnCount:AnyInValueSetEvaluator.kt$AnyInValueSetEvaluator$@JvmStatic fun internalEvaluate( codes: Any?, valueSetRef: ValueSetRef?, valueset: Any?, state: State?, ): Any?</ID>
    <ID>ReturnCount:AnyTrueEvaluator.kt$AnyTrueEvaluator$@JvmStatic fun anyTrue(src: Any?): Boolean?</ID>
    <ID>ReturnCount:BaseModelResolver.kt$BaseModelResolver$override fun `as`(value: Any?, type: Class&lt;*>?, isStrict: Boolean): Any?</ID>
    <ID>ReturnCount:BeforeEvaluator.kt$BeforeEvaluator$@JvmStatic fun before(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:CachingModelResolverDecorator.kt$CachingModelResolverDecorator$override fun getContextPath(contextType: String?, targetType: String?): Any?</ID>
    <ID>ReturnCount:CachingModelResolverDecorator.kt$CachingModelResolverDecorator$override fun resolveType(typeName: String?): Class&lt;*>?</ID>
    <ID>ReturnCount:CachingModelResolverDecorator.kt$CachingModelResolverDecorator$override fun resolveType(value: Any?): Class&lt;*>?</ID>
    <ID>ReturnCount:CeilingEvaluator.kt$CeilingEvaluator$@JvmStatic fun ceiling(operand: Any?): Any?</ID>
    <ID>ReturnCount:CoalesceEvaluator.kt$CoalesceEvaluator$fun coalesce(operands: List&lt;Any?>): Any?</ID>
    <ID>ReturnCount:CollapseEvaluator.kt$CollapseEvaluator$fun collapse(list: Iterable&lt;Interval?>?, per: Quantity?, state: State?): List&lt;Interval?>?</ID>
    <ID>ReturnCount:CollapseEvaluator.kt$CollapseEvaluator$private fun getIntervalWithPerApplied( interval: Interval, per: Quantity, state: State?, ): Interval</ID>
    <ID>ReturnCount:CombineEvaluator.kt$CombineEvaluator$@JvmStatic fun combine(source: Any?, separator: String?): Any?</ID>
    <ID>ReturnCount:Concept.kt$Concept$override fun equivalent(other: Any?): Boolean?</ID>
    <ID>ReturnCount:ContainsEvaluator.kt$ContainsEvaluator$@JvmStatic fun internalEvaluate( left: Any?, right: Any?, expression: Any?, precision: String?, state: State?, ): Any?</ID>
    <ID>ReturnCount:ConvertQuantityEvaluator.kt$ConvertQuantityEvaluator$@JvmStatic fun convertQuantity(argument: Any?, unit: Any?, ucumService: UcumService?): Any?</ID>
    <ID>ReturnCount:ConvertsToBooleanEvaluator.kt$ConvertsToBooleanEvaluator$@JvmStatic fun convertsToBoolean(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToDateEvaluator.kt$ConvertsToDateEvaluator$@JvmStatic fun convertsToDate(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToDateTimeEvaluator.kt$ConvertsToDateTimeEvaluator$@JvmStatic fun convertsToDateTime(argument: Any?, offset: ZoneOffset?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToDecimalEvaluator.kt$ConvertsToDecimalEvaluator$@JvmStatic fun convertsToDecimal(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToIntegerEvaluator.kt$ConvertsToIntegerEvaluator$@JvmStatic fun convertsToInteger(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToLongEvaluator.kt$ConvertsToLongEvaluator$@JvmStatic fun convertsToLong(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$@JvmStatic fun convertsToQuantity(argument: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:ConvertsToTimeEvaluator.kt$ConvertsToTimeEvaluator$@JvmStatic fun convertsToTime(argument: Any?): Boolean?</ID>
    <ID>ReturnCount:CountEvaluator.kt$CountEvaluator$@JvmStatic fun count(source: Any?): Any?</ID>
    <ID>ReturnCount:CqlList.kt$CqlList$fun compareTo(left: Any?, right: Any?): Int</ID>
    <ID>ReturnCount:CqlList.kt$CqlList.Companion$fun equal(left: Iterable&lt;*>, right: Iterable&lt;*>, state: State?): Boolean?</ID>
    <ID>ReturnCount:CqlList.kt$CqlList.Companion$fun equivalent(left: Iterable&lt;*>, right: Iterable&lt;*>, state: State?): Boolean</ID>
    <ID>ReturnCount:Date.kt$Date$override fun compare(other: BaseTemporal, forSort: Boolean): Int?</ID>
    <ID>ReturnCount:Date.kt$Date$override fun compareToPrecision(other: BaseTemporal, p: Precision): Int?</ID>
    <ID>ReturnCount:Date.kt$Date$override fun roundToPrecision(precision: Precision, useCeiling: Boolean): BaseTemporal</ID>
    <ID>ReturnCount:DateFromEvaluator.kt$DateFromEvaluator$@JvmStatic fun dateFrom(operand: Any?): Date?</ID>
    <ID>ReturnCount:DateTime.kt$DateTime$override fun compare(other: BaseTemporal, forSort: Boolean): Int?</ID>
    <ID>ReturnCount:DateTime.kt$DateTime$override fun compareToPrecision(other: BaseTemporal, p: Precision): Int?</ID>
    <ID>ReturnCount:DateTime.kt$DateTime$override fun roundToPrecision(precision: Precision, useCeiling: Boolean): BaseTemporal</ID>
    <ID>ReturnCount:DateTime.kt$DateTime$override fun toString(): String</ID>
    <ID>ReturnCount:DateTimeComponentFromEvaluator.kt$DateTimeComponentFromEvaluator$@JvmStatic fun dateTimeComponentFrom(operand: Any?, precision: String?): Any?</ID>
    <ID>ReturnCount:DifferenceBetweenEvaluator.kt$DifferenceBetweenEvaluator$@JvmStatic fun difference(left: Any?, right: Any?, precision: Precision): Any?</ID>
    <ID>ReturnCount:DivideEvaluator.kt$DivideEvaluator$@JvmStatic fun divide(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:DivideEvaluator.kt$DivideEvaluator$private fun divideHelper(left: BigDecimal, right: BigDecimal?, state: State?): BigDecimal?</ID>
    <ID>ReturnCount:DurationBetweenEvaluator.kt$DurationBetweenEvaluator$@JvmStatic fun duration(left: Any?, right: Any?, precision: Precision?): Any?</ID>
    <ID>ReturnCount:EndsEvaluator.kt$EndsEvaluator$@JvmStatic fun ends(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:Environment.kt$Environment$fun `as`(operand: Any?, type: Class&lt;*>, isStrict: Boolean): Any?</ID>
    <ID>ReturnCount:Environment.kt$Environment$fun `is`(operand: Any?, type: Class&lt;*>): Boolean?</ID>
    <ID>ReturnCount:Environment.kt$Environment$fun objectEquivalent(left: Any?, right: Any?): Boolean?</ID>
    <ID>ReturnCount:Environment.kt$Environment$fun resolveType(value: Any?): Class&lt;*>?</ID>
    <ID>ReturnCount:EqualEvaluator.kt$EqualEvaluator$@JvmStatic @JvmOverloads fun equal(left: Any?, right: Any?, state: State? = null): Boolean?</ID>
    <ID>ReturnCount:EquivalentEvaluator.kt$EquivalentEvaluator$@JvmStatic @JvmOverloads fun equivalent(left: Any?, right: Any?, state: State? = null): Boolean?</ID>
    <ID>ReturnCount:EvaluationResultsForMultiLib.kt$EvaluationResultsForMultiLib$fun getExceptionFor(libraryIdentifier: VersionedIdentifier): RuntimeException?</ID>
    <ID>ReturnCount:EvaluationResultsForMultiLib.kt$EvaluationResultsForMultiLib$fun getResultFor(libraryIdentifier: VersionedIdentifier?): EvaluationResult?</ID>
    <ID>ReturnCount:EvaluationResultsForMultiLib.kt$EvaluationResultsForMultiLib$fun getWarningFor(libraryIdentifier: VersionedIdentifier): RuntimeException?</ID>
    <ID>ReturnCount:EvaluationVisitor.kt$EvaluationVisitor$override fun visitCase(elm: Case, context: State?): Any?</ID>
    <ID>ReturnCount:ExceptEvaluator.kt$ExceptEvaluator$@JvmStatic fun except(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:ExpandEvaluator.kt$ExpandEvaluator$@JvmStatic fun expand(listOrInterval: Any?, per: Quantity?, state: State?): Any?</ID>
    <ID>ReturnCount:ExpandEvaluator.kt$ExpandEvaluator$private fun expandIntervalIntoIntervals( interval: Interval, per: Quantity, state: State?, ): List&lt;Interval?>?</ID>
    <ID>ReturnCount:ExpandEvaluator.kt$ExpandEvaluator$private fun expandIntervalsIntoIntervals( list: Iterable&lt;Interval?>, per: Quantity?, state: State?, ): List&lt;Interval?>?</ID>
    <ID>ReturnCount:FirstEvaluator.kt$FirstEvaluator$@JvmStatic fun first(source: Any?): Any?</ID>
    <ID>ReturnCount:FloorEvaluator.kt$FloorEvaluator$@JvmStatic fun floor(operand: Any?): Any?</ID>
    <ID>ReturnCount:FunctionRefEvaluator.kt$FunctionRefEvaluator$@JvmStatic fun operandDefTypeSpecifierEqual( operandDef: OperandDef, typeSpecifier: TypeSpecifier?, ): kotlin.Boolean</ID>
    <ID>ReturnCount:GreaterEvaluator.kt$GreaterEvaluator$@JvmStatic fun greater(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:GreaterOrEqualEvaluator.kt$GreaterOrEqualEvaluator$@JvmStatic fun greaterOrEqual(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:HighBoundaryEvaluator.kt$HighBoundaryEvaluator$@JvmStatic fun highBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>ReturnCount:ImpliesEvaluator.kt$ImpliesEvaluator$@JvmStatic fun implies(left: Boolean?, right: Boolean?): Any?</ID>
    <ID>ReturnCount:InCodeSystemEvaluator.kt$InCodeSystemEvaluator$@JvmStatic fun inCodeSystem(code: Any?, codeSystem: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:InEvaluator.kt$InEvaluator$fun `in`(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:InEvaluator.kt$InEvaluator$private fun intervalIn( left: Any?, right: Interval, precision: String?, state: State?, ): Boolean?</ID>
    <ID>ReturnCount:InEvaluator.kt$InEvaluator$private fun listIn(left: Any?, right: Iterable&lt;*>, state: State?): Boolean</ID>
    <ID>ReturnCount:InValueSetEvaluator.kt$InValueSetEvaluator$@JvmStatic fun inValueSet(code: Any?, valueset: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:IncludedInEvaluator.kt$IncludedInEvaluator$@JvmStatic fun internalEvaluate(left: Any?, right: Any?, precision: String?, state: State?): Any?</ID>
    <ID>ReturnCount:IncludedInEvaluator.kt$IncludedInEvaluator$fun intervalIncludedIn( left: Interval?, right: Interval?, precision: String?, state: State?, ): Boolean?</ID>
    <ID>ReturnCount:IncludedInEvaluator.kt$IncludedInEvaluator$fun listIncludedIn(left: Iterable&lt;*>?, right: Iterable&lt;*>?, state: State?): Boolean?</ID>
    <ID>ReturnCount:IncludesEvaluator.kt$IncludesEvaluator$@JvmStatic fun internalEvaluate(left: Any?, right: Any?, precision: String?, state: State?): Any?</ID>
    <ID>ReturnCount:IndexOfEvaluator.kt$IndexOfEvaluator$@JvmStatic fun indexOf(source: Any?, elementToFind: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:IndexerEvaluator.kt$IndexerEvaluator$@JvmStatic fun indexer(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:IntersectEvaluator.kt$IntersectEvaluator$@JvmStatic fun intersect(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:Interval.kt$Interval$override fun equal(other: Any?): Boolean?</ID>
    <ID>ReturnCount:IntervalHelper.kt$IntervalHelper.Companion$fun isQuantityCompatibleWithBoundaries( quantity: Quantity, intervals: List&lt;Interval?>, ): Boolean</ID>
    <ID>ReturnCount:IntervalHelper.kt$IntervalHelper.Companion$fun quantityFromCoarsestPrecisionOfBoundaries(intervals: List&lt;Interval?>): Quantity</ID>
    <ID>ReturnCount:IntervalHelper.kt$IntervalHelper.Companion$fun truncateIntervalBoundaries( interval: Interval, quantity: Quantity, state: State?, ): Interval?</ID>
    <ID>ReturnCount:LengthEvaluator.kt$LengthEvaluator$@JvmStatic fun internalEvaluate(operand: Any?, length: Length?, state: State?): Any?</ID>
    <ID>ReturnCount:LessEvaluator.kt$LessEvaluator$@JvmStatic fun less(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:LessOrEqualEvaluator.kt$LessOrEqualEvaluator$@JvmStatic fun lessOrEqual(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:LiteralEvaluator.kt$LiteralEvaluator$@JvmStatic fun internalEvaluate(valueT: QName?, value: String?, state: State?): Any?</ID>
    <ID>ReturnCount:LnEvaluator.kt$LnEvaluator$@JvmStatic fun ln(operand: Any?): Any?</ID>
    <ID>ReturnCount:LogEvaluator.kt$LogEvaluator$@JvmStatic fun log(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:LowBoundaryEvaluator.kt$LowBoundaryEvaluator$@JvmStatic fun lowBoundary(input: Any?, precision: Any?): Any?</ID>
    <ID>ReturnCount:MaxEvaluator.kt$MaxEvaluator$@JvmStatic fun max(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:MaxValueEvaluator.kt$MaxValueEvaluator$@JvmStatic fun maxValue(type: String?): Any?</ID>
    <ID>ReturnCount:MedianEvaluator.kt$MedianEvaluator$@JvmStatic fun median(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:MeetsAfterEvaluator.kt$MeetsAfterEvaluator$@JvmStatic fun meetsAfter(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:MeetsBeforeEvaluator.kt$MeetsBeforeEvaluator$@JvmStatic fun meetsBefore(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:MeetsEvaluator.kt$MeetsEvaluator$@JvmStatic fun meets(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:MeetsEvaluator.kt$MeetsEvaluator$fun meetsOperation(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:MinEvaluator.kt$MinEvaluator$@JvmStatic fun min(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:MinValueEvaluator.kt$MinValueEvaluator$@JvmStatic fun minValue(type: String?): Any?</ID>
    <ID>ReturnCount:ModeEvaluator.kt$ModeEvaluator$@JvmStatic fun mode(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:ModuloEvaluator.kt$ModuloEvaluator$@JvmStatic fun modulo(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:MultiplyEvaluator.kt$MultiplyEvaluator$@JvmStatic fun multiply(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:NegateEvaluator.kt$NegateEvaluator$fun internalEvaluate( operand: Expression, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>ReturnCount:NegateEvaluator.kt$NegateEvaluator$fun negate(source: Any?): Any?</ID>
    <ID>ReturnCount:NodeMatcher.kt$NodeMatcher$override fun matchesSafely(node: Profile.Node): Boolean</ID>
    <ID>ReturnCount:OrEvaluator.kt$OrEvaluator$@JvmStatic fun or(left: Any?, right: Any?): Boolean?</ID>
    <ID>ReturnCount:OverlapsAfterEvaluator.kt$OverlapsAfterEvaluator$@JvmStatic fun overlapsAfter(left: Any?, right: Any?, precision: String?, state: State?): Any?</ID>
    <ID>ReturnCount:OverlapsBeforeEvaluator.kt$OverlapsBeforeEvaluator$@JvmStatic fun overlapsBefore(left: Any?, right: Any?, precision: String?, state: State?): Any?</ID>
    <ID>ReturnCount:OverlapsEvaluator.kt$OverlapsEvaluator$@JvmStatic fun overlaps(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:ParameterRefEvaluator.kt$ParameterRefEvaluator$fun internalEvaluate( parameterRef: ParameterRef?, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>ReturnCount:PopulationStdDevEvaluator.kt$PopulationStdDevEvaluator$@JvmStatic fun popStdDev(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:PopulationVarianceEvaluator.kt$PopulationVarianceEvaluator$@JvmStatic fun popVariance(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:PowerEvaluator.kt$PowerEvaluator$@JvmStatic fun power(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:Precision.kt$Precision.Companion$fun fromString(precision: String): Precision</ID>
    <ID>ReturnCount:PrecisionEvaluator.kt$PrecisionEvaluator$@JvmStatic fun precision(argument: Any?): Int?</ID>
    <ID>ReturnCount:PredecessorEvaluator.kt$PredecessorEvaluator$@JvmStatic fun predecessor(value: Any?): Any?</ID>
    <ID>ReturnCount:PredecessorEvaluator.kt$PredecessorEvaluator$@JvmStatic fun predecessor(value: Any?, quantity: Quantity): Any?</ID>
    <ID>ReturnCount:ProductEvaluator.kt$ProductEvaluator$@JvmStatic fun product(source: Any?): Any?</ID>
    <ID>ReturnCount:ProperContainsEvaluator.kt$ProperContainsEvaluator$fun properContains(left: Any?, right: Any?, state: State?): Boolean?</ID>
    <ID>ReturnCount:ProperIncludedInEvaluator.kt$ProperIncludedInEvaluator$@JvmStatic fun properlyIncludedIn(left: Any?, right: Any?, precision: String?, state: State?): Any?</ID>
    <ID>ReturnCount:ProperIncludesEvaluator.kt$ProperIncludesEvaluator$@JvmStatic fun properlyIncludes(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:ProperIncludesEvaluator.kt$ProperIncludesEvaluator$fun intervalProperlyIncludes( left: Interval?, right: Interval?, precision: String?, state: State?, ): Boolean?</ID>
    <ID>ReturnCount:ProperIncludesEvaluator.kt$ProperIncludesEvaluator$fun listProperlyIncludes(left: Iterable&lt;*>?, right: Iterable&lt;*>?, state: State?): Boolean?</ID>
    <ID>ReturnCount:PropertyEvaluator.kt$PropertyEvaluator$fun internalEvaluate( elm: Property?, state: State?, visitor: ElmLibraryVisitor&lt;Any?, State?>, ): Any?</ID>
    <ID>ReturnCount:Quantity.kt$Quantity.Companion$fun unitsEqual(leftUnit: String?, rightUnit: String?): Boolean</ID>
    <ID>ReturnCount:Quantity.kt$Quantity.Companion$fun unitsEquivalent(leftUnit: String?, rightUnit: String?): Boolean</ID>
    <ID>ReturnCount:RoundEvaluator.kt$RoundEvaluator$@JvmStatic fun round(operand: Any?, precision: Any?): Any?</ID>
    <ID>ReturnCount:SameAsEvaluator.kt$SameAsEvaluator$@JvmStatic fun sameAs(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:SameOrAfterEvaluator.kt$SameOrAfterEvaluator$@JvmStatic fun sameOrAfter(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:SameOrAfterEvaluator.kt$SameOrAfterEvaluator$fun onOrAfter(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:SameOrBeforeEvaluator.kt$SameOrBeforeEvaluator$@JvmStatic fun sameOrBefore(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:SameOrBeforeEvaluator.kt$SameOrBeforeEvaluator$fun onOrBefore(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:SliceEvaluator.kt$SliceEvaluator$@JvmStatic fun slice(source: Any?, start: Int?, end: Int?): Any?</ID>
    <ID>ReturnCount:StartsEvaluator.kt$StartsEvaluator$@JvmStatic fun starts(left: Any?, right: Any?, precision: String?, state: State?): Boolean?</ID>
    <ID>ReturnCount:State.kt$State$fun resolveIdentifierRef(name: String): Any?</ID>
    <ID>ReturnCount:StdDevEvaluator.kt$StdDevEvaluator$@JvmStatic fun stdDev(source: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:SubstringEvaluator.kt$SubstringEvaluator$@JvmStatic fun substring(stringValue: Any?, startIndexValue: Any?, lengthValue: Any?): Any?</ID>
    <ID>ReturnCount:SubtractEvaluator.kt$SubtractEvaluator$@JvmStatic fun subtract(left: Any?, right: Any?): Any?</ID>
    <ID>ReturnCount:SuccessorEvaluator.kt$SuccessorEvaluator$@JvmStatic fun successor(value: Any?): Any?</ID>
    <ID>ReturnCount:SuccessorEvaluator.kt$SuccessorEvaluator$@JvmStatic fun successor(value: Any?, quantity: Quantity??): Any?</ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$override fun objectEqual(left: Any?, right: Any?): Boolean?</ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$override fun objectEquivalent(left: Any?, right: Any?): Boolean?</ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$override fun resolvePath(target: Any?, path: String?): Any?</ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$override fun resolveType(typeName: String?): Class&lt;*></ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$private fun getReadAccessor(clazz: Class&lt;*>, path: String?): Method?</ID>
    <ID>ReturnCount:SystemDataProvider.kt$SystemDataProvider$private fun getWriteAccessor(clazz: Class&lt;*>, path: String?): Method</ID>
    <ID>ReturnCount:TemporalHelper.kt$TemporalHelper$fun truncateValueToTargetPrecision( value: Long, precision: Precision, targetPrecision: Precision?, ): Long</ID>
    <ID>ReturnCount:Time.kt$Time$override fun compare(other: BaseTemporal, forSort: Boolean): Int?</ID>
    <ID>ReturnCount:Time.kt$Time$override fun compareToPrecision(other: BaseTemporal, p: Precision): Int?</ID>
    <ID>ReturnCount:TimeFromEvaluator.kt$TimeFromEvaluator$@JvmStatic fun timeFrom(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToBooleanEvaluator.kt$ToBooleanEvaluator$@JvmStatic fun toBoolean(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToConceptEvaluator.kt$ToConceptEvaluator$@JvmStatic fun toConcept(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToDateEvaluator.kt$ToDateEvaluator$@JvmStatic fun toDate(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToDateTimeEvaluator.kt$ToDateTimeEvaluator$@JvmStatic fun toDateTime(operand: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:ToDecimalEvaluator.kt$ToDecimalEvaluator$@JvmStatic fun toDecimal(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToIntegerEvaluator.kt$ToIntegerEvaluator$@JvmStatic fun toInteger(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToLongEvaluator.kt$ToLongEvaluator$@JvmStatic fun toLong(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToQuantityEvaluator.kt$ToQuantityEvaluator$@JvmStatic fun toQuantity(operand: Any?, state: State?): Quantity?</ID>
    <ID>ReturnCount:ToQuantityEvaluator.kt$ToQuantityEvaluator$private fun setValue(quantity: Quantity, str: String): Quantity?</ID>
    <ID>ReturnCount:ToRatioEvaluator.kt$ToRatioEvaluator$@JvmStatic fun toRatio(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToStringEvaluator.kt$ToStringEvaluator$@JvmStatic fun toString(operand: Any?): Any?</ID>
    <ID>ReturnCount:ToTimeEvaluator.kt$ToTimeEvaluator$@JvmStatic fun toTime(operand: Any?): Any?</ID>
    <ID>ReturnCount:TruncateEvaluator.kt$TruncateEvaluator$@JvmStatic fun truncate(operand: Any?): Any?</ID>
    <ID>ReturnCount:TruncatedDivideEvaluator.kt$TruncatedDivideEvaluator$@JvmStatic fun div(left: Any?, right: Any?, state: State?): Any?</ID>
    <ID>ReturnCount:Tuple.kt$Tuple$override fun equal(other: Any?): Boolean?</ID>
    <ID>ReturnCount:Tuple.kt$Tuple$override fun equivalent(other: Any?): Boolean?</ID>
    <ID>ReturnCount:UnionEvaluator.kt$UnionEvaluator$@JvmStatic fun unionInterval(left: Interval?, right: Interval?, state: State?): Interval?</ID>
    <ID>ReturnCount:UnionEvaluator.kt$UnionEvaluator$fun unionIterable(left: Iterable&lt;*>?, right: Iterable&lt;*>?, state: State?): Iterable&lt;*>?</ID>
    <ID>ReturnCount:Value.kt$Value$fun validateDecimal(ret: BigDecimal, targetScale: Int?): BigDecimal?</ID>
    <ID>ReturnCount:ValueSet.kt$ValueSet$fun getCodeSystem(id: String?): CodeSystem?</ID>
    <ID>ReturnCount:ValueSet.kt$ValueSet$fun getCodeSystem(id: String?, version: String?): CodeSystem?</ID>
    <ID>ReturnCount:ValueSet.kt$ValueSet$override fun equal(other: Any?): Boolean?</ID>
    <ID>ReturnCount:ValueSet.kt$ValueSet$override fun equivalent(other: Any?): Boolean?</ID>
    <ID>ReturnCount:VarianceEvaluator.kt$VarianceEvaluator$@JvmStatic fun variance(source: Any?, state: State?): Any?</ID>
    <ID>SpreadOperator:DateTime.kt$DateTime$(*dateElements)</ID>
    <ID>SpreadOperator:DateTimeEvaluator.kt$DateTimeEvaluator$( timeZoneOffset!!, *TemporalHelper.cleanArray(year, month, day, hour, minute, second, milliSecond), )</ID>
    <ID>SpreadOperator:IntervalHelper.kt$IntervalHelper.Companion$( *(intervals .filter { obj -> obj != null } .flatMap { interval -> listOf( interval!!.start as BaseTemporal?, interval.end as BaseTemporal?, ) } .toTypedArray()) )</ID>
    <ID>SpreadOperator:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$( staticFunction.getDeclaringClass(), *arguments!!.toTypedArray(), )</ID>
    <ID>SpreadOperator:Time.kt$Time$(*timeElements)</ID>
    <ID>SpreadOperator:TimeEvaluator.kt$TimeEvaluator$(*TemporalHelper.cleanArray(hour, minute, second, miliSecond))</ID>
    <ID>SwallowedException:ContainsEvaluator.kt$ContainsEvaluator$e: InvalidOperatorArgument</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: ExceptionInInitializerError</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: IllegalAccessException</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: InstantiationException</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: InvocationTargetException</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: NoSuchMethodException</ID>
    <ID>SwallowedException:ConvertEvaluator.kt$ConvertEvaluator$e: SecurityException</ID>
    <ID>SwallowedException:ConvertQuantityEvaluator.kt$ConvertQuantityEvaluator$e: Exception</ID>
    <ID>SwallowedException:ConvertsToDateTimeEvaluator.kt$ConvertsToDateTimeEvaluator$e: Exception</ID>
    <ID>SwallowedException:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$e: Exception</ID>
    <ID>SwallowedException:CqlAggregateFunctionsTest.kt$CqlAggregateFunctionsTest$e: InvalidOperatorArgument</ID>
    <ID>SwallowedException:CqlArithmeticFunctionsTest.kt$CqlArithmeticFunctionsTest$e: CqlException</ID>
    <ID>SwallowedException:DebugResult.kt$DebugResult$e: Exception</ID>
    <ID>SwallowedException:DivideEvaluator.kt$DivideEvaluator$e: ArithmeticException</ID>
    <ID>SwallowedException:IncludesEvaluator.kt$IncludesEvaluator$e: IllegalArgumentException</ID>
    <ID>SwallowedException:IntervalHelper.kt$IntervalHelper.Companion$e: InvalidPrecision</ID>
    <ID>SwallowedException:ProperIncludedInEvaluator.kt$ProperIncludedInEvaluator$e: InvalidOperatorArgument</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: ClassNotFoundException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: ExceptionInInitializerError</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: IllegalAccessException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: InstantiationException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: InvocationTargetException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: NoSuchFieldException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: NoSuchMethodException</ID>
    <ID>SwallowedException:SystemDataProvider.kt$SystemDataProvider$e: SecurityException</ID>
    <ID>SwallowedException:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$e: Exception</ID>
    <ID>SwallowedException:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$e: IllegalAccessException</ID>
    <ID>SwallowedException:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$e: InvocationTargetException</ID>
    <ID>ThrowsCount:ConvertEvaluator.kt$ConvertEvaluator$private fun convert(operand: Any?, type: Class&lt;*>): Any?</ID>
    <ID>ThrowsCount:ExpEvaluator.kt$ExpEvaluator$@JvmStatic fun exp(operand: Any?): Any?</ID>
    <ID>ThrowsCount:LiteralEvaluator.kt$LiteralEvaluator$@JvmStatic fun internalEvaluate(valueT: QName?, value: String?, state: State?): Any?</ID>
    <ID>ThrowsCount:LnEvaluator.kt$LnEvaluator$@JvmStatic fun ln(operand: Any?): Any?</ID>
    <ID>ThrowsCount:PredecessorEvaluator.kt$PredecessorEvaluator$@JvmStatic fun predecessor(value: Any?): Any?</ID>
    <ID>ThrowsCount:SuccessorEvaluator.kt$SuccessorEvaluator$@JvmStatic fun successor(value: Any?): Any?</ID>
    <ID>TooGenericExceptionCaught:ConvertQuantityEvaluator.kt$ConvertQuantityEvaluator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConvertsToDateTimeEvaluator.kt$ConvertsToDateTimeEvaluator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConvertsToQuantityEvaluator.kt$ConvertsToQuantityEvaluator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CqlEngine.kt$CqlEngine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CqlEngine.kt$CqlEngine$exception: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:DebugResult.kt$DebugResult$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EvaluationVisitor.kt$EvaluationVisitor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$e: Exception</ID>
    <ID>TooGenericExceptionThrown:State.kt$State$throw RuntimeException("Not supported")</ID>
    <ID>TooGenericExceptionThrown:State.kt$State$throw RuntimeException("Stack underflow")</ID>
    <ID>TooGenericExceptionThrown:SystemExternalFunctionProvider.kt$SystemExternalFunctionProvider$throw RuntimeException( "Error when executing function [" + staticFunctionName + "]: \n" + e.toString() )</ID>
    <ID>TooManyFunctions:CachingModelResolverDecorator.kt$CachingModelResolverDecorator : ModelResolver</ID>
    <ID>TooManyFunctions:CompositeDataProvider.kt$CompositeDataProvider : DataProvider</ID>
    <ID>TooManyFunctions:CqlEngine.kt$CqlEngine</ID>
    <ID>TooManyFunctions:Date.kt$Date : BaseTemporal</ID>
    <ID>TooManyFunctions:DateTime.kt$DateTime : BaseTemporal</ID>
    <ID>TooManyFunctions:Environment.kt$Environment</ID>
    <ID>TooManyFunctions:EvaluationVisitor.kt$EvaluationVisitor : BaseElmLibraryVisitor</ID>
    <ID>TooManyFunctions:ModelResolver.kt$ModelResolver</ID>
    <ID>TooManyFunctions:Precision.kt$Precision$Companion</ID>
    <ID>TooManyFunctions:State.kt$State</ID>
    <ID>TooManyFunctions:SystemDataProvider.kt$SystemDataProvider : BaseModelResolverDataProvider</ID>
    <ID>TooManyFunctions:TemporalHelper.kt$TemporalHelper</ID>
    <ID>TooManyFunctions:Time.kt$Time : BaseTemporal</ID>
    <ID>TooManyFunctions:ValueSet.kt$ValueSet : Vocabulary</ID>
    <ID>UnusedParameter:CollapseEvaluator.kt$CollapseEvaluator$state: State?</ID>
    <ID>UnusedParameter:LengthEvaluator.kt$LengthEvaluator$state: State?</ID>
    <ID>UnusedParameter:NullEvaluator.kt$NullEvaluator$state: State?</ID>
    <ID>UnusedParameter:QuantityEvaluator.kt$QuantityEvaluator$state: State?</ID>
    <ID>UnusedParameter:RepeatEvaluator.kt$RepeatEvaluator$element: Any?</ID>
    <ID>UnusedParameter:RepeatEvaluator.kt$RepeatEvaluator$scope: String?</ID>
    <ID>UnusedParameter:RepeatEvaluator.kt$RepeatEvaluator$source: Any?</ID>
    <ID>UnusedParameter:RepeatEvaluator.kt$RepeatEvaluator$state: State?</ID>
    <ID>UnusedParameter:State.kt$State$library: Library?</ID>
    <ID>UnusedPrivateMember:CqlEngineMultipleLibrariesTest.kt$CqlEngineMultipleLibrariesTest.Companion$@JvmStatic private fun libraryWithVersionQueriesParams(): Stream&lt;Arguments></ID>
    <ID>UnusedPrivateMember:CqlInternalTypeRepresentationSuiteTest.kt$CqlInternalTypeRepresentationSuiteTest.Companion$@JvmStatic private fun timeZones(): Array&lt;Array&lt;Any>></ID>
    <ID>UnusedPrivateMember:CqlPerformanceIT.kt$CqlPerformanceIT.Companion$@JvmStatic private fun engineOptionCombinations(): Stream&lt;MutableSet&lt;CqlEngine.Options>></ID>
    <ID>UnusedPrivateMember:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun bigDecimals(): Array&lt;Array&lt;Any?>?></ID>
    <ID>UnusedPrivateMember:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun dateStrings(): Array&lt;Array&lt;Any>></ID>
    <ID>UnusedPrivateMember:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun dateStringsOtherZoneId(): Array&lt;Array&lt;Any>></ID>
    <ID>UnusedPrivateMember:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun offsetPrecisions(): Array&lt;Array&lt;Any>></ID>
    <ID>UnusedPrivateMember:DateTimeTest.kt$DateTimeTest.Companion$@JvmStatic private fun timeZones(): Array&lt;Array&lt;Any>></ID>
    <ID>UnusedPrivateMember:DebugMap.kt$DebugMap$private fun ensureLibraryMap(libraryName: String?): DebugLibraryMapEntry</ID>
    <ID>UnusedPrivateMember:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$@JvmStatic private fun evaluateWithMatchedLibraryIdsParams(): Stream&lt;Arguments></ID>
    <ID>UnusedPrivateMember:InvalidCqlLibraryIdentifierMismatchTest.kt$InvalidCqlLibraryIdentifierMismatchTest.Companion$@JvmStatic private fun evaluateWithMismatchedLibraryIdsParams(): Stream&lt;Arguments></ID>
    <ID>UnusedPrivateProperty:CqlArithmeticFunctionsTest.kt$CqlArithmeticFunctionsTest$val value = AbsEvaluator.abs("This is an error")</ID>
    <ID>UnusedPrivateProperty:CqlArithmeticFunctionsTest.kt$CqlArithmeticFunctionsTest$val value = AddEvaluator.add("This is an error", 404)</ID>
    <ID>UnusedPrivateProperty:CqlPerformanceIT.kt$CqlPerformanceIT$i</ID>
    <ID>UnusedPrivateProperty:CqlPerformanceIT.kt$CqlPerformanceIT$val results = engine.evaluate(libraryId, null, null, null, null, evaluationZonedDateTime)</ID>
    <ID>UnusedPrivateProperty:GreaterEvaluator.kt$GreaterEvaluator$private val logger: Logger? = LoggerFactory.getLogger(GreaterEvaluator::class.java)</ID>
    <ID>UnusedPrivateProperty:QueryIterator.kt$QueryIterator$state: State?</ID>
    <ID>UseCheckOrError:DateTime.kt$DateTime$throw IllegalStateException("There must be a non-null offset!")</ID>
    <ID>UseCheckOrError:IntervalHelper.kt$IntervalHelper$throw IllegalStateException("Utility class")</ID>
    <ID>UseCheckOrError:State.kt$State$throw IllegalStateException( "Could not resolve alias reference $name in the current context" )</ID>
    <ID>UtilityClassWithPublicConstructor:MyMath.kt$MyMath</ID>
    <ID>UtilityClassWithPublicConstructor:MyMath2.kt$MyMath2</ID>
    <ID>VariableNaming:CachingModelResolverDecoratorTest.kt$CachingModelResolverDecoratorTest$val `object` = "object"</ID>
    <ID>VariableNaming:CachingModelResolverDecoratorTest.kt$CachingModelResolverDecoratorTest$val `object` = 1L</ID>
    <ID>VariableNaming:CachingModelResolverDecoratorTest.kt$CachingModelResolverDecoratorTest$val `object` = Date()</ID>
    <ID>VariableNaming:CompositeDataProviderTest.kt$CompositeDataProviderTest$val `object` = "object"</ID>
    <ID>VariableNaming:CompositeDataProviderTest.kt$CompositeDataProviderTest$val `object` = 1L</ID>
    <ID>VariableNaming:CompositeDataProviderTest.kt$CompositeDataProviderTest$val `object` = Date()</ID>
    <ID>VariableNaming:CqlEngine.kt$CqlEngine$val `object` = this.evaluationVisitor.visitExpressionDef(def, this.state)</ID>
    <ID>VariableNaming:EvaluationVisitor.kt$EvaluationVisitor$val `when` = visitExpression(caseItem.`when`!!, context)</ID>
    <ID>VariableNaming:EvaluationVisitor.kt$EvaluationVisitor$val `when` = visitExpression(caseItem.`when`!!, context) as Boolean? ?: continue</ID>
  </CurrentIssues>
</SmellBaseline>
